###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.42.1.142 for STM8               01/Jul/2016  17:30:46 #
# Copyright 2010-2013 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  E:\hwpro-2016\20160627_L\utils\lib\memb.c                #
#    Command line =  E:\hwpro-2016\20160627_L\utils\lib\memb.c -e -Ol         #
#                    --no_cse --no_unroll --no_inline --no_code_motion        #
#                    --no_tbaa --no_cross_call --debug --code_model medium    #
#                    --data_model medium -o E:\hwpro-2016\20160627_L\iar\Debu #
#                    g\Obj\ --dlib_config "C:\Program Files (x86)\IAR         #
#                    Systems\Embedded Workbench 6.5\stm8\LIB\dlstm8mmn.h" -D  #
#                    STM8L15X_MD -lC E:\hwpro-2016\20160627_L\iar\Debug\List\ #
#                     -I E:\hwpro-2016\20160627_L\iar\..\stm8l15x_lib\inc\    #
#                    -I E:\hwpro-2016\20160627_L\iar\..\user\inc\ -I          #
#                    E:\hwpro-2016\20160627_L\iar\..\utils\xprintf\ -I        #
#                    E:\hwpro-2016\20160627_L\iar\..\drivers\ -I              #
#                    E:\hwpro-2016\20160627_L\iar\..\utils\ -I                #
#                    E:\hwpro-2016\20160627_L\iar\..\app\ --vregs 16          #
#    List file    =  E:\hwpro-2016\20160627_L\iar\Debug\List\memb.lst         #
#    Object file  =  E:\hwpro-2016\20160627_L\iar\Debug\Obj\memb.o            #
#                                                                             #
#                                                                             #
###############################################################################

E:\hwpro-2016\20160627_L\utils\lib\memb.c
      1          /*
      2           * Copyright (c) 2004, Swedish Institute of Computer Science.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without
      6           * modification, are permitted provided that the following conditions
      7           * are met:
      8           * 1. Redistributions of source code must retain the above copyright
      9           *    notice, this list of conditions and the following disclaimer.
     10           * 2. Redistributions in binary form must reproduce the above copyright
     11           *    notice, this list of conditions and the following disclaimer in the
     12           *    documentation and/or other materials provided with the distribution.
     13           * 3. Neither the name of the Institute nor the names of its contributors
     14           *    may be used to endorse or promote products derived from this software
     15           *    without specific prior written permission.
     16           *
     17           * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
     18           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     19           * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     20           * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
     21           * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     22           * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
     23           * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
     24           * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
     25           * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
     26           * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
     27           * SUCH DAMAGE.
     28           *
     29           * This file is part of the Contiki operating system.
     30           *
     31           * Author: Adam Dunkels <adam@sics.se>
     32           *
     33           */
     34          
     35          /**
     36           * \addtogroup memb
     37           * @{
     38           */
     39          
     40           /**
     41           * \file
     42           * Memory block allocation routines.
     43           * \author Adam Dunkels <adam@sics.se>
     44           */
     45          #include <string.h>
     46          
     47          
     48          #include "lib/memb.h"
     49          
     50          /*---------------------------------------------------------------------------*/

   \                                 In section .far_func.text, align 1
     51          void
     52          memb_init(struct memb *m)
     53          {
   \                     memb_init:
   \   000000 8D ......    CALLF     L:?push_w4
   \   000004 BF ..        LDW       S:?w4, X
     54            memset(m->count, 0, m->num);
   \   000006 BE ..        LDW       X, S:?w4
   \   000008 1C 0002      ADDW      X, #0x2
   \   00000B FE           LDW       X, (X)
   \   00000C BF ..        LDW       S:?w0, X
   \   00000E 905F         CLRW      Y
   \   000010 BE ..        LDW       X, S:?w4
   \   000012 1C 0004      ADDW      X, #0x4
   \   000015 FE           LDW       X, (X)
   \   000016 8D ......    CALLF     memset
     55            memset(m->mem, 0, m->size * m->num);
   \   00001A BE ..        LDW       X, S:?w4
   \   00001C 1C 0002      ADDW      X, #0x2
   \   00001F FE           LDW       X, (X)
   \   000020 BF ..        LDW       S:?w0, X
   \   000022 92CE ..      LDW       X, [S:?w4.w]
   \   000025 9093         LDW       Y, X
   \   000027 93           LDW       X, Y
   \   000028 8D ......    CALLF     L:?mul16_x_x_w0
   \   00002C BF ..        LDW       S:?w0, X
   \   00002E 905F         CLRW      Y
   \   000030 BE ..        LDW       X, S:?w4
   \   000032 1C 0006      ADDW      X, #0x6
   \   000035 FE           LDW       X, (X)
   \   000036 8D ......    CALLF     memset
     56          }
   \   00003A AC ......    JPF       L:?epilogue_w4
     57          /*---------------------------------------------------------------------------*/

   \                                 In section .far_func.text, align 1
     58          void *
     59          memb_alloc(struct memb *m)
     60          {
   \                     memb_alloc:
   \   000000 BF ..        LDW       S:?w1, X
     61            int i;
     62          
     63            for(i = 0; i < m->num; ++i) {
   \   000002 3F ..        CLR       S:?b5
   \   000004 3F ..        CLR       S:?b4
   \   000006 20 05        JRA       L:??memb_alloc_0
   \                     ??memb_alloc_1:
   \   000008 BE ..        LDW       X, S:?w2
   \   00000A 5C           INCW      X
   \   00000B BF ..        LDW       S:?w2, X
   \                     ??memb_alloc_0:
   \   00000D BE ..        LDW       X, S:?w1
   \   00000F 1C 0002      ADDW      X, #0x2
   \   000012 90BE ..      LDW       Y, S:?w2
   \   000015 F3           CPW       Y, (X)
   \   000016 24 41        JRNC      L:??memb_alloc_2
     64              if(m->count[i] == 0) {
   \   000018 BE ..        LDW       X, S:?w1
   \   00001A 1C 0004      ADDW      X, #0x4
   \   00001D FE           LDW       X, (X)
   \   00001E 72BB ....    ADDW      X, S:?w2
   \   000022 7D           TNZ       (X)
   \   000023 26 E3        JRNE      L:??memb_alloc_1
     65                /* If this block was unused, we increase the reference count to
     66          	 indicate that it now is used and return a pointer to the
     67          	 memory block. */
     68                ++(m->count[i]);
   \   000025 BE ..        LDW       X, S:?w1
   \   000027 1C 0004      ADDW      X, #0x4
   \   00002A FE           LDW       X, (X)
   \   00002B 72BB ....    ADDW      X, S:?w2
   \   00002F F6           LD        A, (X)
   \   000030 AB 01        ADD       A, #0x1
   \   000032 BE ..        LDW       X, S:?w1
   \   000034 1C 0004      ADDW      X, #0x4
   \   000037 FE           LDW       X, (X)
   \   000038 72BB ....    ADDW      X, S:?w2
   \   00003C F7           LD        (X), A
     69                return (void *)((char *)m->mem + (i * m->size));
   \   00003D 92CE ..      LDW       X, [S:?w1.w]
   \   000040 BF ..        LDW       S:?w0, X
   \   000042 BE ..        LDW       X, S:?w2
   \   000044 8D ......    CALLF     L:?mul16_x_x_w0
   \   000048 90BE ..      LDW       Y, S:?w1
   \   00004B 72A9 0006    ADDW      Y, #0x6
   \   00004F 90FE         LDW       Y, (Y)
   \   000051 BF ..        LDW       S:?w0, X
   \   000053 93           LDW       X, Y
   \   000054 72BB ....    ADDW      X, S:?w0
   \   000058 87           RETF
     70              }
     71            }
     72          
     73            /* No free block was found, so we return NULL to indicate failure to
     74               allocate block. */
     75            return NULL;
   \                     ??memb_alloc_2:
   \   000059 5F           CLRW      X
   \   00005A 87           RETF
     76          }
     77          /*---------------------------------------------------------------------------*/

   \                                 In section .far_func.text, align 1
     78          char
     79          memb_free(struct memb *m, void *ptr)
     80          {
   \                     memb_free:
   \   000000 BF ..        LDW       S:?w0, X
   \   000002 90BF ..      LDW       S:?w2, Y
     81            int i;
     82            char *ptr2;
     83          
     84            /* Walk through the list of blocks and try to find the block to
     85               which the pointer "ptr" points to. */
     86            ptr2 = (char *)m->mem;
   \   000005 BE ..        LDW       X, S:?w0
   \   000007 1C 0006      ADDW      X, #0x6
   \   00000A FE           LDW       X, (X)
   \   00000B BF ..        LDW       S:?w1, X
     87            for(i = 0; i < m->num; ++i) {
   \   00000D 3F ..        CLR       S:?b7
   \   00000F 3F ..        CLR       S:?b6
   \   000011 20 0E        JRA       L:??memb_free_0
     88              
     89              if(ptr2 == (char *)ptr) {
     90                /* We've found to block to which "ptr" points so we decrease the
     91          	 reference count and return the new value of it. */
     92                if(m->count[i] > 0) {
     93          	/* Make sure that we don't deallocate free memory. */
     94          	--(m->count[i]);
     95                }
     96                return m->count[i];
     97              }
     98              ptr2 += m->size;
   \                     ??memb_free_1:
   \   000013 92CE ..      LDW       X, [S:?w0.w]
   \   000016 72BB ....    ADDW      X, S:?w1
   \   00001A BF ..        LDW       S:?w1, X
   \   00001C BE ..        LDW       X, S:?w3
   \   00001E 5C           INCW      X
   \   00001F BF ..        LDW       S:?w3, X
   \                     ??memb_free_0:
   \   000021 BE ..        LDW       X, S:?w0
   \   000023 1C 0002      ADDW      X, #0x2
   \   000026 90BE ..      LDW       Y, S:?w3
   \   000029 F3           CPW       Y, (X)
   \   00002A 24 37        JRNC      L:??memb_free_2
   \   00002C BE ..        LDW       X, S:?w1
   \   00002E B3 ..        CPW       X, S:?w2
   \   000030 26 E1        JRNE      L:??memb_free_1
   \   000032 BE ..        LDW       X, S:?w0
   \   000034 1C 0004      ADDW      X, #0x4
   \   000037 FE           LDW       X, (X)
   \   000038 72BB ....    ADDW      X, S:?w3
   \   00003C 7D           TNZ       (X)
   \   00003D 27 18        JREQ      L:??memb_free_3
   \   00003F BE ..        LDW       X, S:?w0
   \   000041 1C 0004      ADDW      X, #0x4
   \   000044 FE           LDW       X, (X)
   \   000045 72BB ....    ADDW      X, S:?w3
   \   000049 F6           LD        A, (X)
   \   00004A AB FF        ADD       A, #0xff
   \   00004C BE ..        LDW       X, S:?w0
   \   00004E 1C 0004      ADDW      X, #0x4
   \   000051 FE           LDW       X, (X)
   \   000052 72BB ....    ADDW      X, S:?w3
   \   000056 F7           LD        (X), A
   \                     ??memb_free_3:
   \   000057 BE ..        LDW       X, S:?w0
   \   000059 1C 0004      ADDW      X, #0x4
   \   00005C FE           LDW       X, (X)
   \   00005D 72BB ....    ADDW      X, S:?w3
   \   000061 F6           LD        A, (X)
   \   000062 87           RETF
     99            }
    100            return -1;
   \                     ??memb_free_2:
   \   000063 A6 FF        LD        A, #0xff
   \   000065 87           RETF
    101          }
    102          /*---------------------------------------------------------------------------*/

   \                                 In section .far_func.text, align 1
    103          int
    104          memb_inmemb(struct memb *m, void *ptr)
    105          {
   \                     memb_inmemb:
   \   000000 BF ..        LDW       S:?w1, X
   \   000002 90BF ..      LDW       S:?w2, Y
    106            return (char *)ptr >= (char *)m->mem &&
    107              (char *)ptr < (char *)m->mem + (m->num * m->size);
   \   000005 BE ..        LDW       X, S:?w1
   \   000007 1C 0006      ADDW      X, #0x6
   \   00000A FE           LDW       X, (X)
   \   00000B BF ..        LDW       S:?w0, X
   \   00000D BE ..        LDW       X, S:?w2
   \   00000F B3 ..        CPW       X, S:?w0
   \   000011 25 2A        JRC       L:??memb_inmemb_0
   \   000013 BE ..        LDW       X, S:?w1
   \   000015 1C 0002      ADDW      X, #0x2
   \   000018 FE           LDW       X, (X)
   \   000019 9093         LDW       Y, X
   \   00001B 92CE ..      LDW       X, [S:?w1.w]
   \   00001E BF ..        LDW       S:?w0, X
   \   000020 93           LDW       X, Y
   \   000021 8D ......    CALLF     L:?mul16_x_x_w0
   \   000025 BF ..        LDW       S:?w0, X
   \   000027 BE ..        LDW       X, S:?w1
   \   000029 1C 0006      ADDW      X, #0x6
   \   00002C FE           LDW       X, (X)
   \   00002D 72BB ....    ADDW      X, S:?w0
   \   000031 BF ..        LDW       S:?w0, X
   \   000033 BE ..        LDW       X, S:?w2
   \   000035 B3 ..        CPW       X, S:?w0
   \   000037 24 04        JRNC      L:??memb_inmemb_0
   \   000039 A6 01        LD        A, #0x1
   \   00003B 20 01        JRA       L:??memb_inmemb_1
   \                     ??memb_inmemb_0:
   \   00003D 4F           CLR       A
   \                     ??memb_inmemb_1:
   \   00003E 5F           CLRW      X
   \   00003F 97           LD        XL, A
   \   000040 87           RETF
    108          }
    109          /*---------------------------------------------------------------------------*/

   \                                 In section .far_func.text, align 1
    110          int
    111          memb_numfree(struct memb *m)
    112          {
   \                     memb_numfree:
   \   000000 BF ..        LDW       S:?w1, X
    113            int i;
    114            int num_free = 0;
   \   000002 3F ..        CLR       S:?b1
   \   000004 3F ..        CLR       S:?b0
    115          
    116            for(i = 0; i < m->num; ++i) {
   \   000006 3F ..        CLR       S:?b5
   \   000008 3F ..        CLR       S:?b4
   \   00000A 20 17        JRA       L:??memb_numfree_0
    117              if(m->count[i] == 0) {
   \                     ??memb_numfree_1:
   \   00000C BE ..        LDW       X, S:?w1
   \   00000E 1C 0004      ADDW      X, #0x4
   \   000011 FE           LDW       X, (X)
   \   000012 72BB ....    ADDW      X, S:?w2
   \   000016 7D           TNZ       (X)
   \   000017 26 05        JRNE      L:??memb_numfree_2
    118                ++num_free;
   \   000019 BE ..        LDW       X, S:?w0
   \   00001B 5C           INCW      X
   \   00001C BF ..        LDW       S:?w0, X
    119              }
    120            }
   \                     ??memb_numfree_2:
   \   00001E BE ..        LDW       X, S:?w2
   \   000020 5C           INCW      X
   \   000021 BF ..        LDW       S:?w2, X
   \                     ??memb_numfree_0:
   \   000023 BE ..        LDW       X, S:?w1
   \   000025 1C 0002      ADDW      X, #0x2
   \   000028 90BE ..      LDW       Y, S:?w2
   \   00002B F3           CPW       Y, (X)
   \   00002C 25 DE        JRC       L:??memb_numfree_1
    121          
    122            return num_free;
   \   00002E BE ..        LDW       X, S:?w0
   \   000030 87           RETF
    123          }
    124          /** @} */

   Section sizes:

   Bytes  Function/Label
   -----  --------------
      91  memb_alloc
     102  memb_free
      62  memb_init
      65  memb_inmemb
      49  memb_numfree

 
 369 bytes in section .far_func.text
 
 369 bytes of CODE memory

Errors: none
Warnings: none
