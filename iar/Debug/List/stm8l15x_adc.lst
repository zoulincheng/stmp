###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.42.1.142 for STM8               01/Jul/2016  17:30:47 #
# Copyright 2010-2013 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  E:\hwpro-2016\20160627_L\stm8l15x_lib\src\stm8l15x_adc.c #
#    Command line =  E:\hwpro-2016\20160627_L\stm8l15x_lib\src\stm8l15x_adc.c #
#                     -e -Ol --no_cse --no_unroll --no_inline                 #
#                    --no_code_motion --no_tbaa --no_cross_call --debug       #
#                    --code_model medium --data_model medium -o               #
#                    E:\hwpro-2016\20160627_L\iar\Debug\Obj\ --dlib_config    #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.5\stm8\LIB\dlstm8mmn.h" -D STM8L15X_MD -lC             #
#                    E:\hwpro-2016\20160627_L\iar\Debug\List\ -I              #
#                    E:\hwpro-2016\20160627_L\iar\..\stm8l15x_lib\inc\ -I     #
#                    E:\hwpro-2016\20160627_L\iar\..\user\inc\ -I             #
#                    E:\hwpro-2016\20160627_L\iar\..\utils\xprintf\ -I        #
#                    E:\hwpro-2016\20160627_L\iar\..\drivers\ -I              #
#                    E:\hwpro-2016\20160627_L\iar\..\utils\ -I                #
#                    E:\hwpro-2016\20160627_L\iar\..\app\ --vregs 16          #
#    List file    =  E:\hwpro-2016\20160627_L\iar\Debug\List\stm8l15x_adc.lst #
#    Object file  =  E:\hwpro-2016\20160627_L\iar\Debug\Obj\stm8l15x_adc.o    #
#                                                                             #
#                                                                             #
###############################################################################

E:\hwpro-2016\20160627_L\stm8l15x_lib\src\stm8l15x_adc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm8l15x_adc.c
      4            * @author  MCD Application Team
      5            * @version V1.6.1
      6            * @date    30-September-2014
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Analog to Digital Convertor (ADC) peripheral:           
      9            *           - Initialization and Configuration
     10            *           - Power saving
     11            *           - Analog Watchdog configuration              
     12            *           - Temperature Sensor & Vrefint (Voltage Reference internal) management 
     13            *           - Regular Channels Configuration
     14            *           - Regular Channels DMA Configuration
     15            *           - Injected channels Configuration      
     16            *           - Interrupts and flags management       
     17            *         
     18            *  @verbatim
     19            *                               
     20            *          ===================================================================      
     21            *                                   How to use this driver
     22            *          ===================================================================      
     23            *          1. Enable The ADC controller clock using CLK_PeripheralClockConfig() 
     24            *            function : CLK_PeripheralClockConfig(CLK_Peripheral_ADC1, ENABLE).
     25            *
     26            *            2. Configure the ADC Prescaler, conversion resolution and data 
     27            *              alignment using the ADC_Init() function.
     28            * 
     29            *            3. Activate the ADC peripheral using ADC_Cmd() function.  
     30            *
     31            *          Regular channels group configuration
     32            *          ====================================    
     33            *            - To configure the ADC regular channels group features, use 
     34            *              ADC_Init() and ADC_RegularChannelConfig() functions.
     35            *            - To activate the continuous mode, use the ADC_continuousModeCmd()
     36            *              function.
     37            *            - To configure and activate the Discontinuous mode, use the 
     38            *              ADC_DiscModeChannelCountConfig() and ADC_DiscModeCmd() functions.        
     39            *            - To read the ADC converted values, use the ADC_GetConversionValue()
     40            *              function.
     41            *
     42            *          DMA for Regular channels group features configuration
     43            *          ====================================================== 
     44            *           - To enable the DMA mode for regular channels group, use the 
     45            *             ADC_DMACmd() function.
     46            *           - To enable the generation of DMA requests continuously at the end
     47            *             of the last DMA transfer, use the ADC_DMARequestAfterLastTransferCmd() 
     48            *             function.    
     49                       
     50            *          Injected channels group configuration
     51            *          =====================================    
     52            *            - To configure the ADC Injected channels group features, use 
     53            *              ADC_InjectedChannelConfig() and  ADC_InjectedSequencerLengthConfig()
     54            *              functions.
     55            *            - To activate the continuous mode, use the ADC_continuousModeCmd()
     56            *              function.
     57            *            - To activate the Injected Discontinuous mode, use the 
     58            *              ADC_InjectedDiscModeCmd() function.  
     59            *            - To activate the AutoInjected mode, use the ADC_AutoInjectedConvCmd() 
     60            *              function.        
     61            *            - To read the ADC converted values, use the ADC_GetInjectedConversionValue() 
     62            *              function.
     63            *              
     64            *  @endverbatim
     65            *         
     66            ******************************************************************************
     67            * @attention
     68            *
     69            * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
     70            *
     71            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     72            * You may not use this file except in compliance with the License.
     73            * You may obtain a copy of the License at:
     74            *
     75            *        http://www.st.com/software_license_agreement_liberty_v2
     76            *
     77            * Unless required by applicable law or agreed to in writing, software 
     78            * distributed under the License is distributed on an "AS IS" BASIS, 
     79            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     80            * See the License for the specific language governing permissions and
     81            * limitations under the License.
     82            *
     83            ******************************************************************************
     84            */ 
     85          
     86          /* Includes ------------------------------------------------------------------*/
     87          #include "stm8l15x_adc.h"
     88          
     89          /** @addtogroup STM8L15x_StdPeriph_Driver
     90            * @{
     91            */
     92          
     93          /** @defgroup ADC 
     94            * @brief ADC driver modules
     95            * @{
     96            */ 
     97            
     98          /* Private typedef -----------------------------------------------------------*/
     99          /* Private define ------------------------------------------------------------*/
    100          /* Private macro -------------------------------------------------------------*/
    101          /* Private variables ---------------------------------------------------------*/
    102          /* Private function prototypes -----------------------------------------------*/
    103          /* Private functions ---------------------------------------------------------*/
    104          
    105          /** @defgroup ADC_Private_Functions
    106            * @{
    107            */ 
    108              
    109              
    110          /** @defgroup ADC_Group1 Initialization and Configuration functions
    111           *  @brief   Initialization and Configuration functions 
    112           *
    113          @verbatim    
    114           ===============================================================================
    115                                Initialization and Configuration functions
    116           ===============================================================================  
    117            This section provides functions allowing to:
    118             - Enable or disable the ADC peripheral,
    119             - Initialize and configure the ADC Prescaler, ADC Conversion Resolution 
    120               (12bit..6bit), ADC Continuous Conversion Mode (Continuous or Single 
    121               conversion),
    122             - Configure External trigger Sensitivity and source,
    123             - Start ADC conversion, by software trigger.
    124          
    125          
    126          @endverbatim
    127            * @{
    128            */
    129          /**
    130            * @brief  Deinitializes the ADC peripheral registers to their default reset 
    131            *         values.
    132            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
    133            * @retval None
    134            */

   \                                 In section .far_func.text, align 1
    135          void ADC_DeInit(ADC_TypeDef* ADCx)
    136          {
    137            /*  Set the Configuration registers to their reset values */
    138            ADCx->CR1 =  ADC_CR1_RESET_VALUE;
   \                     ADC_DeInit:
   \   000000 4F           CLR       A
   \   000001 F7           LD        (X), A
    139            ADCx->CR2 =  ADC_CR2_RESET_VALUE;
   \   000002 9093         LDW       Y, X
   \   000004 905C         INCW      Y
   \   000006 4F           CLR       A
   \   000007 90F7         LD        (Y), A
    140            ADCx->CR3 =  ADC_CR3_RESET_VALUE;
   \   000009 9093         LDW       Y, X
   \   00000B 72A9 0002    ADDW      Y, #0x2
   \   00000F A6 1F        LD        A, #0x1f
   \   000011 90F7         LD        (Y), A
    141          
    142            /*  Set the status registers to their reset values */
    143            ADCx->SR =  (uint8_t)~ADC_SR_RESET_VALUE;
   \   000013 9093         LDW       Y, X
   \   000015 72A9 0003    ADDW      Y, #0x3
   \   000019 A6 FF        LD        A, #0xff
   \   00001B 90F7         LD        (Y), A
    144          
    145            /*  Set the High threshold registers to their reset values */
    146            ADCx->HTRH =  ADC_HTRH_RESET_VALUE;
   \   00001D 9093         LDW       Y, X
   \   00001F 72A9 0006    ADDW      Y, #0x6
   \   000023 A6 0F        LD        A, #0xf
   \   000025 90F7         LD        (Y), A
    147            ADCx->HTRL =  ADC_HTRL_RESET_VALUE;
   \   000027 9093         LDW       Y, X
   \   000029 72A9 0007    ADDW      Y, #0x7
   \   00002D A6 FF        LD        A, #0xff
   \   00002F 90F7         LD        (Y), A
    148          
    149            /*  Set the low threshold registers to their reset values */
    150            ADCx->LTRH =  ADC_LTRH_RESET_VALUE;
   \   000031 9093         LDW       Y, X
   \   000033 72A9 0008    ADDW      Y, #0x8
   \   000037 4F           CLR       A
   \   000038 90F7         LD        (Y), A
    151            ADCx->LTRL =  ADC_LTRL_RESET_VALUE;
   \   00003A 9093         LDW       Y, X
   \   00003C 72A9 0009    ADDW      Y, #0x9
   \   000040 4F           CLR       A
   \   000041 90F7         LD        (Y), A
    152          
    153            /*  Set the channels sequence registers to their reset values */
    154            ADCx->SQR[0] =  ADC_SQR1_RESET_VALUE;
   \   000043 9093         LDW       Y, X
   \   000045 72A9 000A    ADDW      Y, #0xa
   \   000049 4F           CLR       A
   \   00004A 90F7         LD        (Y), A
    155            ADCx->SQR[1] =  ADC_SQR2_RESET_VALUE;
   \   00004C 9093         LDW       Y, X
   \   00004E 72A9 000B    ADDW      Y, #0xb
   \   000052 4F           CLR       A
   \   000053 90F7         LD        (Y), A
    156            ADCx->SQR[2] =  ADC_SQR3_RESET_VALUE;
   \   000055 9093         LDW       Y, X
   \   000057 72A9 000C    ADDW      Y, #0xc
   \   00005B 4F           CLR       A
   \   00005C 90F7         LD        (Y), A
    157            ADCx->SQR[3] =  ADC_SQR4_RESET_VALUE;
   \   00005E 9093         LDW       Y, X
   \   000060 72A9 000D    ADDW      Y, #0xd
   \   000064 4F           CLR       A
   \   000065 90F7         LD        (Y), A
    158          
    159            /*  Set the channels Trigger registers to their reset values */
    160            ADCx->TRIGR[0] =  ADC_TRIGR1_RESET_VALUE;
   \   000067 9093         LDW       Y, X
   \   000069 72A9 000E    ADDW      Y, #0xe
   \   00006D 4F           CLR       A
   \   00006E 90F7         LD        (Y), A
    161            ADCx->TRIGR[1] =  ADC_TRIGR2_RESET_VALUE;
   \   000070 9093         LDW       Y, X
   \   000072 72A9 000F    ADDW      Y, #0xf
   \   000076 4F           CLR       A
   \   000077 90F7         LD        (Y), A
    162            ADCx->TRIGR[2] =  ADC_TRIGR3_RESET_VALUE;
   \   000079 9093         LDW       Y, X
   \   00007B 72A9 0010    ADDW      Y, #0x10
   \   00007F 4F           CLR       A
   \   000080 90F7         LD        (Y), A
    163            ADCx->TRIGR[3] =  ADC_TRIGR4_RESET_VALUE;
   \   000082 1C 0011      ADDW      X, #0x11
   \   000085 4F           CLR       A
   \   000086 F7           LD        (X), A
    164          }
   \   000087 87           RETF
    165          
    166          /**
    167            * @brief  Initializes the specified ADC peripheral according to the specified 
    168            *         parameters.
    169            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
    170            * @param  ADC_ConversionMode : specifies the ADC conversion mode,
    171            *          This parameter can be one of the following values:
    172            *            @arg ADC_ConversionMode_Single: Single Conversion Mode
    173            *            @arg ADC_ConversionMode_Continuous: Continuous Conversion Mode
    174            * @param  ADC_Resolution : specifies the ADC Data resolution,
    175            *          This parameter can be one of the following values:
    176            *            @arg ADC_Resolution_12Bit: 12 bit resolution
    177            *            @arg ADC_Resolution_10Bit: 10 bit resolution
    178            *            @arg ADC_Resolution_8Bit: 8 bit resolution
    179            *            @arg ADC_Resolution_6Bit: 6 bit resolution      
    180            * @param  ADC_Prescaler : specifies the ADC Prescaler,
    181            *          This parameter can be one of the following values:
    182            *            @arg ADC_Prescaler_1: ADC Clock frequency is divided by 1
    183            *            @arg ADC_Prescaler_2: ADC Clock frequency is divided by 2
    184            * @retval None
    185            */

   \                                 In section .far_func.text, align 1
    186          void ADC_Init(ADC_TypeDef* ADCx,
    187                        ADC_ConversionMode_TypeDef ADC_ConversionMode,
    188                        ADC_Resolution_TypeDef ADC_Resolution,
    189                        ADC_Prescaler_TypeDef ADC_Prescaler)
    190          {
   \                     ADC_Init:
   \   000000 B7 ..        LD        S:?b2, A
    191            /* Check the parameters */
    192            assert_param(IS_ADC_CONVERSION_MODE(ADC_ConversionMode));
    193            assert_param(IS_ADC_RESOLUTION(ADC_Resolution));
    194            assert_param(IS_ADC_PRESCALER(ADC_Prescaler));
    195          
    196            /*clear CR1 register */
    197            ADCx->CR1 &= (uint8_t)~(ADC_CR1_CONT | ADC_CR1_RES);
   \   000002 F6           LD        A, (X)
   \   000003 A4 9B        AND       A, #0x9b
   \   000005 F7           LD        (X), A
    198          
    199            /* set the resolution and the conversion mode */
    200            ADCx->CR1 |= (uint8_t)((uint8_t)ADC_ConversionMode | (uint8_t)ADC_Resolution);
   \   000006 B6 ..        LD        A, S:?b0
   \   000008 BA ..        OR        A, S:?b2
   \   00000A FA           OR        A, (X)
   \   00000B F7           LD        (X), A
    201          
    202            /*clear CR2 register */
    203            ADCx->CR2 &= (uint8_t)~(ADC_CR2_PRESC);
   \   00000C 9093         LDW       Y, X
   \   00000E 905C         INCW      Y
   \   000010 90F6         LD        A, (Y)
   \   000012 A4 7F        AND       A, #0x7f
   \   000014 9093         LDW       Y, X
   \   000016 905C         INCW      Y
   \   000018 90F7         LD        (Y), A
    204          
    205            /* set the Prescaler */
    206            ADCx->CR2 |= (uint8_t) ADC_Prescaler;
   \   00001A 9093         LDW       Y, X
   \   00001C 905C         INCW      Y
   \   00001E B6 ..        LD        A, S:?b1
   \   000020 90FA         OR        A, (Y)
   \   000022 5C           INCW      X
   \   000023 F7           LD        (X), A
    207          }
   \   000024 87           RETF
    208          
    209          /**
    210            * @brief  Enables or disables the selected ADC peripheral.
    211            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
    212            * @param  NewState : new state of the specified ADC peripheral.
    213              *         This parameter can be: ENABLE or DISABLE.
    214            * @retval None
    215            */

   \                                 In section .far_func.text, align 1
    216          void ADC_Cmd(ADC_TypeDef* ADCx,
    217                       FunctionalState NewState)
    218          {
    219            /* Check the parameters */
    220            assert_param(IS_FUNCTIONAL_STATE(NewState));
    221          
    222            if (NewState != DISABLE)
   \                     ADC_Cmd:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??ADC_Cmd_0
    223            {
    224              /* Set the ADON bit to wake up the specified ADC from power down mode */
    225              ADCx->CR1 |= ADC_CR1_ADON;
   \   000003 F6           LD        A, (X)
   \   000004 AA 01        OR        A, #0x1
   \   000006 F7           LD        (X), A
   \   000007 87           RETF
    226            }
    227            else
    228            {
    229              /* Disable the selected ADC peripheral */
    230              ADCx->CR1 &= (uint8_t)~ADC_CR1_ADON;
   \                     ??ADC_Cmd_0:
   \   000008 F6           LD        A, (X)
   \   000009 A4 FE        AND       A, #0xfe
   \   00000B F7           LD        (X), A
    231            }
    232          }
   \   00000C 87           RETF
    233          
    234          /**
    235            * @brief  Starts ADC conversion, by software trigger.
    236            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
    237            * @retval None
    238            */

   \                                 In section .far_func.text, align 1
    239          void ADC_SoftwareStartConv(ADC_TypeDef* ADCx)
    240          {
    241            /*  Start the ADC software conversion */
    242            ADCx->CR1 |= ADC_CR1_START;
   \                     ADC_SoftwareStartConv:
   \   000000 F6           LD        A, (X)
   \   000001 AA 02        OR        A, #0x2
   \   000003 F7           LD        (X), A
    243          }
   \   000004 87           RETF
    244          
    245          /**
    246            * @brief  Configures the ADC conversion through external trigger.
    247            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
    248            * @param  ADC_ExtEventSelection : Specifies the external trigger.
    249            *          This parameter can be one of the following values:
    250            *            @arg ADC_ExtEventSelection_None: Conversion starts only by software start
    251            *            @arg ADC_ExtEventSelection_Trigger1: Trigger 1  Enables conversion
    252            *            @arg ADC_ExtEventSelection_Trigger2: Trigger 2  Enables conversion
    253            *            @arg ADC_ExtEventSelection_Trigger3: Trigger 3  Enables conversion      
    254            * @param  ADC_ExtTRGSensitivity : Specifies the external trigger sensitivity.
    255            *          This parameter can be one of the following values:
    256            *            @arg ADC_ExtTRGSensitivity_Rising: External Trigger Sensitivity is Rising Edge
    257            *            @arg ADC_ExtTRGSensitivity_Falling: External Trigger Sensitivity is Falling Edge
    258            *            @arg ADC_ExtTRGSensitivity_All: External Trigger Sensitivity is Falling and Rising Edge
    259            * @retval None
    260            */

   \                                 In section .far_func.text, align 1
    261          void ADC_ExternalTrigConfig(ADC_TypeDef* ADCx,
    262                                      ADC_ExtEventSelection_TypeDef ADC_ExtEventSelection,
    263                                      ADC_ExtTRGSensitivity_TypeDef ADC_ExtTRGSensitivity)
    264          {
   \                     ADC_ExternalTrigConfig:
   \   000000 B7 ..        LD        S:?b1, A
    265            /* Check the parameters */
    266            assert_param(IS_ADC_EXT_EVENT_SELECTION(ADC_ExtEventSelection));
    267            assert_param(IS_ADC_EXT_TRG_SENSITIVITY(ADC_ExtTRGSensitivity));
    268          
    269            /*clear old configuration of CR2 register */
    270            ADCx->CR2 &= (uint8_t)~(ADC_CR2_TRIGEDGE | ADC_CR2_EXTSEL);
   \   000002 9093         LDW       Y, X
   \   000004 905C         INCW      Y
   \   000006 90F6         LD        A, (Y)
   \   000008 A4 87        AND       A, #0x87
   \   00000A 9093         LDW       Y, X
   \   00000C 905C         INCW      Y
   \   00000E 90F7         LD        (Y), A
    271          
    272            /* set the External Trigger Edge Sensitivity  and the external event 
    273               selection */
    274            ADCx->CR2 |= (uint8_t)( (uint8_t)ADC_ExtTRGSensitivity | \
    275                                    (uint8_t)ADC_ExtEventSelection);
   \   000010 B6 ..        LD        A, S:?b1
   \   000012 BA ..        OR        A, S:?b0
   \   000014 9093         LDW       Y, X
   \   000016 905C         INCW      Y
   \   000018 90FA         OR        A, (Y)
   \   00001A 5C           INCW      X
   \   00001B F7           LD        (X), A
    276          }
   \   00001C 87           RETF
    277          
    278           /**
    279            * @}
    280            */
    281          
    282          /** @defgroup ADC_Group2 Analog Watchdog configuration functions
    283           *  @brief   Analog Watchdog configuration functions 
    284           *
    285          @verbatim   
    286           ===============================================================================
    287                              Analog Watchdog configuration functions
    288           ===============================================================================  
    289          
    290            This section provides functions allowing to configure the Analog Watchdog
    291            (AWD) feature in the ADC.
    292            
    293            A typical configuration Analog Watchdog is done following these steps :
    294             1. the ADC guarded channel is selected using the 
    295                ADC_AnalogWatchdogChannelSelect() function.
    296             2. The Analog watchdog lower and higher threshold are configured using the  
    297                ADC_AnalogWatchdogThresholdsConfig() function.
    298             
    299             Note : Both AWD selection and thresholds can be configured with one unique 
    300                    function ADC_AnalogWatchdogConfig(), which is kept for firmware 
    301                    compatibility reason.
    302          
    303          @endverbatim
    304            * @{
    305            */
    306          /**
    307            * @brief  Configures the channel to be checked by the Analog watchdog.
    308            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
    309            * @param  ADC_AnalogWatchdogSelection : Specifies the channel to be checked 
    310            *         by the Analog watchdog.
    311            *          This parameter can be one of the following values:
    312            *            @arg ADC_AnalogWatchdogSelection_Channel0: AWD affected to Channel 0
    313            *            @arg ADC_AnalogWatchdogSelection_Channel1: AWD affected to Channel 1
    314            *            @arg ADC_AnalogWatchdogSelection_Channel2: AWD affected to Channel 2
    315            *            @arg ADC_AnalogWatchdogSelection_Channel3: AWD affected to Channel 3
    316            *            @arg ADC_AnalogWatchdogSelection_Channel4: AWD affected to Channel 4
    317            *            @arg ADC_AnalogWatchdogSelection_Channel5: AWD affected to Channel 5
    318            *            @arg ADC_AnalogWatchdogSelection_Channel6: AWD affected to Channel 6
    319            *            @arg ADC_AnalogWatchdogSelection_Channel7: AWD affected to Channel 7
    320            *            @arg ADC_AnalogWatchdogSelection_Channel8: AWD affected to Channel 8
    321            *            @arg ADC_AnalogWatchdogSelection_Channel9: AWD affected to Channel 9
    322            *            @arg ADC_AnalogWatchdogSelection_Channel10: AWD affected to Channel 10
    323            *            @arg ADC_AnalogWatchdogSelection_Channel11: AWD affected to Channel 11
    324            *            @arg ADC_AnalogWatchdogSelection_Channel12: AWD affected to Channel 12
    325            *            @arg ADC_AnalogWatchdogSelection_Channel13: AWD affected to Channel 13
    326            *            @arg ADC_AnalogWatchdogSelection_Channel14: AWD affected to Channel 14
    327            *            @arg ADC_AnalogWatchdogSelection_Channel15: AWD affected to Channel 15
    328            *            @arg ADC_AnalogWatchdogSelection_Channel16: AWD affected to Channel 16
    329            *            @arg ADC_AnalogWatchdogSelection_Channel17: AWD affected to Channel 17
    330            *            @arg ADC_AnalogWatchdogSelection_Channel18: AWD affected to Channel 18
    331            *            @arg ADC_AnalogWatchdogSelection_Channel19: AWD affected to Channel 19
    332            *            @arg ADC_AnalogWatchdogSelection_Channel20: AWD affected to Channel 20
    333            *            @arg ADC_AnalogWatchdogSelection_Channel21: AWD affected to Channel 21
    334            *            @arg ADC_AnalogWatchdogSelection_Channel22: AWD affected to Channel 22
    335            *            @arg ADC_AnalogWatchdogSelection_Channel23: AWD affected to Channel 23
    336            *         @ref ADC_AnalogWatchdogSelection_TypeDef enumeration.
    337            * @retval None
    338            */

   \                                 In section .far_func.text, align 1
    339          void ADC_AnalogWatchdogChannelSelect(ADC_TypeDef* ADCx,
    340                                               ADC_AnalogWatchdogSelection_TypeDef ADC_AnalogWatchdogSelection)
    341          {
   \                     ADC_AnalogWatchdogChannelSelect:
   \   000000 B7 ..        LD        S:?b0, A
    342            /* Check the parameters */
    343            assert_param(IS_ADC_ANALOGWATCHDOG_SELECTION(ADC_AnalogWatchdogSelection));
    344          
    345            /* Reset the CHSEL bits */
    346            ADCx->CR3 &= ((uint8_t)~ADC_CR3_CHSEL);
   \   000002 9093         LDW       Y, X
   \   000004 72A9 0002    ADDW      Y, #0x2
   \   000008 90F6         LD        A, (Y)
   \   00000A A4 E0        AND       A, #0xe0
   \   00000C 9093         LDW       Y, X
   \   00000E 72A9 0002    ADDW      Y, #0x2
   \   000012 90F7         LD        (Y), A
    347          
    348            /* Select the channel to be checked by the Analog watchdog */
    349            ADCx->CR3 |= (uint8_t)ADC_AnalogWatchdogSelection;
   \   000014 9093         LDW       Y, X
   \   000016 72A9 0002    ADDW      Y, #0x2
   \   00001A B6 ..        LD        A, S:?b0
   \   00001C 90FA         OR        A, (Y)
   \   00001E 1C 0002      ADDW      X, #0x2
   \   000021 F7           LD        (X), A
    350          }
   \   000022 87           RETF
    351          
    352          /**
    353            * @brief  Configures the high and low thresholds of the Analog watchdog.
    354            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
    355            * @param  HighThreshold: Analog watchdog High threshold value.
    356              *       This parameter must be a 12bit value.
    357            * @param  LowThreshold: Analog watchdog Low threshold value.
    358              *       This parameter must be a 12bit value.
    359            * @retval None
    360            */

   \                                 In section .far_func.text, align 1
    361          void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold, uint16_t LowThreshold)
    362          {
   \                     ADC_AnalogWatchdogThresholdsConfig:
   \   000000 BF ..        LDW       S:?w1, X
    363            /* Check the parameters */
    364            assert_param(IS_ADC_THRESHOLD(HighThreshold));
    365            assert_param(IS_ADC_THRESHOLD(LowThreshold));
    366          
    367            /* Set the ADC high threshold */
    368            ADCx->HTRH = (uint8_t)(HighThreshold >> 8);
   \   000002 93           LDW       X, Y
   \   000003 4F           CLR       A
   \   000004 01           RRWA      X, A
   \   000005 9F           LD        A, XL
   \   000006 BE ..        LDW       X, S:?w1
   \   000008 1C 0006      ADDW      X, #0x6
   \   00000B F7           LD        (X), A
    369            ADCx->HTRL = (uint8_t)(HighThreshold);
   \   00000C BE ..        LDW       X, S:?w1
   \   00000E 1C 0007      ADDW      X, #0x7
   \   000011 909F         LD        A, YL
   \   000013 F7           LD        (X), A
    370          
    371            /* Set the ADC low threshold */
    372            ADCx->LTRH = (uint8_t)(LowThreshold >> 8);
   \   000014 BE ..        LDW       X, S:?w0
   \   000016 4F           CLR       A
   \   000017 01           RRWA      X, A
   \   000018 9F           LD        A, XL
   \   000019 BE ..        LDW       X, S:?w1
   \   00001B 1C 0008      ADDW      X, #0x8
   \   00001E F7           LD        (X), A
    373            ADCx->LTRL = (uint8_t)(LowThreshold);
   \   00001F BE ..        LDW       X, S:?w1
   \   000021 1C 0009      ADDW      X, #0x9
   \   000024 B6 ..        LD        A, S:?b1
   \   000026 F7           LD        (X), A
    374          }
   \   000027 87           RETF
    375          
    376          /**
    377            * @brief  Configures the Analog watchdog.
    378            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
    379            * @param  ADC_AnalogWatchdogSelection : Specifies the channel to be checked 
    380            *         by the Analog watchdog.
    381            *          This parameter can be one of the following values:
    382            *            @arg ADC_AnalogWatchdogSelection_Channel0: AWD affected to Channel 0
    383            *            @arg ADC_AnalogWatchdogSelection_Channel1: AWD affected to Channel 1
    384            *            @arg ADC_AnalogWatchdogSelection_Channel2: AWD affected to Channel 2
    385            *            @arg ADC_AnalogWatchdogSelection_Channel3: AWD affected to Channel 3
    386            *            @arg ADC_AnalogWatchdogSelection_Channel4: AWD affected to Channel 4
    387            *            @arg ADC_AnalogWatchdogSelection_Channel5: AWD affected to Channel 5
    388            *            @arg ADC_AnalogWatchdogSelection_Channel6: AWD affected to Channel 6
    389            *            @arg ADC_AnalogWatchdogSelection_Channel7: AWD affected to Channel 7
    390            *            @arg ADC_AnalogWatchdogSelection_Channel8: AWD affected to Channel 8
    391            *            @arg ADC_AnalogWatchdogSelection_Channel9: AWD affected to Channel 9
    392            *            @arg ADC_AnalogWatchdogSelection_Channel10: AWD affected to Channel 10
    393            *            @arg ADC_AnalogWatchdogSelection_Channel11: AWD affected to Channel 11
    394            *            @arg ADC_AnalogWatchdogSelection_Channel12: AWD affected to Channel 12
    395            *            @arg ADC_AnalogWatchdogSelection_Channel13: AWD affected to Channel 13
    396            *            @arg ADC_AnalogWatchdogSelection_Channel14: AWD affected to Channel 14
    397            *            @arg ADC_AnalogWatchdogSelection_Channel15: AWD affected to Channel 15
    398            *            @arg ADC_AnalogWatchdogSelection_Channel16: AWD affected to Channel 16
    399            *            @arg ADC_AnalogWatchdogSelection_Channel17: AWD affected to Channel 17
    400            *            @arg ADC_AnalogWatchdogSelection_Channel18: AWD affected to Channel 18
    401            *            @arg ADC_AnalogWatchdogSelection_Channel19: AWD affected to Channel 19
    402            *            @arg ADC_AnalogWatchdogSelection_Channel20: AWD affected to Channel 20
    403            *            @arg ADC_AnalogWatchdogSelection_Channel21: AWD affected to Channel 21
    404            *            @arg ADC_AnalogWatchdogSelection_Channel22: AWD affected to Channel 22
    405            *            @arg ADC_AnalogWatchdogSelection_Channel23: AWD affected to Channel 23  
    406            * @param  HighThreshold: Analog watchdog High threshold value.
    407              *       This parameter must be a 12bit value.
    408            * @param  LowThreshold: Analog watchdog Low threshold value.
    409              *       This parameter must be a 12bit value.
    410            * @retval None
    411            */

   \                                 In section .far_func.text, align 1
    412          void ADC_AnalogWatchdogConfig(ADC_TypeDef* ADCx,
    413                                        ADC_AnalogWatchdogSelection_TypeDef ADC_AnalogWatchdogSelection,
    414                                        uint16_t HighThreshold,
    415                                        uint16_t LowThreshold)
    416          {
   \                     ADC_AnalogWatchdogConfig:
   \   000000 BF ..        LDW       S:?w1, X
   \   000002 B7 ..        LD        S:?b4, A
    417            /* Check the parameters */
    418            assert_param(IS_ADC_ANALOGWATCHDOG_SELECTION(ADC_AnalogWatchdogSelection));
    419            assert_param(IS_ADC_THRESHOLD(HighThreshold));
    420            assert_param(IS_ADC_THRESHOLD(LowThreshold));
    421          
    422            /*Reset the CHSEL bits */
    423            ADCx->CR3 &= ((uint8_t)~ADC_CR3_CHSEL);
   \   000004 BE ..        LDW       X, S:?w1
   \   000006 1C 0002      ADDW      X, #0x2
   \   000009 F6           LD        A, (X)
   \   00000A A4 E0        AND       A, #0xe0
   \   00000C BE ..        LDW       X, S:?w1
   \   00000E 1C 0002      ADDW      X, #0x2
   \   000011 F7           LD        (X), A
    424          
    425            /* Select the channel to be checked by the Analog watchdog.*/
    426            ADCx->CR3 |= (uint8_t)ADC_AnalogWatchdogSelection;
   \   000012 BE ..        LDW       X, S:?w1
   \   000014 1C 0002      ADDW      X, #0x2
   \   000017 B6 ..        LD        A, S:?b4
   \   000019 FA           OR        A, (X)
   \   00001A BE ..        LDW       X, S:?w1
   \   00001C 1C 0002      ADDW      X, #0x2
   \   00001F F7           LD        (X), A
    427          
    428            /* Set the ADC high threshold */
    429            ADCx->HTRH = (uint8_t)(HighThreshold >> 8);
   \   000020 93           LDW       X, Y
   \   000021 4F           CLR       A
   \   000022 01           RRWA      X, A
   \   000023 9F           LD        A, XL
   \   000024 BE ..        LDW       X, S:?w1
   \   000026 1C 0006      ADDW      X, #0x6
   \   000029 F7           LD        (X), A
    430            ADCx->HTRL = (uint8_t)(HighThreshold);
   \   00002A BE ..        LDW       X, S:?w1
   \   00002C 1C 0007      ADDW      X, #0x7
   \   00002F 909F         LD        A, YL
   \   000031 F7           LD        (X), A
    431          
    432            /* Set the ADC low threshold */
    433            ADCx->LTRH = (uint8_t)(LowThreshold >> 8);
   \   000032 BE ..        LDW       X, S:?w0
   \   000034 4F           CLR       A
   \   000035 01           RRWA      X, A
   \   000036 9F           LD        A, XL
   \   000037 BE ..        LDW       X, S:?w1
   \   000039 1C 0008      ADDW      X, #0x8
   \   00003C F7           LD        (X), A
    434            ADCx->LTRL = (uint8_t)LowThreshold;
   \   00003D BE ..        LDW       X, S:?w1
   \   00003F 1C 0009      ADDW      X, #0x9
   \   000042 B6 ..        LD        A, S:?b1
   \   000044 F7           LD        (X), A
    435          }
   \   000045 87           RETF
    436          
    437           /**
    438            * @}
    439            */
    440          
    441          /** @defgroup ADC_Group3 Temperature Sensor & Vrefint (Voltage Reference 
    442           *            internal) management functions
    443           *  @brief   Temperature Sensor & Vrefint (Voltage Reference internal) 
    444           *            management functions 
    445           *
    446          @verbatim   
    447           ===============================================================================
    448            Temperature Sensor & Vrefint (Voltage Reference internal) management functions
    449           ===============================================================================  
    450          
    451            This section provides functions allowing to enable/ disable the internal 
    452            connections between the ADC and the Temperature Sensor and the Vrefint source.
    453               
    454            A typical configuration to get the Temperature sensor or/and Vrefint channels 
    455            voltages is done following these steps :
    456             1. Enable the internal connection of Temperature sensor or/and Vrefint sources 
    457                with the ADC channels: 
    458                - for the Temperature sensor using ADC_TempSensorCmd() function.
    459                - for the Internal Voltage reference using ADC_VrefintCmd() function. 
    460             2. Enable the ADC_Channel_TempSensor and/or ADC_Channel_Vrefint channels 
    461                using ADC_ChannelCmd()function. 
    462             3. Get the voltage values, using ADC_GetConversionValue().
    463           
    464          @endverbatim
    465            * @{
    466            */
    467            
    468          /**
    469            * @brief  Enables or disables the Temperature sensor internal reference.
    470            * @param  NewState : new state of the Temperature sensor internal reference.
    471              *         This parameter can be: ENABLE or DISABLE.
    472            * @retval None
    473            */

   \                                 In section .far_func.text, align 1
    474          void ADC_TempSensorCmd(FunctionalState NewState)
    475          {
    476            /* Check the parameters */
    477            assert_param(IS_FUNCTIONAL_STATE(NewState));
    478          
    479            if (NewState != DISABLE)
   \                     ADC_TempSensorCmd:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??ADC_TempSensorCmd_0
    480            {
    481              /*Enable the Temperature sensor internal reference.*/
    482              ADC1->TRIGR[0] |= (uint8_t)(ADC_TRIGR1_TSON);
   \   000003 721A 534E    BSET      L:0x534e, #0x5
   \   000007 87           RETF
    483            }
    484            else
    485            {
    486              /*Disable the Temperature sensor internal reference.*/
    487              ADC1->TRIGR[0] &= (uint8_t)(~ADC_TRIGR1_TSON);
   \                     ??ADC_TempSensorCmd_0:
   \   000008 721B 534E    BRES      L:0x534e, #0x5
    488            }
    489          }
   \   00000C 87           RETF
    490          
    491          /**
    492            * @brief  Enables or disables the Internal Voltage reference.
    493            * @param  NewState : new state of the Internal Voltage reference.
    494              *         This parameter can be: ENABLE or DISABLE.
    495            * @retval None
    496            */

   \                                 In section .far_func.text, align 1
    497          void ADC_VrefintCmd(FunctionalState NewState)
    498          {
    499            /* Check the parameters */
    500            assert_param(IS_FUNCTIONAL_STATE(NewState));
    501          
    502            if (NewState != DISABLE)
   \                     ADC_VrefintCmd:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??ADC_VrefintCmd_0
    503            {
    504              /* Enable the Internal Voltage reference.*/
    505              ADC1->TRIGR[0] |= (uint8_t)(ADC_TRIGR1_VREFINTON);
   \   000003 7218 534E    BSET      L:0x534e, #0x4
   \   000007 87           RETF
    506            }
    507            else
    508            {
    509              /* Disable the Internal Voltage reference.*/
    510              ADC1->TRIGR[0] &= (uint8_t)(~ADC_TRIGR1_VREFINTON);
   \                     ??ADC_VrefintCmd_0:
   \   000008 7219 534E    BRES      L:0x534e, #0x4
    511            }
    512          }
   \   00000C 87           RETF
    513          
    514           /**
    515            * @}
    516            */
    517          /** @defgroup ADC_Group4 Channels Configuration functions
    518           *  @brief   Channels Configuration functions
    519           *
    520          @verbatim    
    521           ===============================================================================
    522                                Channels Configuration functions
    523           ===============================================================================  
    524            This section provides functions allowing to:
    525             - Enable or disable the ADC channel using ADC_ChannelCmd() function,
    526             - Configure the channels sampling times using ADC_SamplingTimeConfig() 
    527               function.
    528               Note: there are 2 sampling times configuration values : 
    529                      - 1st Group value : for channels 0..23  
    530                      - 2nd Group value : for channels 24..27 (depending on the MCU 
    531                        package density) and Temperature Sensor and Vrefint channels. 
    532             - Configure the channels Schmitt Trigger for each channel using 
    533               ADC_SchmittTriggerConfig() function.
    534             - Get the current ADC conversion value.
    535             
    536           @endverbatim
    537            * @{
    538            */
    539              
    540          /**
    541            * @brief  Enables or disables the selected ADC channel(s).
    542            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
    543            * @param  ADC_Channels: specifies the ADC channels to be initialized
    544            *          This parameter can be one of the following values:
    545            *            @arg ADC_Channel_0: Channel 0
    546            *            @arg ADC_Channel_1: Channel 1
    547            *            @arg ADC_Channel_2: Channel 2
    548            *            @arg ADC_Channel_3: Channel 3
    549            *            @arg ADC_Channel_4: Channel 4
    550            *            @arg ADC_Channel_5: Channel 5
    551            *            @arg ADC_Channel_6: Channel 6
    552            *            @arg ADC_Channel_7: Channel 7
    553            *            @arg ADC_Channel_8: Channel 8
    554            *            @arg ADC_Channel_9: Channel 9
    555            *            @arg ADC_Channel_10: Channel 10
    556            *            @arg ADC_Channel_11: Channel 11
    557            *            @arg ADC_Channel_12: Channel 12
    558            *            @arg ADC_Channel_13: Channel 13
    559            *            @arg ADC_Channel_14: Channel 14
    560            *            @arg ADC_Channel_15: Channel 15
    561            *            @arg ADC_Channel_16: Channel 16
    562            *            @arg ADC_Channel_17: Channel 17
    563            *            @arg ADC_Channel_18: Channel 18
    564            *            @arg ADC_Channel_19: Channel 19
    565            *            @arg ADC_Channel_20: Channel 20
    566            *            @arg ADC_Channel_21: Channel 21
    567            *            @arg ADC_Channel_22: Channel 22
    568            *            @arg ADC_Channel_23: Channel 23
    569            *            @arg ADC_Channel_24: Channel 24
    570            *            @arg ADC_Channel_25: Channel 25
    571            *            @arg ADC_Channel_26: Channel 26
    572            *            @arg ADC_Channel_27: Channel 27
    573            *            @arg ADC_Channel_Vrefint: Vrefint Channel
    574            *            @arg ADC_Channel_TempSensor: Temperature sensor Channel
    575            *            @arg ADC_Channel_00To07: select from channel00 to channel07
    576            *            @arg ADC_Channel_08To15: select from channel08 to channel15
    577            *            @arg ADC_Channel_16To23: select from channel16 to channel23
    578            *            @arg ADC_Channel_24To27: select from channel24 to channel27
    579            * @param  NewState : new state of the specified ADC channel(s).
    580              *         This parameter can be: ENABLE or DISABLE.
    581            * @retval None
    582            */

   \                                 In section .far_func.text, align 1
    583          void ADC_ChannelCmd(ADC_TypeDef* ADCx, ADC_Channel_TypeDef ADC_Channels, FunctionalState NewState)
    584          {
   \                     ADC_ChannelCmd:
   \   000000 BF ..        LDW       S:?w1, X
   \   000002 B7 ..        LD        S:?b0, A
    585            uint8_t regindex = 0;
   \   000004 3F ..        CLR       S:?b1
    586            /* Check the parameters */
    587            assert_param(IS_FUNCTIONAL_STATE(NewState));
    588          
    589            regindex = (uint8_t)((uint16_t)ADC_Channels >> 8);
   \   000006 93           LDW       X, Y
   \   000007 4F           CLR       A
   \   000008 01           RRWA      X, A
   \   000009 9F           LD        A, XL
   \   00000A B7 ..        LD        S:?b1, A
    590          
    591            if (NewState != DISABLE)
   \   00000C 3D ..        TNZ       S:?b0
   \   00000E 27 1D        JREQ      L:??ADC_ChannelCmd_0
    592            {
    593              /* Enable the selected ADC channel(s). */
    594              ADCx->SQR[regindex] |= (uint8_t)(ADC_Channels);
   \   000010 5F           CLRW      X
   \   000011 41           EXG       A, XL
   \   000012 B6 ..        LD        A, S:?b1
   \   000014 41           EXG       A, XL
   \   000015 72BB ....    ADDW      X, S:?w1
   \   000019 1C 000A      ADDW      X, #0xa
   \   00001C 909F         LD        A, YL
   \   00001E FA           OR        A, (X)
   \   00001F 5F           CLRW      X
   \   000020 41           EXG       A, XL
   \   000021 B6 ..        LD        A, S:?b1
   \   000023 41           EXG       A, XL
   \   000024 72BB ....    ADDW      X, S:?w1
   \   000028 1C 000A      ADDW      X, #0xa
   \   00002B F7           LD        (X), A
   \   00002C 87           RETF
    595            }
    596            else
    597            {
    598              /* Disable the selected ADC channel(s). */
    599              ADCx->SQR[regindex] &= (uint8_t)(~(uint8_t)(ADC_Channels));
   \                     ??ADC_ChannelCmd_0:
   \   00002D 5F           CLRW      X
   \   00002E 41           EXG       A, XL
   \   00002F B6 ..        LD        A, S:?b1
   \   000031 41           EXG       A, XL
   \   000032 72BB ....    ADDW      X, S:?w1
   \   000036 1C 000A      ADDW      X, #0xa
   \   000039 909F         LD        A, YL
   \   00003B 43           CPL       A
   \   00003C F4           AND       A, (X)
   \   00003D 5F           CLRW      X
   \   00003E 41           EXG       A, XL
   \   00003F B6 ..        LD        A, S:?b1
   \   000041 41           EXG       A, XL
   \   000042 72BB ....    ADDW      X, S:?w1
   \   000046 1C 000A      ADDW      X, #0xa
   \   000049 F7           LD        (X), A
    600            }
    601          }
   \   00004A 87           RETF
    602          
    603          /**
    604            * @brief  Configures the sampling time for the selected ADC channel group.
    605            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
    606            * @param  ADC_GroupChannels : ADC channel group to configure.
    607            *          This parameter can be one of the following values:
    608            *            @arg ADC_Group_SlowChannels: Slow Channels group
    609            *            @arg ADC_Group_FastChannels: Fast Channels group  
    610            * @note   The channels of 1st ADC Group can be channels 0..23  
    611            * @note   The channels of 2nd ADC Group can be channels 24..27 (depending on the MCU 
    612            *         package density) and Temperature Sensor and Vrefint channels.  
    613            * @param  ADC_SamplingTime : Specifies the sample time value
    614            *          This parameter can be one of the following values:
    615            *            @arg ADC_SamplingTime_4Cycles: Sampling Time Cycles is 4
    616            *            @arg ADC_SamplingTime_9Cycles: Sampling Time Cycles is 9
    617            *            @arg ADC_SamplingTime_16Cycles: Sampling Time Cycles is 16
    618            *            @arg ADC_SamplingTime_24Cycles: Sampling Time Cycles is 24
    619            *            @arg ADC_SamplingTime_48Cycles: Sampling Time Cycles is 48
    620            *            @arg ADC_SamplingTime_96Cycles: Sampling Time Cycles is 96
    621            *            @arg ADC_SamplingTime_192Cycles: Sampling Time Cycles is 192
    622            *            @arg ADC_SamplingTime_384Cycles: Sampling Time Cycles is 384
    623            * @retval None
    624            */

   \                                 In section .far_func.text, align 1
    625          void ADC_SamplingTimeConfig(ADC_TypeDef* ADCx,
    626                                      ADC_Group_TypeDef ADC_GroupChannels,
    627                                      ADC_SamplingTime_TypeDef ADC_SamplingTime)
    628          {
    629            /* Check the parameters */
    630            assert_param(IS_ADC_GROUP(ADC_GroupChannels));
    631            assert_param(IS_ADC_SAMPLING_TIME_CYCLES(ADC_SamplingTime));
    632          
    633            if ( ADC_GroupChannels != ADC_Group_SlowChannels)
   \                     ADC_SamplingTimeConfig:
   \   000000 4D           TNZ       A
   \   000001 27 25        JREQ      L:??ADC_SamplingTimeConfig_0
    634            {
    635              /* Configures the sampling time for the Fast ADC channel group. */
    636              ADCx->CR3 &= (uint8_t)~ADC_CR3_SMPT2;
   \   000003 9093         LDW       Y, X
   \   000005 72A9 0002    ADDW      Y, #0x2
   \   000009 90F6         LD        A, (Y)
   \   00000B A4 1F        AND       A, #0x1f
   \   00000D 9093         LDW       Y, X
   \   00000F 72A9 0002    ADDW      Y, #0x2
   \   000013 90F7         LD        (Y), A
    637              ADCx->CR3 |= (uint8_t)(ADC_SamplingTime << 5);
   \   000015 9093         LDW       Y, X
   \   000017 72A9 0002    ADDW      Y, #0x2
   \   00001B B6 ..        LD        A, S:?b0
   \   00001D 4E           SWAP      A
   \   00001E A4 F0        AND       A, #0xf0
   \   000020 48           SLL       A
   \   000021 90FA         OR        A, (Y)
   \   000023 1C 0002      ADDW      X, #0x2
   \   000026 F7           LD        (X), A
   \   000027 87           RETF
    638            }
    639            else
    640            {
    641              /* Configures the sampling time for the Slow ADC channel group. */
    642              ADCx->CR2 &= (uint8_t)~ADC_CR2_SMPT1;
   \                     ??ADC_SamplingTimeConfig_0:
   \   000028 9093         LDW       Y, X
   \   00002A 905C         INCW      Y
   \   00002C 90F6         LD        A, (Y)
   \   00002E A4 F8        AND       A, #0xf8
   \   000030 9093         LDW       Y, X
   \   000032 905C         INCW      Y
   \   000034 90F7         LD        (Y), A
    643              ADCx->CR2 |= (uint8_t)ADC_SamplingTime;
   \   000036 9093         LDW       Y, X
   \   000038 905C         INCW      Y
   \   00003A B6 ..        LD        A, S:?b0
   \   00003C 90FA         OR        A, (Y)
   \   00003E 5C           INCW      X
   \   00003F F7           LD        (X), A
    644            }
    645          }
   \   000040 87           RETF
    646          
    647          /**
    648            * @brief  Configures the status of the Schmitt Trigger for the selected ADC 
    649            *         channel(s).
    650            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
    651            * @param  ADC_Channels: specifies the ADC channels to be initialized,
    652            *          This parameter can be one of the following values:
    653            *            @arg ADC_Channel_0: Channel 0
    654            *            @arg ADC_Channel_1: Channel 1
    655            *            @arg ADC_Channel_2: Channel 2
    656            *            @arg ADC_Channel_3: Channel 3
    657            *            @arg ADC_Channel_4: Channel 4
    658            *            @arg ADC_Channel_5: Channel 5
    659            *            @arg ADC_Channel_6: Channel 6
    660            *            @arg ADC_Channel_7: Channel 7
    661            *            @arg ADC_Channel_8: Channel 8
    662            *            @arg ADC_Channel_9: Channel 9
    663            *            @arg ADC_Channel_10: Channel 10
    664            *            @arg ADC_Channel_11: Channel 11
    665            *            @arg ADC_Channel_12: Channel 12
    666            *            @arg ADC_Channel_13: Channel 13
    667            *            @arg ADC_Channel_14: Channel 14
    668            *            @arg ADC_Channel_15: Channel 15
    669            *            @arg ADC_Channel_16: Channel 16
    670            *            @arg ADC_Channel_17: Channel 17
    671            *            @arg ADC_Channel_18: Channel 18
    672            *            @arg ADC_Channel_19: Channel 19
    673            *            @arg ADC_Channel_20: Channel 20
    674            *            @arg ADC_Channel_21: Channel 21
    675            *            @arg ADC_Channel_22: Channel 22
    676            *            @arg ADC_Channel_23: Channel 23
    677            *            @arg ADC_Channel_24: Channel 24
    678            *            @arg ADC_Channel_25: Channel 25
    679            *            @arg ADC_Channel_26: Channel 26
    680            *            @arg ADC_Channel_27: Channel 27
    681            *            @arg ADC_Channel_Vrefint: Vrefint Channel
    682            *            @arg ADC_Channel_TempSensor: Temperature sensor Channel
    683            *            @arg ADC_Channel_00To07: select from channel00 to channel07
    684            *            @arg ADC_Channel_08To15: select from channel08 to channel15
    685            *            @arg ADC_Channel_16To23: select from channel16 to channel23
    686            *            @arg ADC_Channel_24To27: select from channel24 to channel27
    687            * @param  NewState : new state of the Schmitt Trigger
    688              *         This parameter can be: ENABLE or DISABLE.
    689            * @retval None
    690            */

   \                                 In section .far_func.text, align 1
    691          void ADC_SchmittTriggerConfig(ADC_TypeDef* ADCx, ADC_Channel_TypeDef ADC_Channels,
    692                                        FunctionalState NewState)
    693          {
   \                     ADC_SchmittTriggerConfig:
   \   000000 BF ..        LDW       S:?w1, X
   \   000002 B7 ..        LD        S:?b0, A
    694            uint8_t regindex = 0;
   \   000004 3F ..        CLR       S:?b1
    695            /* Check the parameters */
    696            assert_param(IS_FUNCTIONAL_STATE(NewState));
    697          
    698            regindex = (uint8_t)((uint16_t)ADC_Channels >> 8);
   \   000006 93           LDW       X, Y
   \   000007 4F           CLR       A
   \   000008 01           RRWA      X, A
   \   000009 9F           LD        A, XL
   \   00000A B7 ..        LD        S:?b1, A
    699          
    700            if (NewState != DISABLE)
   \   00000C 3D ..        TNZ       S:?b0
   \   00000E 27 1E        JREQ      L:??ADC_SchmittTriggerConfig_0
    701            {
    702              /* Enable the Schmitt Trigger for the selected ADC channel(s).*/
    703              ADCx->TRIGR[regindex] &= (uint8_t)(~(uint8_t)ADC_Channels);
   \   000010 5F           CLRW      X
   \   000011 41           EXG       A, XL
   \   000012 B6 ..        LD        A, S:?b1
   \   000014 41           EXG       A, XL
   \   000015 72BB ....    ADDW      X, S:?w1
   \   000019 1C 000E      ADDW      X, #0xe
   \   00001C 909F         LD        A, YL
   \   00001E 43           CPL       A
   \   00001F F4           AND       A, (X)
   \   000020 5F           CLRW      X
   \   000021 41           EXG       A, XL
   \   000022 B6 ..        LD        A, S:?b1
   \   000024 41           EXG       A, XL
   \   000025 72BB ....    ADDW      X, S:?w1
   \   000029 1C 000E      ADDW      X, #0xe
   \   00002C F7           LD        (X), A
   \   00002D 87           RETF
    704            }
    705            else
    706            {
    707              /* Disable the Schmitt Trigger for the selected ADC channel(s).*/
    708              ADCx->TRIGR[regindex] |= (uint8_t)(ADC_Channels);
   \                     ??ADC_SchmittTriggerConfig_0:
   \   00002E 5F           CLRW      X
   \   00002F 41           EXG       A, XL
   \   000030 B6 ..        LD        A, S:?b1
   \   000032 41           EXG       A, XL
   \   000033 72BB ....    ADDW      X, S:?w1
   \   000037 1C 000E      ADDW      X, #0xe
   \   00003A 909F         LD        A, YL
   \   00003C FA           OR        A, (X)
   \   00003D 5F           CLRW      X
   \   00003E 41           EXG       A, XL
   \   00003F B6 ..        LD        A, S:?b1
   \   000041 41           EXG       A, XL
   \   000042 72BB ....    ADDW      X, S:?w1
   \   000046 1C 000E      ADDW      X, #0xe
   \   000049 F7           LD        (X), A
    709            }
    710          }
   \   00004A 87           RETF
    711          
    712          /**
    713            * @brief  Returns the last ADC converted data.
    714            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
    715            * @retval The Data conversion value.
    716            */

   \                                 In section .far_func.text, align 1
    717          uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx)
    718          {
   \                     ADC_GetConversionValue:
   \   000000 BF ..        LDW       S:?w0, X
    719            uint16_t tmpreg = 0;
   \   000002 5F           CLRW      X
    720          
    721            /* Get last ADC converted data.*/
    722            tmpreg = (uint16_t)(ADCx->DRH);
   \   000003 90BE ..      LDW       Y, S:?w0
   \   000006 72A9 0004    ADDW      Y, #0x4
   \   00000A 90F6         LD        A, (Y)
   \   00000C 905F         CLRW      Y
   \   00000E 9097         LD        YL, A
   \   000010 93           LDW       X, Y
    723            tmpreg = (uint16_t)((uint16_t)((uint16_t)tmpreg << 8) | ADCx->DRL);
   \   000011 90BE ..      LDW       Y, S:?w0
   \   000014 72A9 0005    ADDW      Y, #0x5
   \   000018 90F6         LD        A, (Y)
   \   00001A 905F         CLRW      Y
   \   00001C 9097         LD        YL, A
   \   00001E 4F           CLR       A
   \   00001F 02           RLWA      X, A
   \   000020 90BF ..      LDW       S:?w0, Y
   \   000023 01           RRWA      X, A
   \   000024 BA ..        OR        A, S:?b1
   \   000026 01           RRWA      X, A
   \   000027 BA ..        OR        A, S:?b0
   \   000029 01           RRWA      X, A
    724          
    725            /* Return the selected ADC conversion value */
    726            return (uint16_t)(tmpreg) ;
   \   00002A 87           RETF
    727          }
    728          
    729           /**
    730            * @}
    731            */
    732          
    733          /** @defgroup ADC_Group5 ADC Channels DMA Configuration function
    734           *  @brief   ADC Channels DMA Configuration function 
    735           *
    736          @verbatim   
    737           ===============================================================================
    738                             ADC Channels DMA Configuration function
    739           ===============================================================================  
    740          
    741            This section provides a function allowing to configure the DMA for ADC 
    742            channel.
    743            Since converted channel values are stored into a unique data register, 
    744            it is useful to use DMA for conversion of more than one channel. This 
    745            avoids the loss of the data already stored in the ADC Data register. 
    746            
    747            When the DMA mode is enabled (using the ADC_DMACmd() function), after each
    748            conversion of a channel, a DMA request is generated.
    749          
    750          @endverbatim
    751            * @{
    752            */
    753          /**
    754            * @brief  Enables or disables the specified ADC DMA request.
    755            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
    756            * @param  NewState : new state of the specified ADC DMA transfer.
    757              *         This parameter can be: ENABLE or DISABLE.
    758            * @retval None
    759            */

   \                                 In section .far_func.text, align 1
    760          void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    761          {
    762            /* Check the parameters */
    763            assert_param(IS_FUNCTIONAL_STATE(NewState));
    764          
    765            if (NewState != DISABLE)
   \                     ADC_DMACmd:
   \   000000 4D           TNZ       A
   \   000001 27 0F        JREQ      L:??ADC_DMACmd_0
    766            {
    767              /* Enable the specified ADC DMA request */
    768              ADCx->SQR[0] &= (uint8_t)~ADC_SQR1_DMAOFF;
   \   000003 9093         LDW       Y, X
   \   000005 72A9 000A    ADDW      Y, #0xa
   \   000009 90F6         LD        A, (Y)
   \   00000B A4 7F        AND       A, #0x7f
   \   00000D 1C 000A      ADDW      X, #0xa
   \   000010 F7           LD        (X), A
   \   000011 87           RETF
    769            }
    770            else
    771            {
    772              /* Disable the specified ADC DMA request */
    773              ADCx->SQR[0] |= ADC_SQR1_DMAOFF;
   \                     ??ADC_DMACmd_0:
   \   000012 9093         LDW       Y, X
   \   000014 72A9 000A    ADDW      Y, #0xa
   \   000018 90F6         LD        A, (Y)
   \   00001A AA 80        OR        A, #0x80
   \   00001C 1C 000A      ADDW      X, #0xa
   \   00001F F7           LD        (X), A
    774            }
    775          }
   \   000020 87           RETF
    776          
    777          /**
    778            * @}
    779            */
    780          
    781          /** @defgroup ADC_Group6 Interrupts and flags management functions
    782           *  @brief   Interrupts and flags management functions
    783           *
    784          @verbatim   
    785           ===============================================================================
    786                             Interrupts and flags management functions
    787           ===============================================================================  
    788          
    789            This section provides functions allowing to configure the ADC Interrupts and 
    790            get the status and clear flags and Interrupts pending bits.
    791            
    792            The ADC provides 3 Interrupt sources and 3 Flags:
    793            
    794            Flags :
    795            ---------- 
    796               1. ADC_FLAG_OVR : Overrun detection when ADC channel converted data is lost
    797          
    798               2. ADC_FLAG_EOC : End of conversion- to indicate the end of a regular 
    799                            CHANNEL conversion or a GROUP conversions, depending of the 
    800                            ADC Continuous Conversion Mode (Continuous or Single 
    801                            conversion) and of the DMA usage.
    802                            Note : if DMA is used, EOC occurs at the end of the sequence 
    803                                   conversion, else it occurs after each conversion
    804               3. ADC_FLAG_AWD: to indicate if the converted voltage crosses the 
    805                          programmed Analog watchdog thresholds values.
    806          
    807               
    808            Interrupts :
    809            ------------
    810               1. ADC_IT_OVR : specifies the interrupt source for the Overrun detection event.
    811               2. ADC_IT_EOC : specifies the interrupt source for the End of conversion event.
    812               3. ADC_IT_AWD : specifies the interrupt source for the Analog watchdog event.
    813          
    814          @endverbatim
    815            * @{
    816            */ 
    817          
    818          /**
    819            * @brief  Enables or disables the specified ADC interrupts.
    820            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
    821            * @param  ADC_IT : specifies the ADC interrupt sources to be enabled or 
    822            *         disabled. 
    823            *          This parameter can be one of the following values:
    824            *            @arg ADC_IT_EOC: End of Conversion Interrupt
    825            *            @arg ADC_IT_AWD: Analog Watchdog Interrupt
    826            *            @arg ADC_IT_OVER: Over Run Interrupt
    827            * @param  NewState : new state of the specified ADC interrupts.
    828              *         This parameter can be: ENABLE or DISABLE.
    829            * @retval None
    830            */

   \                                 In section .far_func.text, align 1
    831          void ADC_ITConfig(ADC_TypeDef* ADCx, ADC_IT_TypeDef ADC_IT, FunctionalState NewState)
    832          {
    833            /* Check the parameters */
    834            assert_param(IS_FUNCTIONAL_STATE(NewState));
    835            assert_param(IS_ADC_IT(ADC_IT));
    836          
    837            if (NewState != DISABLE)
   \                     ADC_ITConfig:
   \   000000 3D ..        TNZ       S:?b0
   \   000002 27 03        JREQ      L:??ADC_ITConfig_0
    838            {
    839              /* Enable the selected ADC interrupts */
    840              ADCx->CR1 |= (uint8_t) ADC_IT;
   \   000004 FA           OR        A, (X)
   \   000005 F7           LD        (X), A
   \   000006 87           RETF
    841            }
    842            else
    843            {
    844              /* Disable the selected ADC interrupts */
    845              ADCx->CR1 &= (uint8_t)(~ADC_IT);
   \                     ??ADC_ITConfig_0:
   \   000007 43           CPL       A
   \   000008 F4           AND       A, (X)
   \   000009 F7           LD        (X), A
    846            }
    847          }
   \   00000A 87           RETF
    848          
    849          /**
    850            * @brief  Checks whether the specified ADC flag is set or not.
    851            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
    852            * @param  ADC_FLAG: specifies the flag to check.
    853            *          This parameter can be one of the following values:
    854            *            @arg ADC_FLAG_EOC: End of Conversion flag
    855            *            @arg ADC_FLAG_AWD: Analog Watchdog flag
    856            *            @arg ADC_FLAG_OVER: Over Run flag    
    857            * @retval The new state of ADC_FLAG (SET or RESET).
    858            */

   \                                 In section .far_func.text, align 1
    859          FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, ADC_FLAG_TypeDef ADC_FLAG)
    860          {
    861            FlagStatus flagstatus = RESET;
   \                     ADC_GetFlagStatus:
   \   000000 3F ..        CLR       S:?b0
    862          
    863            /* Check the parameters */
    864            assert_param(IS_ADC_GET_FLAG(ADC_FLAG));
    865          
    866            /* Check the status of the specified ADC flag */
    867            if ((ADCx->SR & ADC_FLAG) != (uint8_t)RESET)
   \   000002 1C 0003      ADDW      X, #0x3
   \   000005 F4           AND       A, (X)
   \   000006 A1 00        CP        A, #0x0
   \   000008 27 06        JREQ      L:??ADC_GetFlagStatus_0
    868            {
    869              /* ADC_FLAG is set */
    870              flagstatus = SET;
   \   00000A 35 01 ....   MOV       S:?b0, #0x1
   \   00000E 20 02        JRA       L:??ADC_GetFlagStatus_1
    871            }
    872            else
    873            {
    874              /* ADC_FLAG is reset */
    875              flagstatus = RESET;
   \                     ??ADC_GetFlagStatus_0:
   \   000010 3F ..        CLR       S:?b0
    876            }
    877          
    878            /* Return the ADC_FLAG status */
    879            return  flagstatus;
   \                     ??ADC_GetFlagStatus_1:
   \   000012 B6 ..        LD        A, S:?b0
   \   000014 87           RETF
    880          }
    881          
    882          /**
    883            * @brief  Clears the ADC's pending flags.
    884            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
    885            * @param  ADC_FLAG: specifies the flag to clear.
    886            *          This parameter can be one of the following values:
    887            *            @arg ADC_FLAG_EOC: End of Conversion flag
    888            *            @arg ADC_FLAG_AWD: Analog Watchdog flag
    889            *            @arg ADC_FLAG_OVER: Over Run flag 
    890            * @retval None
    891            */

   \                                 In section .far_func.text, align 1
    892          void ADC_ClearFlag(ADC_TypeDef* ADCx,
    893                             ADC_FLAG_TypeDef ADC_FLAG)
    894          {
    895            /* Check the parameters */
    896            assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));
    897          
    898            /* Clear the selected ADC flags */
    899            ADCx->SR = (uint8_t)~ADC_FLAG;
   \                     ADC_ClearFlag:
   \   000000 1C 0003      ADDW      X, #0x3
   \   000003 43           CPL       A
   \   000004 F7           LD        (X), A
    900          }
   \   000005 87           RETF
    901          
    902          /**
    903            * @brief  Checks whether the specified ADC interrupt has occurred or not.
    904            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
    905            * @param  ADC_IT: specifies the ADC interrupt source to check.
    906            *          This parameter can be one of the following values:
    907            *            @arg ADC_IT_EOC: End of Conversion Interrupt
    908            *            @arg ADC_IT_AWD: Analog Watchdog Interrupt
    909            *            @arg ADC_IT_OVER: Over Run Interrupt
    910            * @retval Status of ADC_IT (SET or RESET).
    911            */

   \                                 In section .far_func.text, align 1
    912          ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx,
    913                                   ADC_IT_TypeDef ADC_IT)
    914          {
   \                     ADC_GetITStatus:
   \   000000 B7 ..        LD        S:?b3, A
    915            ITStatus itstatus = RESET;
   \   000002 3F ..        CLR       S:?b0
    916            uint8_t itmask = 0, enablestatus = 0;
   \   000004 3F ..        CLR       S:?b2
   \   000006 3F ..        CLR       S:?b1
    917          
    918            /* Check the parameters */
    919            assert_param(IS_ADC_GET_IT(ADC_IT));
    920          
    921            /* Get the ADC IT index */
    922            itmask = (uint8_t)(ADC_IT >> 3);
   \   000008 B6 ..        LD        A, S:?b3
   \   00000A 44           SRL       A
   \   00000B 44           SRL       A
   \   00000C 44           SRL       A
   \   00000D B7 ..        LD        S:?b2, A
    923            itmask =  (uint8_t)((uint8_t)((uint8_t)(itmask & (uint8_t)0x10) >> 2) | \
    924                                          (uint8_t)(itmask & (uint8_t)0x03));
   \   00000F B6 ..        LD        A, S:?b2
   \   000011 A4 10        AND       A, #0x10
   \   000013 44           SRL       A
   \   000014 44           SRL       A
   \   000015 B7 ..        LD        S:?b4, A
   \   000017 B6 ..        LD        A, S:?b2
   \   000019 A4 03        AND       A, #0x3
   \   00001B BA ..        OR        A, S:?b4
   \   00001D B7 ..        LD        S:?b2, A
    925          
    926            /* Get the ADC_IT enable bit status */
    927            enablestatus = (uint8_t)(ADCx->CR1 & (uint8_t)ADC_IT) ;
   \   00001F B6 ..        LD        A, S:?b3
   \   000021 F4           AND       A, (X)
   \   000022 B7 ..        LD        S:?b1, A
    928          
    929            /* Check the status of the specified ADC interrupt */
    930            if (((ADCx->SR & itmask) != (uint8_t)RESET) && enablestatus)
   \   000024 1C 0003      ADDW      X, #0x3
   \   000027 B6 ..        LD        A, S:?b2
   \   000029 F4           AND       A, (X)
   \   00002A A1 00        CP        A, #0x0
   \   00002C 27 0A        JREQ      L:??ADC_GetITStatus_0
   \   00002E 3D ..        TNZ       S:?b1
   \   000030 27 06        JREQ      L:??ADC_GetITStatus_0
    931            {
    932              /* ADC_IT is set */
    933              itstatus = SET;
   \   000032 35 01 ....   MOV       S:?b0, #0x1
   \   000036 20 02        JRA       L:??ADC_GetITStatus_1
    934            }
    935            else
    936            {
    937              /* ADC_IT is reset */
    938              itstatus = RESET;
   \                     ??ADC_GetITStatus_0:
   \   000038 3F ..        CLR       S:?b0
    939            }
    940          
    941            /* Return the ADC_IT status */
    942            return  itstatus;
   \                     ??ADC_GetITStatus_1:
   \   00003A B6 ..        LD        A, S:?b0
   \   00003C 87           RETF
    943          }
    944          
    945          /**
    946            * @brief  Clears the ADCs interrupt pending bits.
    947            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
    948            * @param  ADC_IT: specifies the ADC interrupt pending bit to clear.
    949            *          This parameter can be one of the following values:
    950            *            @arg ADC_IT_EOC: End of Conversion Interrupt
    951            *            @arg ADC_IT_AWD: Analog Watchdog Interrupt
    952            *            @arg ADC_IT_OVER: Over Run Interrupt
    953            * @retval None
    954            */

   \                                 In section .far_func.text, align 1
    955          void ADC_ClearITPendingBit(ADC_TypeDef* ADCx,
    956                                     ADC_IT_TypeDef ADC_IT)
    957          {
    958            uint8_t itmask = 0;
   \                     ADC_ClearITPendingBit:
   \   000000 3F ..        CLR       S:?b0
    959          
    960            /* Check the parameters */
    961            assert_param(IS_ADC_IT(ADC_IT));
    962          
    963            /* Get the ADC IT index */
    964            itmask = (uint8_t)(ADC_IT >> 3);
   \   000002 44           SRL       A
   \   000003 44           SRL       A
   \   000004 44           SRL       A
   \   000005 B7 ..        LD        S:?b0, A
    965            itmask =  (uint8_t)((uint8_t)(((uint8_t)(itmask & (uint8_t)0x10)) >> 2) | \
    966                                           (uint8_t)(itmask & (uint8_t)0x03));
   \   000007 B6 ..        LD        A, S:?b0
   \   000009 A4 10        AND       A, #0x10
   \   00000B 44           SRL       A
   \   00000C 44           SRL       A
   \   00000D B7 ..        LD        S:?b1, A
   \   00000F B6 ..        LD        A, S:?b0
   \   000011 A4 03        AND       A, #0x3
   \   000013 BA ..        OR        A, S:?b1
   \   000015 B7 ..        LD        S:?b0, A
    967          
    968            /* Clear the selected ADC interrupt pending bits */
    969            ADCx->SR = (uint8_t)~itmask;
   \   000017 1C 0003      ADDW      X, #0x3
   \   00001A 33 ..        CPL       S:?b0
   \   00001C B6 ..        LD        A, S:?b0
   \   00001E F7           LD        (X), A
    970          }
   \   00001F 87           RETF
    971          
    972          /**
    973            * @}
    974            */ 
    975          
    976          /**
    977            * @}
    978            */
    979          
    980          /**
    981            * @}
    982            */ 
    983          
    984          /**
    985            * @}
    986            */ 
    987          
    988          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Section sizes:

   Bytes  Function/Label
   -----  --------------
      35  ADC_AnalogWatchdogChannelSelect
      70  ADC_AnalogWatchdogConfig
      40  ADC_AnalogWatchdogThresholdsConfig
      75  ADC_ChannelCmd
       6  ADC_ClearFlag
      32  ADC_ClearITPendingBit
      13  ADC_Cmd
      33  ADC_DMACmd
     136  ADC_DeInit
      29  ADC_ExternalTrigConfig
      43  ADC_GetConversionValue
      21  ADC_GetFlagStatus
      61  ADC_GetITStatus
      11  ADC_ITConfig
      37  ADC_Init
      65  ADC_SamplingTimeConfig
      75  ADC_SchmittTriggerConfig
       5  ADC_SoftwareStartConv
      13  ADC_TempSensorCmd
      13  ADC_VrefintCmd

 
 813 bytes in section .far_func.text
 
 813 bytes of CODE memory

Errors: none
Warnings: none
