###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.42.1.142 for STM8               01/Jul/2016  17:30:50 #
# Copyright 2010-2013 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  E:\hwpro-2016\20160627_L\stm8l15x_lib\src\stm8l15x_tim2. #
#                    c                                                        #
#    Command line =  E:\hwpro-2016\20160627_L\stm8l15x_lib\src\stm8l15x_tim2. #
#                    c -e -Ol --no_cse --no_unroll --no_inline                #
#                    --no_code_motion --no_tbaa --no_cross_call --debug       #
#                    --code_model medium --data_model medium -o               #
#                    E:\hwpro-2016\20160627_L\iar\Debug\Obj\ --dlib_config    #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.5\stm8\LIB\dlstm8mmn.h" -D STM8L15X_MD -lC             #
#                    E:\hwpro-2016\20160627_L\iar\Debug\List\ -I              #
#                    E:\hwpro-2016\20160627_L\iar\..\stm8l15x_lib\inc\ -I     #
#                    E:\hwpro-2016\20160627_L\iar\..\user\inc\ -I             #
#                    E:\hwpro-2016\20160627_L\iar\..\utils\xprintf\ -I        #
#                    E:\hwpro-2016\20160627_L\iar\..\drivers\ -I              #
#                    E:\hwpro-2016\20160627_L\iar\..\utils\ -I                #
#                    E:\hwpro-2016\20160627_L\iar\..\app\ --vregs 16          #
#    List file    =  E:\hwpro-2016\20160627_L\iar\Debug\List\stm8l15x_tim2.ls #
#                    t                                                        #
#    Object file  =  E:\hwpro-2016\20160627_L\iar\Debug\Obj\stm8l15x_tim2.o   #
#                                                                             #
#                                                                             #
###############################################################################

E:\hwpro-2016\20160627_L\stm8l15x_lib\src\stm8l15x_tim2.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm8l15x_tim2.c
      4            * @author  MCD Application Team
      5            * @version V1.6.1
      6            * @date    30-September-2014
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the TIM2 peripheral:
      9            *            - TimeBase management
     10            *            - Output Compare management
     11            *            - Input Capture management
     12            *            - Interrupts, DMA and flags management
     13            *            - Clocks management
     14            *            - Synchronization management
     15            *            - Specific interface management
     16            *              
     17            *  @verbatim
     18            *  
     19            *          ===================================================================
     20            *                                 How to use this driver
     21            *          ===================================================================
     22            *          This driver provides functions to configure and initialize the TIM2
     23            *          peripheral
     24            *          These functions are split in 7 groups: 
     25            *   
     26            *          1. TIM2 TimeBase management: this group includes all needed functions 
     27            *             to configure the TIM Timebase unit:
     28            *                   - Set/Get Prescaler
     29            *                   - Set/Get Autoreload  
     30            *                   - Counter modes configuration
     31            *                   - Select the One Pulse mode
     32            *                   - Update Request Configuration
     33            *                   - Update Disable Configuration
     34            *                   - Auto-Preload Configuration 
     35            *                   - Enable/Disable the counter
     36            *                 
     37            *          2. TIM2 Output Compare management: this group includes all needed 
     38            *             functions to configure the Capture/Compare unit used in Output 
     39            *             compare mode: 
     40            *                   - Configure each channel, independently, in Output Compare mode
     41            *                   - Select the output compare modes
     42            *                   - Select the Polarities of each channel
     43            *                   - Set/Get the Capture/Compare register values
     44            *                   - Select the Output Compare Fast mode 
     45            *                   - Select the Output Compare Forced mode  
     46            *                   - Output Compare-Preload Configuration 
     47            *                   - Enable/Disable the Capture/Compare Channels    
     48            *                   
     49            *          3. TIM2 Input Capture management: this group includes all needed 
     50            *             functions to configure the Capture/Compare unit used in 
     51            *             Input Capture mode:
     52            *                   - Configure each channel in input capture mode
     53            *                   - Configure Channel1/2 in PWM Input mode
     54            *                   - Set the Input Capture Prescaler
     55            *                   - Get the Capture/Compare values      
     56            *        
     57            *          4. TIM2 interrupts, DMA and flags management
     58            *                   - Enable/Disable interrupt sources
     59            *                   - Get flags status
     60            *                   - Clear flags/ Pending bits
     61            *                   - Enable/Disable DMA requests 
     62            *                   - Select CaptureCompare DMA request  
     63            *              
     64            *          5. TIM2 clocks management: this group includes all needed functions 
     65            *             to configure the clock controller unit:
     66            *                   - Select internal/External clock
     67            *                   - Select the external clock mode: ETR(Mode1/Mode2) or TIx
     68            *         
     69            *          6. TIM2 synchronization management: this group includes all needed 
     70            *             functions to configure the Synchronization unit:
     71            *                   - Select Input Trigger  
     72            *                   - Select Output Trigger  
     73            *                   - Select Master Slave Mode 
     74            *                   - ETR Configuration when used as external trigger   
     75            *     
     76            *          7. TIM2 specific interface management, this group includes all 
     77            *             needed functions to use the specific TIM2 interface:
     78            *                   - Encoder Interface Configuration
     79            *                   - Select Hall Sensor        
     80            *   
     81            *  @endverbatim
     82            *    
     83            ******************************************************************************
     84            * @attention
     85            *
     86            * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
     87            *
     88            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     89            * You may not use this file except in compliance with the License.
     90            * You may obtain a copy of the License at:
     91            *
     92            *        http://www.st.com/software_license_agreement_liberty_v2
     93            *
     94            * Unless required by applicable law or agreed to in writing, software 
     95            * distributed under the License is distributed on an "AS IS" BASIS, 
     96            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     97            * See the License for the specific language governing permissions and
     98            * limitations under the License.
     99            *
    100            ******************************************************************************
    101            */
    102          
    103          /* Includes ------------------------------------------------------------------*/
    104          #include "stm8l15x_TIM2.h"
    105          
    106          /** @addtogroup STM8L15x_StdPeriph_Driver
    107            * @{
    108            */
    109          
    110          /** @defgroup TIM2 
    111            * @brief TIM2 driver modules
    112            * @{
    113            */
    114            
    115          /* Private typedef -----------------------------------------------------------*/
    116          /* Private define ------------------------------------------------------------*/
    117          /* Private macro -------------------------------------------------------------*/
    118          /* Private variables ---------------------------------------------------------*/
    119          /* Private function prototypes -----------------------------------------------*/
    120          static void TI1_Config(TIM2_ICPolarity_TypeDef TIM2_ICPolarity,
    121                                 TIM2_ICSelection_TypeDef TIM2_ICSelection,
    122                                 uint8_t TIM2_ICFilter);
    123          static void TI2_Config(TIM2_ICPolarity_TypeDef TIM2_ICPolarity,
    124                                 TIM2_ICSelection_TypeDef TIM2_ICSelection,
    125                                 uint8_t TIM2_ICFilter);
    126          
    127          
    128          /** @defgroup TIM2_Private_Functions
    129            * @{
    130            */
    131          
    132          /** @defgroup TIM2_Group1 TimeBase management functions
    133           *  @brief   TimeBase management functions 
    134           *
    135          @verbatim   
    136           ===============================================================================
    137                                 TimeBase management functions
    138           ===============================================================================  
    139            
    140                 ===================================================================      
    141                        TIM2 Driver: how to use it in Timing(Time base) Mode
    142                 =================================================================== 
    143                 To use the Timer in Timing(Time base) mode, the following steps are mandatory:
    144                 
    145                 1. Enable TIM2 clock using CLK_PeripheralClockConfig(CLK_Peripheral_TIM2, ENABLE) function.
    146                  
    147                 2. Call TIM2_TimeBaseInit() to configure the Time Base unit with the
    148                    corresponding configuration.
    149                    
    150                 3. Enable global interrupts if you need to generate the update interrupt.
    151                    
    152                 4. Enable the corresponding interrupt using the function TIM2_ITConfig(TIM2_IT_Update) 
    153                    
    154                 5. Call the TIM2_Cmd(ENABLE) function to enable the TIM2 counter.
    155                 
    156                 Note1: All other functions can be used separately to modify, if needed,
    157                    a specific feature of the Timer. 
    158          
    159          @endverbatim
    160            * @{
    161            */
    162          
    163          /**
    164            * @brief  Deinitialize the TIM2 peripheral registers to their default reset values.
    165            * @param  None
    166            * @retval None
    167            */

   \                                 In section .far_func.text, align 1
    168          void TIM2_DeInit(void)
    169          {
    170            TIM2->CR1 = TIM_CR1_RESET_VALUE;
   \                     TIM2_DeInit:
   \   000000 35 00 5250   MOV       L:0x5250, #0x0
    171            TIM2->CR2 = TIM_CR2_RESET_VALUE;
   \   000004 35 00 5251   MOV       L:0x5251, #0x0
    172            TIM2->SMCR = TIM_SMCR_RESET_VALUE;
   \   000008 35 00 5252   MOV       L:0x5252, #0x0
    173            TIM2->ETR = TIM_ETR_RESET_VALUE;
   \   00000C 35 00 5253   MOV       L:0x5253, #0x0
    174            TIM2->IER = TIM_IER_RESET_VALUE;
   \   000010 35 00 5255   MOV       L:0x5255, #0x0
    175            TIM2->SR2 = TIM_SR2_RESET_VALUE;
   \   000014 35 00 5257   MOV       L:0x5257, #0x0
    176          
    177            /* Disable channels */
    178            TIM2->CCER1 = TIM_CCER1_RESET_VALUE;
   \   000018 35 00 525B   MOV       L:0x525b, #0x0
    179            /* Configure channels as inputs: it is necessary if lock level is equal to 2 or 3 */
    180            TIM2->CCMR1 = 0x01;/*TIM2_ICxSource_TIxFPx */
   \   00001C 35 01 5259   MOV       L:0x5259, #0x1
    181            TIM2->CCMR2 = 0x01;/*TIM2_ICxSource_TIxFPx */
   \   000020 35 01 525A   MOV       L:0x525a, #0x1
    182          
    183            /* Then reset channel registers: it also works if lock level is equal to 2 or 3 */
    184            TIM2->CCER1 = TIM_CCER1_RESET_VALUE;
   \   000024 35 00 525B   MOV       L:0x525b, #0x0
    185            TIM2->CCMR1 = TIM_CCMR1_RESET_VALUE;
   \   000028 35 00 5259   MOV       L:0x5259, #0x0
    186            TIM2->CCMR2 = TIM_CCMR2_RESET_VALUE;
   \   00002C 35 00 525A   MOV       L:0x525a, #0x0
    187          
    188            TIM2->CNTRH = TIM_CNTRH_RESET_VALUE;
   \   000030 35 00 525C   MOV       L:0x525c, #0x0
    189            TIM2->CNTRL = TIM_CNTRL_RESET_VALUE;
   \   000034 35 00 525D   MOV       L:0x525d, #0x0
    190          
    191            TIM2->PSCR = TIM_PSCR_RESET_VALUE;
   \   000038 35 00 525E   MOV       L:0x525e, #0x0
    192          
    193            TIM2->ARRH = TIM_ARRH_RESET_VALUE;
   \   00003C 35 FF 525F   MOV       L:0x525f, #0xff
    194            TIM2->ARRL = TIM_ARRL_RESET_VALUE;
   \   000040 35 FF 5260   MOV       L:0x5260, #0xff
    195          
    196            TIM2->CCR1H = TIM_CCR1H_RESET_VALUE;
   \   000044 35 00 5261   MOV       L:0x5261, #0x0
    197            TIM2->CCR1L = TIM_CCR1L_RESET_VALUE;
   \   000048 35 00 5262   MOV       L:0x5262, #0x0
    198            TIM2->CCR2H = TIM_CCR2H_RESET_VALUE;
   \   00004C 35 00 5263   MOV       L:0x5263, #0x0
    199            TIM2->CCR2L = TIM_CCR2L_RESET_VALUE;
   \   000050 35 00 5264   MOV       L:0x5264, #0x0
    200          
    201          
    202            TIM2->OISR = TIM_OISR_RESET_VALUE;
   \   000054 35 00 5266   MOV       L:0x5266, #0x0
    203            TIM2->EGR = 0x01;/* TIM_EGR_UG */
   \   000058 35 01 5258   MOV       L:0x5258, #0x1
    204            TIM2->BKR = TIM_BKR_RESET_VALUE;
   \   00005C 35 00 5265   MOV       L:0x5265, #0x0
    205            TIM2->SR1 = TIM_SR1_RESET_VALUE;
   \   000060 35 00 5256   MOV       L:0x5256, #0x0
    206          }
   \   000064 87           RETF
    207          
    208          /**
    209            * @brief  Initializes the TIM2 Time Base Unit according to the specified  parameters.
    210            * @param  TIM2_Prescaler: Prescaler 
    211            *          This parameter can be one of the following values:
    212            *            @arg TIM2_Prescaler_1: Time base Prescaler = 1 (No effect)
    213            *            @arg TIM2_Prescaler_2: Time base Prescaler = 2
    214            *            @arg TIM2_Prescaler_4: Time base Prescaler = 4
    215            *            @arg TIM2_Prescaler_8: Time base Prescaler = 8
    216            *            @arg TIM2_Prescaler_16: Time base Prescaler = 16
    217            *            @arg TIM2_Prescaler_32: Time base Prescaler = 32
    218            *            @arg TIM2_Prescaler_64: Time base Prescaler = 64
    219            *            @arg TIM2_Prescaler_128: Time base Prescaler = 128                            
    220            * @param  TIM2_CounterMode: Counter mode
    221            *          This parameter can be one of the following values:
    222            *            @arg TIM2_CounterMode_Up: Counter Up Mode
    223            *            @arg TIM2_CounterMode_Down: Counter Down Mode
    224            *            @arg TIM2_CounterMode_CenterAligned1: Counter Central aligned Mode 1
    225            *            @arg TIM2_CounterMode_CenterAligned2: Counter Central aligned Mode 2
    226            *            @arg TIM2_CounterMode_CenterAligned3: Counter Central aligned Mode 3        
    227            * @param  TIM2_Period: This parameter must be a value between 0x0000 and 0xFFFF.
    228            * @retval None
    229            */
    230          

   \                                 In section .far_func.text, align 1
    231          void TIM2_TimeBaseInit(TIM2_Prescaler_TypeDef TIM2_Prescaler,
    232                                 TIM2_CounterMode_TypeDef TIM2_CounterMode,
    233                                 uint16_t TIM2_Period)
    234          {
   \                     TIM2_TimeBaseInit:
   \   000000 B7 ..        LD        S:?b1, A
   \   000002 9093         LDW       Y, X
    235          
    236            assert_param(IS_TIM2_PRESCALER(TIM2_Prescaler));
    237            assert_param(IS_TIM2_COUNTER_MODE(TIM2_CounterMode));
    238          
    239          
    240          
    241            /* Set the Autoreload value */
    242            TIM2->ARRH = (uint8_t)(TIM2_Period >> 8) ;
   \   000004 93           LDW       X, Y
   \   000005 4F           CLR       A
   \   000006 01           RRWA      X, A
   \   000007 9F           LD        A, XL
   \   000008 C7 525F      LD        L:0x525f, A
    243            TIM2->ARRL = (uint8_t)(TIM2_Period);
   \   00000B 909F         LD        A, YL
   \   00000D C7 5260      LD        L:0x5260, A
    244          
    245            /* Set the Prescaler value */
    246            TIM2->PSCR = (uint8_t)(TIM2_Prescaler);
   \   000010 B6 ..        LD        A, S:?b1
   \   000012 C7 525E      LD        L:0x525e, A
    247          
    248            /* Select the Counter Mode */
    249            TIM2->CR1 &= (uint8_t)((uint8_t)(~TIM_CR1_CMS)) & ((uint8_t)(~TIM_CR1_DIR));
   \   000015 C6 5250      LD        A, L:0x5250
   \   000018 A4 8F        AND       A, #0x8f
   \   00001A C7 5250      LD        L:0x5250, A
    250            TIM2->CR1 |= (uint8_t)(TIM2_CounterMode);
   \   00001D B6 ..        LD        A, S:?b0
   \   00001F CA 5250      OR        A, L:0x5250
   \   000022 C7 5250      LD        L:0x5250, A
    251          
    252            /* Generate an update event to reload the Prescaler value immediately */
    253            TIM2->EGR = TIM2_EventSource_Update;
   \   000025 35 01 5258   MOV       L:0x5258, #0x1
    254          }
   \   000029 87           RETF
    255          
    256          /**
    257            * @brief  Configures the TIM2 Prescaler.
    258            * @param  Prescaler: Specifies the Prescaler Register value
    259            *          This parameter can be one of the following values:
    260            *            @arg TIM2_Prescaler_1: Time base Prescaler = 1 (No effect)
    261            *            @arg TIM2_Prescaler_2: Time base Prescaler = 2
    262            *            @arg TIM2_Prescaler_4: Time base Prescaler = 4
    263            *            @arg TIM2_Prescaler_8: Time base Prescaler = 8
    264            *            @arg TIM2_Prescaler_16: Time base Prescaler = 16
    265            *            @arg TIM2_Prescaler_32: Time base Prescaler = 32
    266            *            @arg TIM2_Prescaler_64: Time base Prescaler = 64
    267            *            @arg TIM2_Prescaler_128: Time base Prescaler = 128  
    268            * @param  TIM2_PSCReloadMode: Specifies the TIM2 Prescaler Reload mode.
    269            *          This parameter can be one of the following values:
    270            *            @arg TIM2_PSCReloadMode_Update: Prescaler value is reloaded at every update
    271            *            @arg TIM2_PSCReloadMode_Immediate: Prescaler value is reloaded at every update  
    272            * @retval None
    273            */

   \                                 In section .far_func.text, align 1
    274          void TIM2_PrescalerConfig(TIM2_Prescaler_TypeDef Prescaler,
    275                                    TIM2_PSCReloadMode_TypeDef TIM2_PSCReloadMode)
    276          {
    277            /* Check the parameters */
    278            assert_param(IS_TIM2_PRESCALER(Prescaler));
    279            assert_param(IS_TIM2_PRESCALER_RELOAD(TIM2_PSCReloadMode));
    280          
    281            /* Set the Prescaler value */
    282            TIM2->PSCR = (uint8_t)(Prescaler);
   \                     TIM2_PrescalerConfig:
   \   000000 C7 525E      LD        L:0x525e, A
    283          
    284            /* Set or reset the UG Bit */
    285            if (TIM2_PSCReloadMode == TIM2_PSCReloadMode_Immediate)
   \   000003 B6 ..        LD        A, S:?b0
   \   000005 A1 01        CP        A, #0x1
   \   000007 26 05        JRNE      L:??TIM2_PrescalerConfig_0
    286            {
    287              TIM2->EGR |= TIM_EGR_UG ;
   \   000009 7210 5258    BSET      L:0x5258, #0x0
   \   00000D 87           RETF
    288            }
    289            else
    290            {
    291              TIM2->EGR &= (uint8_t)(~TIM_EGR_UG) ;
   \                     ??TIM2_PrescalerConfig_0:
   \   00000E 7211 5258    BRES      L:0x5258, #0x0
    292            }
    293          }
   \   000012 87           RETF
    294          
    295          /**
    296            * @brief  Specifies the TIM2 Counter Mode to be used.
    297            * @param  TIM2_CounterMode: Specifies the Counter Mode to be used
    298            *          This parameter can be one of the following values:
    299            *            @arg TIM2_CounterMode_Up: Counter Up Mode
    300            *            @arg TIM2_CounterMode_Down: Counter Down Mode
    301            *            @arg TIM2_CounterMode_CenterAligned1: Counter Central aligned Mode 1
    302            *            @arg TIM2_CounterMode_CenterAligned2: Counter Central aligned Mode 2
    303            *            @arg TIM2_CounterMode_CenterAligned3: Counter Central aligned Mode 3      
    304            * @retval None
    305            */

   \                                 In section .far_func.text, align 1
    306          void TIM2_CounterModeConfig(TIM2_CounterMode_TypeDef TIM2_CounterMode)
    307          {
   \                     TIM2_CounterModeConfig:
   \   000000 B7 ..        LD        S:?b0, A
    308            uint8_t tmpcr1 = 0;
   \   000002 3F ..        CLR       S:?b1
    309          
    310            /* Check the parameters */
    311            assert_param(IS_TIM2_COUNTER_MODE(TIM2_CounterMode));
    312          
    313            tmpcr1 = TIM2->CR1;
   \   000004 C6 5250      LD        A, L:0x5250
   \   000007 B7 ..        LD        S:?b1, A
    314          
    315            /* Reset the CMS and DIR Bits */
    316            tmpcr1 &= (uint8_t)((uint8_t)(~TIM_CR1_CMS) & (uint8_t)(~TIM_CR1_DIR));
   \   000009 B6 ..        LD        A, S:?b1
   \   00000B A4 8F        AND       A, #0x8f
   \   00000D B7 ..        LD        S:?b1, A
    317          
    318            /* Set the Counter Mode */
    319            tmpcr1 |= (uint8_t)TIM2_CounterMode;
   \   00000F B6 ..        LD        A, S:?b0
   \   000011 BA ..        OR        A, S:?b1
   \   000013 B7 ..        LD        S:?b1, A
    320          
    321            TIM2->CR1 = tmpcr1;
   \   000015 B6 ..        LD        A, S:?b1
   \   000017 C7 5250      LD        L:0x5250, A
    322          }
   \   00001A 87           RETF
    323          
    324          /**
    325            * @brief  Sets the TIM2 Counter Register value.
    326            * @param  Counter: Specifies the Counter register new value.
    327            *          This parameter is between 0x0000 and 0xFFFF.
    328            * @retval None
    329            */

   \                                 In section .far_func.text, align 1
    330          void TIM2_SetCounter(uint16_t Counter)
    331          {
   \                     TIM2_SetCounter:
   \   000000 9093         LDW       Y, X
    332          
    333            /* Set the Counter Register value */
    334            TIM2->CNTRH = (uint8_t)(Counter >> 8);
   \   000002 93           LDW       X, Y
   \   000003 4F           CLR       A
   \   000004 01           RRWA      X, A
   \   000005 9F           LD        A, XL
   \   000006 C7 525C      LD        L:0x525c, A
    335            TIM2->CNTRL = (uint8_t)(Counter);
   \   000009 909F         LD        A, YL
   \   00000B C7 525D      LD        L:0x525d, A
    336          }
   \   00000E 87           RETF
    337          
    338          /**
    339            * @brief  Sets the TIM2 Autoreload Register value.
    340            * @param  Autoreload: Specifies the Autoreload register new value.
    341            *          This parameter is between 0x0000 and 0xFFFF.
    342            * @retval None
    343            */

   \                                 In section .far_func.text, align 1
    344          void TIM2_SetAutoreload(uint16_t Autoreload)
    345          {
   \                     TIM2_SetAutoreload:
   \   000000 9093         LDW       Y, X
    346            /* Set the Autoreload Register value */
    347            TIM2->ARRH = (uint8_t)(Autoreload >> 8);
   \   000002 93           LDW       X, Y
   \   000003 4F           CLR       A
   \   000004 01           RRWA      X, A
   \   000005 9F           LD        A, XL
   \   000006 C7 525F      LD        L:0x525f, A
    348            TIM2->ARRL = (uint8_t)(Autoreload);
   \   000009 909F         LD        A, YL
   \   00000B C7 5260      LD        L:0x5260, A
    349          }
   \   00000E 87           RETF
    350          
    351          /**
    352            * @brief  Gets the TIM2 Counter value.
    353            * @param  None
    354            * @retval Counter Register value.
    355            */

   \                                 In section .far_func.text, align 1
    356          uint16_t TIM2_GetCounter(void)
    357          {
    358            uint16_t tmpcnt = 0;
   \                     TIM2_GetCounter:
   \   000000 905F         CLRW      Y
    359            uint8_t tmpcntrl, tmpcntrh;
    360          
    361            tmpcntrh = TIM2->CNTRH;
   \   000002 C6 525C      LD        A, L:0x525c
   \   000005 B7 ..        LD        S:?b0, A
    362            tmpcntrl = TIM2->CNTRL;
   \   000007 C6 525D      LD        A, L:0x525d
    363          
    364            tmpcnt = (uint16_t)(tmpcntrl);
   \   00000A 5F           CLRW      X
   \   00000B 97           LD        XL, A
   \   00000C 9093         LDW       Y, X
    365            tmpcnt |= (uint16_t)((uint16_t)tmpcntrh << 8);
   \   00000E 5F           CLRW      X
   \   00000F 41           EXG       A, XL
   \   000010 B6 ..        LD        A, S:?b0
   \   000012 41           EXG       A, XL
   \   000013 4F           CLR       A
   \   000014 02           RLWA      X, A
   \   000015 BF ..        LDW       S:?w0, X
   \   000017 51           EXGW      X, Y
   \   000018 01           RRWA      X, A
   \   000019 BA ..        OR        A, S:?b1
   \   00001B 01           RRWA      X, A
   \   00001C BA ..        OR        A, S:?b0
   \   00001E 01           RRWA      X, A
   \   00001F 51           EXGW      X, Y
    366            /* Get the Counter Register value */
    367            return ((uint16_t)tmpcnt);
   \   000020 93           LDW       X, Y
   \   000021 87           RETF
    368          }
    369          
    370          /**
    371            * @brief  Gets the TIM2 Prescaler value.
    372            * @param  None
    373            * @retval TIM2 Prescaler, it can be one of the following values:
    374            *            - TIM2_Prescaler_1: Time base Prescaler = 1 (No effect)
    375            *            - TIM2_Prescaler_2: Time base Prescaler = 2
    376            *            - TIM2_Prescaler_4: Time base Prescaler = 4
    377            *            - TIM2_Prescaler_8: Time base Prescaler = 8
    378            *            - TIM2_Prescaler_16: Time base Prescaler = 16
    379            *            - TIM2_Prescaler_32: Time base Prescaler = 32
    380            *            - TIM2_Prescaler_64: Time base Prescaler = 64
    381            *            - TIM2_Prescaler_128: Time base Prescaler = 128    
    382            */

   \                                 In section .far_func.text, align 1
    383          TIM2_Prescaler_TypeDef TIM2_GetPrescaler(void)
    384          {
    385            /* Get the Prescaler Register value */
    386            return ((TIM2_Prescaler_TypeDef)TIM2->PSCR);
   \                     TIM2_GetPrescaler:
   \   000000 C6 525E      LD        A, L:0x525e
   \   000003 87           RETF
    387          }
    388          
    389          /**
    390            * @brief  Enables or Disables the TIM2 Update event.
    391            * @param  NewState: The new state of the TIM2 peripheral Preload register.
    392            *          This parameter can be ENABLE or DISABLE
    393            * @retval None
    394            */
    395          

   \                                 In section .far_func.text, align 1
    396          void TIM2_UpdateDisableConfig(FunctionalState NewState)
    397          {
    398            /* Check the parameters */
    399            assert_param(IS_FUNCTIONAL_STATE(NewState));
    400          
    401            /* Set or Reset the UDIS Bit */
    402            if (NewState != DISABLE)
   \                     TIM2_UpdateDisableConfig:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM2_UpdateDisableConfig_0
    403            {
    404              TIM2->CR1 |= TIM_CR1_UDIS;
   \   000003 7212 5250    BSET      L:0x5250, #0x1
   \   000007 87           RETF
    405            }
    406            else
    407            {
    408              TIM2->CR1 &= (uint8_t)(~TIM_CR1_UDIS);
   \                     ??TIM2_UpdateDisableConfig_0:
   \   000008 7213 5250    BRES      L:0x5250, #0x1
    409            }
    410          }
   \   00000C 87           RETF
    411          
    412          /**
    413            * @brief  Selects the TIM2 Update Request Interrupt source.
    414            * @param  TIM2_UpdateSource: Specifies the Update source.
    415            *          This parameter can be one of the following values:
    416            *            @arg TIM2_UpdateSource_Global: Global Update request source
    417            *            @arg TIM2_UpdateSource_Regular: Regular Update request source 
    418            * @retval None
    419            */

   \                                 In section .far_func.text, align 1
    420          void TIM2_UpdateRequestConfig(TIM2_UpdateSource_TypeDef TIM2_UpdateSource)
    421          {
    422            /* Check the parameters */
    423            assert_param(IS_TIM2_UPDATE_SOURCE(TIM2_UpdateSource));
    424          
    425            /* Set or Reset the URS Bit */
    426            if (TIM2_UpdateSource == TIM2_UpdateSource_Regular)
   \                     TIM2_UpdateRequestConfig:
   \   000000 A1 01        CP        A, #0x1
   \   000002 26 05        JRNE      L:??TIM2_UpdateRequestConfig_0
    427            {
    428              TIM2->CR1 |= TIM_CR1_URS ;
   \   000004 7214 5250    BSET      L:0x5250, #0x2
   \   000008 87           RETF
    429            }
    430            else
    431            {
    432              TIM2->CR1 &= (uint8_t)(~TIM_CR1_URS);
   \                     ??TIM2_UpdateRequestConfig_0:
   \   000009 7215 5250    BRES      L:0x5250, #0x2
    433            }
    434          }
   \   00000D 87           RETF
    435          
    436          /**
    437            * @brief  Enables or disables TIM2 peripheral Preload register on ARR.
    438            * @param  NewState: The new state of the TIM2 peripheral Preload register.
    439            *          This parameter can be ENABLE or DISABLE
    440            * @retval None
    441            */

   \                                 In section .far_func.text, align 1
    442          void TIM2_ARRPreloadConfig(FunctionalState NewState)
    443          {
    444            /* Check the parameters */
    445            assert_param(IS_FUNCTIONAL_STATE(NewState));
    446          
    447            /* Set or Reset the ARPE Bit */
    448            if (NewState != DISABLE)
   \                     TIM2_ARRPreloadConfig:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM2_ARRPreloadConfig_0
    449            {
    450              TIM2->CR1 |= TIM_CR1_ARPE;
   \   000003 721E 5250    BSET      L:0x5250, #0x7
   \   000007 87           RETF
    451            }
    452            else
    453            {
    454              TIM2->CR1 &= (uint8_t)(~TIM_CR1_ARPE);
   \                     ??TIM2_ARRPreloadConfig_0:
   \   000008 721F 5250    BRES      L:0x5250, #0x7
    455            }
    456          }
   \   00000C 87           RETF
    457          
    458          /**
    459            * @brief  Selects the TIM’s One Pulse Mode.
    460            * @param  TIM2_OPMode: Specifies the OPM Mode to be used.
    461            *          This parameter can be one of the following values:
    462            *            @arg TIM2_OPMode_Single: Single one Pulse mode (OPM Active)
    463            *            @arg TIM2_OPMode_Repetitive: Single one Pulse mode (OPM Active)  
    464            * @retval None
    465            */

   \                                 In section .far_func.text, align 1
    466          void TIM2_SelectOnePulseMode(TIM2_OPMode_TypeDef TIM2_OPMode)
    467          {
    468            /* Check the parameters */
    469            assert_param(IS_TIM2_OPM_MODE(TIM2_OPMode));
    470          
    471            /* Set or Reset the OPM Bit */
    472            if (TIM2_OPMode == TIM2_OPMode_Single)
   \                     TIM2_SelectOnePulseMode:
   \   000000 A1 01        CP        A, #0x1
   \   000002 26 05        JRNE      L:??TIM2_SelectOnePulseMode_0
    473            {
    474              TIM2->CR1 |= TIM_CR1_OPM ;
   \   000004 7216 5250    BSET      L:0x5250, #0x3
   \   000008 87           RETF
    475            }
    476            else
    477            {
    478              TIM2->CR1 &= (uint8_t)(~TIM_CR1_OPM);
   \                     ??TIM2_SelectOnePulseMode_0:
   \   000009 7217 5250    BRES      L:0x5250, #0x3
    479            }
    480          }
   \   00000D 87           RETF
    481          
    482          /**
    483            * @brief  Enables or disables the TIM2 peripheral.
    484            * @param  NewState: The new state of the TIM2 peripheral.
    485            *          This parameter can be ENABLE or DISABLE
    486            * @retval None
    487            */

   \                                 In section .far_func.text, align 1
    488          void TIM2_Cmd(FunctionalState NewState)
    489          {
    490            /* Check the parameters */
    491            assert_param(IS_FUNCTIONAL_STATE(NewState));
    492          
    493            /* set or Reset the CEN Bit */
    494            if (NewState != DISABLE)
   \                     TIM2_Cmd:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM2_Cmd_0
    495            {
    496              TIM2->CR1 |= TIM_CR1_CEN;
   \   000003 7210 5250    BSET      L:0x5250, #0x0
   \   000007 87           RETF
    497            }
    498            else
    499            {
    500              TIM2->CR1 &= (uint8_t)(~TIM_CR1_CEN);
   \                     ??TIM2_Cmd_0:
   \   000008 7211 5250    BRES      L:0x5250, #0x0
    501            }
    502          }
   \   00000C 87           RETF
    503          
    504          /**
    505            * @}
    506            */
    507          
    508          /** @defgroup TIM2_Group2 Output Compare management functions
    509           *  @brief    Output Compare management functions 
    510           *
    511          @verbatim   
    512           ===============================================================================
    513                                  Output Compare management functions
    514           ===============================================================================  
    515             
    516                 ===================================================================      
    517                        TIM2 Driver: how to use it in Output Compare Mode
    518                 =================================================================== 
    519                 To use the Timer in Output Compare mode, the following steps are mandatory:
    520                 
    521                 1. Enable TIM2 clock using CLK_PeripheralClockConfig(CLK_Peripheral_TIM2, ENABLE) function.
    522                 
    523                 2. Configure the TIM2 pins in output mode by configuring the corresponding GPIO pins
    524                    
    525                 3. Configure the Time base unit as described in the first part of this driver, if needed,
    526                    otherwise the Timer will run with the default configuration:
    527                    - Autoreload value = 0xFFFF
    528                    - Prescaler value = 0x0000
    529                    - Counter mode = Up counting
    530                
    531                 4. Call TIM2_OCxInit() to configure the channel x with the desired parameters
    532                    including:
    533                    - TIM2 Output Compare mode: TIM2_OCMode
    534                    - TIM2 Output State: TIM2_OutputState
    535                    - TIM2 Pulse value: TIM2_Pulse
    536                    - TIM2 Output Compare Polarity: TIM2_OCPolarity
    537                    - TIM2 Output Idle State: TIM2_OCIdleState
    538                 
    539                 5. Call the TIM2_Cmd(ENABLE) function to enable the TIM2 counter.
    540                 
    541                 Note1: All other functions can be used separately to modify, if needed,
    542                    a specific feature of the Timer. 
    543                 
    544                 Note2: If the corresponding interrupt or DMA request are needed, the user should:
    545                        1. Enable global interrupts (or the DMA) to use the TIM2 interrupts (or DMA requests). 
    546                        2. Enable the corresponding interrupt (or DMA request) using the function 
    547                        TIM2_ITConfig(TIM2_IT_CCx) (or TIM2_DMACmd(TIM2_DMASource_CCx))   
    548          
    549          @endverbatim
    550            * @{
    551            */
    552          
    553          /**
    554            * @brief  Initializes the TIM2 Channel1 according to the specified parameters.
    555            * @param  TIM2_OCMode: Output Compare Mode 
    556            *          This parameter can be one of the following values:
    557            *            @arg TIM2_OCMode_Timing: Timing (Frozen) Mode
    558            *            @arg TIM2_OCMode_Active: Active Mode
    559            *            @arg TIM2_OCMode_Inactive: Inactive Mode
    560            *            @arg TIM2_OCMode_Toggle: Toggle Mode
    561            *            @arg TIM2_OCMode_PWM1: PWM Mode 1
    562            *            @arg TIM2_OCMode_PWM2: PWM Mode 2          
    563            * @param  TIM2_OutputState: Output state
    564            *          This parameter can be one of the following values:
    565            *            @arg TIM2_OutputState_Disable: Output compare State disabled (channel output disabled)
    566            *            @arg TIM2_OutputState_Enable: Output compare State enabled (channel output enabled)
    567            * @param  TIM2_Pulse: This parameter must be a value between 0x0000 and 0xFFFF.
    568            * @param  TIM2_OCPolarity: Polarity
    569            *          This parameter can be one of the following values:
    570            *            @arg TIM2_OCPolarity_High: Output compare polarity  = High
    571            *            @arg TIM2_OCPolarity_Low: Output compare polarity  = Low 
    572            * @param  TIM2_OCIdleState: Output Compare Idle State
    573            *          This parameter can be one of the following values:
    574            *            @arg TIM2_OCIdleState_Reset: Output Compare Idle state  = Reset
    575            *            @arg TIM2_OCIdleState_Set: Output Compare Idle state  = Set
    576            * @retval None
    577            */

   \                                 In section .far_func.text, align 1
    578          void TIM2_OC1Init(TIM2_OCMode_TypeDef TIM2_OCMode,
    579                            TIM2_OutputState_TypeDef TIM2_OutputState,
    580                            uint16_t TIM2_Pulse,
    581                            TIM2_OCPolarity_TypeDef TIM2_OCPolarity,
    582                            TIM2_OCIdleState_TypeDef TIM2_OCIdleState)
    583          {
   \                     TIM2_OC1Init:
   \   000000 B7 ..        LD        S:?b3, A
   \   000002 9093         LDW       Y, X
    584            uint8_t tmpccmr1 = 0;
   \   000004 3F ..        CLR       S:?b4
    585          
    586            /* Check the parameters */
    587            assert_param(IS_TIM2_OC_MODE(TIM2_OCMode));
    588            assert_param(IS_TIM2_OUTPUT_STATE(TIM2_OutputState));
    589            assert_param(IS_TIM2_OC_POLARITY(TIM2_OCPolarity));
    590            assert_param(IS_TIM2_OCIDLE_STATE(TIM2_OCIdleState));
    591          
    592            tmpccmr1 = TIM2->CCMR1;
   \   000006 C6 5259      LD        A, L:0x5259
   \   000009 B7 ..        LD        S:?b4, A
    593          
    594            /* Disable the Channel 1: Reset the CCE Bit */
    595            TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC1E);
   \   00000B 7211 525B    BRES      L:0x525b, #0x0
    596            /* Reset the Output Compare Bits */
    597            tmpccmr1 &= (uint8_t)(~TIM_CCMR_OCM);
   \   00000F B6 ..        LD        A, S:?b4
   \   000011 A4 8F        AND       A, #0x8f
   \   000013 B7 ..        LD        S:?b4, A
    598          
    599            /* Set the Output Compare Mode */
    600            tmpccmr1 |= (uint8_t)TIM2_OCMode;
   \   000015 B6 ..        LD        A, S:?b3
   \   000017 BA ..        OR        A, S:?b4
   \   000019 B7 ..        LD        S:?b4, A
    601          
    602            TIM2->CCMR1 = tmpccmr1;
   \   00001B B6 ..        LD        A, S:?b4
   \   00001D C7 5259      LD        L:0x5259, A
    603          
    604            /* Set the Output State */
    605            if (TIM2_OutputState == TIM2_OutputState_Enable)
   \   000020 B6 ..        LD        A, S:?b0
   \   000022 A1 01        CP        A, #0x1
   \   000024 26 06        JRNE      L:??TIM2_OC1Init_0
    606            {
    607              TIM2->CCER1 |= TIM_CCER1_CC1E;
   \   000026 7210 525B    BSET      L:0x525b, #0x0
   \   00002A 20 04        JRA       L:??TIM2_OC1Init_1
    608            }
    609            else
    610            {
    611              TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC1E);
   \                     ??TIM2_OC1Init_0:
   \   00002C 7211 525B    BRES      L:0x525b, #0x0
    612            }
    613          
    614            /* Set the Output Polarity */
    615            if (TIM2_OCPolarity == TIM2_OCPolarity_Low)
   \                     ??TIM2_OC1Init_1:
   \   000030 B6 ..        LD        A, S:?b1
   \   000032 A1 01        CP        A, #0x1
   \   000034 26 06        JRNE      L:??TIM2_OC1Init_2
    616            {
    617              TIM2->CCER1 |= TIM_CCER1_CC1P;
   \   000036 7212 525B    BSET      L:0x525b, #0x1
   \   00003A 20 04        JRA       L:??TIM2_OC1Init_3
    618            }
    619            else
    620            {
    621              TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC1P);
   \                     ??TIM2_OC1Init_2:
   \   00003C 7213 525B    BRES      L:0x525b, #0x1
    622            }
    623          
    624            /* Set the Output Idle state */
    625            if (TIM2_OCIdleState == TIM2_OCIdleState_Set)
   \                     ??TIM2_OC1Init_3:
   \   000040 B6 ..        LD        A, S:?b2
   \   000042 A1 01        CP        A, #0x1
   \   000044 26 06        JRNE      L:??TIM2_OC1Init_4
    626            {
    627              TIM2->OISR |= TIM_OISR_OIS1;
   \   000046 7210 5266    BSET      L:0x5266, #0x0
   \   00004A 20 04        JRA       L:??TIM2_OC1Init_5
    628            }
    629            else
    630            {
    631              TIM2->OISR &= (uint8_t)(~TIM_OISR_OIS1);
   \                     ??TIM2_OC1Init_4:
   \   00004C 7211 5266    BRES      L:0x5266, #0x0
    632            }
    633          
    634            /* Set the Pulse value */
    635            TIM2->CCR1H = (uint8_t)(TIM2_Pulse >> 8);
   \                     ??TIM2_OC1Init_5:
   \   000050 93           LDW       X, Y
   \   000051 4F           CLR       A
   \   000052 01           RRWA      X, A
   \   000053 9F           LD        A, XL
   \   000054 C7 5261      LD        L:0x5261, A
    636            TIM2->CCR1L = (uint8_t)(TIM2_Pulse);
   \   000057 909F         LD        A, YL
   \   000059 C7 5262      LD        L:0x5262, A
    637          }
   \   00005C 87           RETF
    638          
    639          /**
    640            * @brief  Initializes the TIM2 Channel2 according to the specified parameters.
    641            * @param  TIM2_OCMode: Output Compare Mode 
    642            *          This parameter can be one of the following values:
    643            *            @arg TIM2_OCMode_Timing: Timing (Frozen) Mode
    644            *            @arg TIM2_OCMode_Active: Active Mode
    645            *            @arg TIM2_OCMode_Inactive: Inactive Mode
    646            *            @arg TIM2_OCMode_Toggle: Toggle Mode
    647            *            @arg TIM2_OCMode_PWM1: PWM Mode 1
    648            *            @arg TIM2_OCMode_PWM2: PWM Mode 2          
    649            * @param  TIM2_OutputState: Output state
    650            *          This parameter can be one of the following values:
    651            *            @arg TIM2_OutputState_Disable: Output compare State disabled (channel output disabled)
    652            *            @arg TIM2_OutputState_Enable: Output compare State enabled (channel output enabled)
    653            * @param  TIM2_Pulse: This parameter must be a value between 0x0000 and 0xFFFF.
    654            * @param  TIM2_OCPolarity: Polarity
    655            *          This parameter can be one of the following values:
    656            *            @arg TIM2_OCPolarity_High: Output compare polarity  = High
    657            *            @arg TIM2_OCPolarity_Low: Output compare polarity  = Low 
    658            * @param  TIM2_OCIdleState: Output Compare Idle State
    659            *          This parameter can be one of the following values:
    660            *            @arg TIM2_OCIdleState_Reset: Output Compare Idle state  = Reset
    661            *            @arg TIM2_OCIdleState_Set: Output Compare Idle state  = Set
    662            * @retval None
    663            */

   \                                 In section .far_func.text, align 1
    664          void TIM2_OC2Init(TIM2_OCMode_TypeDef TIM2_OCMode,
    665                            TIM2_OutputState_TypeDef TIM2_OutputState,
    666                            uint16_t TIM2_Pulse,
    667                            TIM2_OCPolarity_TypeDef TIM2_OCPolarity,
    668                            TIM2_OCIdleState_TypeDef TIM2_OCIdleState)
    669          {
   \                     TIM2_OC2Init:
   \   000000 B7 ..        LD        S:?b3, A
   \   000002 9093         LDW       Y, X
    670            uint8_t tmpccmr2 = 0;
   \   000004 3F ..        CLR       S:?b4
    671          
    672            /* Check the parameters */
    673            assert_param(IS_TIM2_OC_MODE(TIM2_OCMode));
    674            assert_param(IS_TIM2_OUTPUT_STATE(TIM2_OutputState));
    675            assert_param(IS_TIM2_OC_POLARITY(TIM2_OCPolarity));
    676            assert_param(IS_TIM2_OCIDLE_STATE(TIM2_OCIdleState));
    677          
    678            tmpccmr2 = TIM2->CCMR2;
   \   000006 C6 525A      LD        A, L:0x525a
   \   000009 B7 ..        LD        S:?b4, A
    679          
    680            /* Disable the Channel 2: Reset the CCE Bit */
    681            TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC2E);
   \   00000B 7219 525B    BRES      L:0x525b, #0x4
    682          
    683            /* Reset the Output Compare Bits */
    684            tmpccmr2 &= (uint8_t)(~TIM_CCMR_OCM);
   \   00000F B6 ..        LD        A, S:?b4
   \   000011 A4 8F        AND       A, #0x8f
   \   000013 B7 ..        LD        S:?b4, A
    685          
    686            /* Set the Output Compare Mode */
    687            tmpccmr2 |= (uint8_t)TIM2_OCMode;
   \   000015 B6 ..        LD        A, S:?b3
   \   000017 BA ..        OR        A, S:?b4
   \   000019 B7 ..        LD        S:?b4, A
    688          
    689            TIM2->CCMR2 = tmpccmr2;
   \   00001B B6 ..        LD        A, S:?b4
   \   00001D C7 525A      LD        L:0x525a, A
    690          
    691            /* Set the Output State */
    692            if (TIM2_OutputState == TIM2_OutputState_Enable)
   \   000020 B6 ..        LD        A, S:?b0
   \   000022 A1 01        CP        A, #0x1
   \   000024 26 06        JRNE      L:??TIM2_OC2Init_0
    693            {
    694              TIM2->CCER1 |= TIM_CCER1_CC2E;
   \   000026 7218 525B    BSET      L:0x525b, #0x4
   \   00002A 20 04        JRA       L:??TIM2_OC2Init_1
    695            }
    696            else
    697            {
    698              TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC2E);
   \                     ??TIM2_OC2Init_0:
   \   00002C 7219 525B    BRES      L:0x525b, #0x4
    699            }
    700          
    701            /* Set the Output Polarity */
    702            if (TIM2_OCPolarity == TIM2_OCPolarity_Low)
   \                     ??TIM2_OC2Init_1:
   \   000030 B6 ..        LD        A, S:?b1
   \   000032 A1 01        CP        A, #0x1
   \   000034 26 06        JRNE      L:??TIM2_OC2Init_2
    703            {
    704              TIM2->CCER1 |= TIM_CCER1_CC2P;
   \   000036 721A 525B    BSET      L:0x525b, #0x5
   \   00003A 20 04        JRA       L:??TIM2_OC2Init_3
    705            }
    706            else
    707            {
    708              TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC2P);
   \                     ??TIM2_OC2Init_2:
   \   00003C 721B 525B    BRES      L:0x525b, #0x5
    709            }
    710          
    711          
    712            /* Set the Output Idle state */
    713            if (TIM2_OCIdleState == TIM2_OCIdleState_Set)
   \                     ??TIM2_OC2Init_3:
   \   000040 B6 ..        LD        A, S:?b2
   \   000042 A1 01        CP        A, #0x1
   \   000044 26 06        JRNE      L:??TIM2_OC2Init_4
    714            {
    715              TIM2->OISR |= TIM_OISR_OIS2;
   \   000046 7214 5266    BSET      L:0x5266, #0x2
   \   00004A 20 04        JRA       L:??TIM2_OC2Init_5
    716            }
    717            else
    718            {
    719              TIM2->OISR &= (uint8_t)(~TIM_OISR_OIS2);
   \                     ??TIM2_OC2Init_4:
   \   00004C 7215 5266    BRES      L:0x5266, #0x2
    720            }
    721          
    722            /* Set the Pulse value */
    723            TIM2->CCR2H = (uint8_t)(TIM2_Pulse >> 8);
   \                     ??TIM2_OC2Init_5:
   \   000050 93           LDW       X, Y
   \   000051 4F           CLR       A
   \   000052 01           RRWA      X, A
   \   000053 9F           LD        A, XL
   \   000054 C7 5263      LD        L:0x5263, A
    724            TIM2->CCR2L = (uint8_t)(TIM2_Pulse);
   \   000057 909F         LD        A, YL
   \   000059 C7 5264      LD        L:0x5264, A
    725          }
   \   00005C 87           RETF
    726          
    727          /**
    728            * @brief  Configures the Break feature, dead time, Lock level, the OSSI,
    729            *         and the AOE(automatic output enable).
    730            * @param  TIM2_OSSIState: Off-State Selection for Idle mode states.
    731            *          This parameter can be one of the following values:
    732            *            @arg TIM2_OSSIState_Enable: Off-State Selection for Idle mode enabled
    733            *            @arg TIM2_OSSIState_Disable: Off-State Selection for Idle mode disabled 
    734            * @param  TIM2_LockLevel: Lock level.
    735            *          This parameter can be one of the following values:
    736            *            @arg TIM2_LockLevel_Off: Lock option disabled
    737            *            @arg TIM2_LockLevel_1: Select Lock Level 1
    738            *            @arg TIM2_LockLevel_2: Select Lock Level 2
    739            *            @arg TIM2_LockLevel_3: Select Lock Level 3    
    740            * @param  TIM2_BreakState: Break Input enable/disable .
    741            *          This parameter can be one of the following values:
    742            *            @arg TIM2_BreakState_Disable: Break State disabled (break option disabled)
    743            *            @arg TIM2_BreakState_Enable: Break State enabled (break option enabled) 
    744            * @param  TIM2_BreakPolarity: Break Polarity.
    745            *          This parameter can be one of the following values:
    746            *            @arg TIM2_BreakPolarity_High: if Break, channel polarity = High
    747            *            @arg TIM2_BreakPolarity_Low: if Break, channel polarity = Low   
    748            * @param  TIM2_AutomaticOutput: TIM2 AOE Bit Set/Reset .
    749            *          This parameter can be one of the following values:
    750            *            @arg TIM2_AutomaticOutput_Enable: Automatic Output option enabled
    751            *            @arg TIM2_AutomaticOutput_Disable: Automatic Output option disabled
    752            * @retval None
    753            */

   \                                 In section .far_func.text, align 1
    754          void TIM2_BKRConfig(TIM2_OSSIState_TypeDef TIM2_OSSIState,
    755                              TIM2_LockLevel_TypeDef TIM2_LockLevel,
    756                              TIM2_BreakState_TypeDef TIM2_BreakState,
    757                              TIM2_BreakPolarity_TypeDef TIM2_BreakPolarity,
    758                              TIM2_AutomaticOutput_TypeDef TIM2_AutomaticOutput)
    759          
    760          {
   \                     TIM2_BKRConfig:
   \   000000 B7 ..        LD        S:?b4, A
   \   000002 B6 ..        LD        A, S:?b2
    761            /* Check the parameters */
    762            assert_param(IS_TIM2_OSSI_STATE(TIM2_OSSIState));
    763            assert_param(IS_TIM2_LOCK_LEVEL(TIM2_LockLevel));
    764            assert_param(IS_TIM2_BREAK_STATE(TIM2_BreakState));
    765            assert_param(IS_TIM2_BREAK_POLARITY(TIM2_BreakPolarity));
    766            assert_param(IS_TIM2_AUTOMATIC_OUTPUT_STATE(TIM2_AutomaticOutput));
    767          
    768          
    769          
    770            /* Set the Lock level, the Break enable Bit and the Polarity, the OSSI State,
    771            the dead time value and the Automatic Output Enable Bit */
    772            TIM2->BKR = (uint8_t)((uint8_t)((uint8_t)((uint8_t)((uint8_t)TIM2_OSSIState | (uint8_t)TIM2_LockLevel) | \
    773                                            (uint8_t)((uint8_t)TIM2_BreakState | (uint8_t)TIM2_BreakPolarity)) | \
    774                                            TIM2_AutomaticOutput));
   \   000004 BA ..        OR        A, S:?b1
   \   000006 88           PUSH      A
   \   000007 B6 ..        LD        A, S:?b0
   \   000009 BA ..        OR        A, S:?b4
   \   00000B B7 ..        LD        S:?b0, A
   \   00000D 84           POP       A
   \   00000E BA ..        OR        A, S:?b0
   \   000010 BA ..        OR        A, S:?b3
   \   000012 C7 5265      LD        L:0x5265, A
    775          }
   \   000015 87           RETF
    776          
    777          /**
    778            * @brief  Enables or disables the TIM2 peripheral Main Outputs.
    779            * @param  NewState: The new state of the TIM2 peripheral.
    780            *          This parameter can be ENABLE or DISABLE
    781            * @retval None
    782            */

   \                                 In section .far_func.text, align 1
    783          void TIM2_CtrlPWMOutputs(FunctionalState NewState)
    784          {
    785            /* Check the parameters */
    786            assert_param(IS_FUNCTIONAL_STATE(NewState));
    787          
    788            /* Set or Reset the MOE Bit */
    789          
    790            if (NewState != DISABLE)
   \                     TIM2_CtrlPWMOutputs:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM2_CtrlPWMOutputs_0
    791            {
    792              TIM2->BKR |= TIM_BKR_MOE ;
   \   000003 721E 5265    BSET      L:0x5265, #0x7
   \   000007 87           RETF
    793            }
    794            else
    795            {
    796              TIM2->BKR &= (uint8_t)(~TIM_BKR_MOE) ;
   \                     ??TIM2_CtrlPWMOutputs_0:
   \   000008 721F 5265    BRES      L:0x5265, #0x7
    797            }
    798          }
   \   00000C 87           RETF
    799          
    800          /**
    801            * @brief  Selects the TIM2 Output Compare Mode. This function disables the
    802            *         selected channel before changing the Output Compare Mode. User has to
    803            *         enable this channel using TIM2_CCxCmd and TIM2_CCxNCmd functions.
    804            * @param  TIM2_Channel: Specifies the TIM2 Channel.
    805            *          This parameter can be one of the following values:
    806            *            @arg TIM2_Channel_1: Channel 1
    807            *            @arg TIM2_Channel_2: Channel 2  
    808            * @param  TIM2_OCMode: Specifies the TIM2 Output Compare Mode.
    809            *          This parameter can be one of the following values:
    810            *            @arg TIM2_OCMode_Timing: Timing (Frozen) Mode
    811            *            @arg TIM2_OCMode_Active: Active Mode
    812            *            @arg TIM2_OCMode_Inactive: Inactive Mode
    813            *            @arg TIM2_OCMode_Toggle: Toggle Mode
    814            *            @arg TIM2_OCMode_PWM1: PWM Mode 1
    815            *            @arg TIM2_OCMode_PWM2: PWM Mode 2    
    816            * @retval None
    817            */

   \                                 In section .far_func.text, align 1
    818          void TIM2_SelectOCxM(TIM2_Channel_TypeDef TIM2_Channel,
    819                               TIM2_OCMode_TypeDef TIM2_OCMode)
    820          {
    821            /* Check the parameters */
    822            assert_param(IS_TIM2_CHANNEL(TIM2_Channel));
    823            assert_param(IS_TIM2_OCM(TIM2_OCMode));
    824          
    825            if (TIM2_Channel == TIM2_Channel_1)
   \                     TIM2_SelectOCxM:
   \   000000 4D           TNZ       A
   \   000001 26 15        JRNE      L:??TIM2_SelectOCxM_0
    826            {
    827              /* Disable the Channel 1: Reset the CCE Bit */
    828              TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC1E);
   \   000003 7211 525B    BRES      L:0x525b, #0x0
    829          
    830              /* Reset the Output Compare Bits */
    831              TIM2->CCMR1 &= (uint8_t)(~TIM_CCMR_OCM);
   \   000007 C6 5259      LD        A, L:0x5259
   \   00000A A4 8F        AND       A, #0x8f
   \   00000C C7 5259      LD        L:0x5259, A
    832          
    833              /* Set the Output Compare Mode */
    834              TIM2->CCMR1 |= (uint8_t)TIM2_OCMode;
   \   00000F B6 ..        LD        A, S:?b0
   \   000011 CA 5259      OR        A, L:0x5259
   \   000014 C7 5259      LD        L:0x5259, A
   \   000017 87           RETF
    835            }
    836            else /* if (TIM2_Channel == TIM2_Channel_2) */
    837            {
    838              /* Disable the Channel 2: Reset the CCE Bit */
    839              TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC2E);
   \                     ??TIM2_SelectOCxM_0:
   \   000018 7219 525B    BRES      L:0x525b, #0x4
    840          
    841              /* Reset the Output Compare Bits */
    842              TIM2->CCMR2 &= (uint8_t)(~TIM_CCMR_OCM);
   \   00001C C6 525A      LD        A, L:0x525a
   \   00001F A4 8F        AND       A, #0x8f
   \   000021 C7 525A      LD        L:0x525a, A
    843          
    844              /* Set the Output Compare Mode */
    845              TIM2->CCMR2 |= (uint8_t)TIM2_OCMode;
   \   000024 B6 ..        LD        A, S:?b0
   \   000026 CA 525A      OR        A, L:0x525a
   \   000029 C7 525A      LD        L:0x525a, A
    846            }
    847          }
   \   00002C 87           RETF
    848          
    849          /**
    850            * @brief  Sets the TIM2 Capture Compare1 Register value.
    851            * @param  Compare: Specifies the Capture Compare1 register new value.
    852            *         This parameter is between 0x0000 and 0xFFFF.
    853            * @retval None
    854            */

   \                                 In section .far_func.text, align 1
    855          void TIM2_SetCompare1(uint16_t Compare)
    856          {
   \                     TIM2_SetCompare1:
   \   000000 9093         LDW       Y, X
    857            /* Set the Capture Compare1 Register value */
    858            TIM2->CCR1H = (uint8_t)(Compare >> 8);
   \   000002 93           LDW       X, Y
   \   000003 4F           CLR       A
   \   000004 01           RRWA      X, A
   \   000005 9F           LD        A, XL
   \   000006 C7 5261      LD        L:0x5261, A
    859            TIM2->CCR1L = (uint8_t)(Compare);
   \   000009 909F         LD        A, YL
   \   00000B C7 5262      LD        L:0x5262, A
    860          }
   \   00000E 87           RETF
    861          
    862          /**
    863            * @brief  Sets the TIM2 Capture Compare2 Register value.
    864            * @param  Compare: Specifies the Capture Compare2 register new value.
    865            *         This parameter is between 0x0000 and 0xFFFF.
    866            * @retval None
    867            */

   \                                 In section .far_func.text, align 1
    868          void TIM2_SetCompare2(uint16_t Compare)
    869          {
   \                     TIM2_SetCompare2:
   \   000000 9093         LDW       Y, X
    870            /* Set the Capture Compare2 Register value */
    871            TIM2->CCR2H = (uint8_t)(Compare >> 8);
   \   000002 93           LDW       X, Y
   \   000003 4F           CLR       A
   \   000004 01           RRWA      X, A
   \   000005 9F           LD        A, XL
   \   000006 C7 5263      LD        L:0x5263, A
    872            TIM2->CCR2L = (uint8_t)(Compare);
   \   000009 909F         LD        A, YL
   \   00000B C7 5264      LD        L:0x5264, A
    873          }
   \   00000E 87           RETF
    874          
    875          /**
    876            * @brief  Forces the TIM2 Channel1 output waveform to active or inactive level.
    877            * @param  TIM2_ForcedAction: Specifies the forced Action to be set to the output waveform.
    878            *          This parameter can be one of the following values:
    879            *            @arg TIM2_ForcedAction_Active: Output Reference is forced low 
    880            *            @arg TIM2_ForcedAction_Inactive: Output Reference is forced high 
    881            * @retval None
    882            */

   \                                 In section .far_func.text, align 1
    883          void TIM2_ForcedOC1Config(TIM2_ForcedAction_TypeDef TIM2_ForcedAction)
    884          {
   \                     TIM2_ForcedOC1Config:
   \   000000 B7 ..        LD        S:?b0, A
    885            uint8_t tmpccmr1 = 0;
   \   000002 3F ..        CLR       S:?b1
    886          
    887            /* Check the parameters */
    888            assert_param(IS_TIM2_FORCED_ACTION(TIM2_ForcedAction));
    889          
    890            tmpccmr1 = TIM2->CCMR1;
   \   000004 C6 5259      LD        A, L:0x5259
   \   000007 B7 ..        LD        S:?b1, A
    891          
    892            /* Reset the OCM Bits */
    893            tmpccmr1 &= (uint8_t)(~TIM_CCMR_OCM);
   \   000009 B6 ..        LD        A, S:?b1
   \   00000B A4 8F        AND       A, #0x8f
   \   00000D B7 ..        LD        S:?b1, A
    894          
    895            /* Configure The Forced output Mode */
    896            tmpccmr1 |= (uint8_t)TIM2_ForcedAction;
   \   00000F B6 ..        LD        A, S:?b0
   \   000011 BA ..        OR        A, S:?b1
   \   000013 B7 ..        LD        S:?b1, A
    897          
    898            TIM2->CCMR1 = tmpccmr1;
   \   000015 B6 ..        LD        A, S:?b1
   \   000017 C7 5259      LD        L:0x5259, A
    899          }
   \   00001A 87           RETF
    900          
    901          /**
    902            * @brief  Forces the TIM2 Channel2 output waveform to active or inactive level.
    903            * @param  TIM2_ForcedAction: Specifies the forced Action to be set to the output waveform.
    904            *          This parameter can be one of the following values:
    905            *            @arg TIM2_ForcedAction_Active: Output Reference is forced low 
    906            *            @arg TIM2_ForcedAction_Inactive: Output Reference is forced high 
    907            * @retval None
    908            */

   \                                 In section .far_func.text, align 1
    909          void TIM2_ForcedOC2Config(TIM2_ForcedAction_TypeDef TIM2_ForcedAction)
    910          {
   \                     TIM2_ForcedOC2Config:
   \   000000 B7 ..        LD        S:?b0, A
    911            uint8_t tmpccmr2 = 0;
   \   000002 3F ..        CLR       S:?b1
    912          
    913            /* Check the parameters */
    914            assert_param(IS_TIM2_FORCED_ACTION(TIM2_ForcedAction));
    915          
    916            tmpccmr2 = TIM2->CCMR2;
   \   000004 C6 525A      LD        A, L:0x525a
   \   000007 B7 ..        LD        S:?b1, A
    917          
    918            /* Reset the OCM Bits */
    919            tmpccmr2 &= (uint8_t)(~TIM_CCMR_OCM);
   \   000009 B6 ..        LD        A, S:?b1
   \   00000B A4 8F        AND       A, #0x8f
   \   00000D B7 ..        LD        S:?b1, A
    920          
    921            /* Configure The Forced output Mode */
    922            tmpccmr2 |= (uint8_t)TIM2_ForcedAction;
   \   00000F B6 ..        LD        A, S:?b0
   \   000011 BA ..        OR        A, S:?b1
   \   000013 B7 ..        LD        S:?b1, A
    923          
    924            TIM2->CCMR2 = tmpccmr2;
   \   000015 B6 ..        LD        A, S:?b1
   \   000017 C7 525A      LD        L:0x525a, A
    925          }
   \   00001A 87           RETF
    926          
    927          /**
    928            * @brief  Enables or disables the TIM2 peripheral Preload Register on CCR1.
    929            * @param  NewState: The new state of the Capture Compare Preload register.
    930            *          This parameter can be ENABLE or DISABLE
    931            * @retval None
    932            */

   \                                 In section .far_func.text, align 1
    933          void TIM2_OC1PreloadConfig(FunctionalState NewState)
    934          {
    935            /* Check the parameters */
    936            assert_param(IS_FUNCTIONAL_STATE(NewState));
    937          
    938            /* Set or Reset the OC1PE Bit */
    939            if (NewState != DISABLE)
   \                     TIM2_OC1PreloadConfig:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM2_OC1PreloadConfig_0
    940            {
    941              TIM2->CCMR1 |= TIM_CCMR_OCxPE ;
   \   000003 7216 5259    BSET      L:0x5259, #0x3
   \   000007 87           RETF
    942            }
    943            else
    944            {
    945              TIM2->CCMR1 &= (uint8_t)(~TIM_CCMR_OCxPE) ;
   \                     ??TIM2_OC1PreloadConfig_0:
   \   000008 7217 5259    BRES      L:0x5259, #0x3
    946            }
    947          }
   \   00000C 87           RETF
    948          
    949          /**
    950            * @brief  Enables or disables the TIM2 peripheral Preload Register on CCR2.
    951            * @param  NewState: The new state of the Capture Compare Preload register.
    952            *          This parameter can be ENABLE or DISABLE
    953            * @retval None
    954            */

   \                                 In section .far_func.text, align 1
    955          void TIM2_OC2PreloadConfig(FunctionalState NewState)
    956          {
    957            /* Check the parameters */
    958            assert_param(IS_FUNCTIONAL_STATE(NewState));
    959          
    960            /* Set or Reset the OC2PE Bit */
    961            if (NewState != DISABLE)
   \                     TIM2_OC2PreloadConfig:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM2_OC2PreloadConfig_0
    962            {
    963              TIM2->CCMR2 |= TIM_CCMR_OCxPE ;
   \   000003 7216 525A    BSET      L:0x525a, #0x3
   \   000007 87           RETF
    964            }
    965            else
    966            {
    967              TIM2->CCMR2 &= (uint8_t)(~TIM_CCMR_OCxPE) ;
   \                     ??TIM2_OC2PreloadConfig_0:
   \   000008 7217 525A    BRES      L:0x525a, #0x3
    968            }
    969          }
   \   00000C 87           RETF
    970          
    971          /**
    972            * @brief  Configures the TIM2 Capture Compare 1 Fast feature.
    973            * @param  NewState: The new state of the Output Compare Fast Enable bit.
    974            *          This parameter can be ENABLE or DISABLE
    975            * @retval None
    976            */

   \                                 In section .far_func.text, align 1
    977          void TIM2_OC1FastConfig(FunctionalState NewState)
    978          {
    979            /* Check the parameters */
    980            assert_param(IS_FUNCTIONAL_STATE(NewState));
    981          
    982            /* Set or Reset the OC1FE Bit */
    983            if (NewState != DISABLE)
   \                     TIM2_OC1FastConfig:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM2_OC1FastConfig_0
    984            {
    985              TIM2->CCMR1 |= TIM_CCMR_OCxFE ;
   \   000003 7214 5259    BSET      L:0x5259, #0x2
   \   000007 87           RETF
    986            }
    987            else
    988            {
    989              TIM2->CCMR1 &= (uint8_t)(~TIM_CCMR_OCxFE) ;
   \                     ??TIM2_OC1FastConfig_0:
   \   000008 7215 5259    BRES      L:0x5259, #0x2
    990            }
    991          }
   \   00000C 87           RETF
    992          
    993          /**
    994            * @brief  Configures the TIM2 Capture Compare 2 Fast feature.
    995            * @param  NewState: The new state of the Output Compare Fast Enable bit.
    996            *          This parameter can be ENABLE or DISABLE
    997            * @retval None
    998            */
    999          

   \                                 In section .far_func.text, align 1
   1000          void TIM2_OC2FastConfig(FunctionalState NewState)
   1001          {
   1002            /* Check the parameters */
   1003            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1004          
   1005            /* Set or Reset the OC2FE Bit */
   1006            if (NewState != DISABLE)
   \                     TIM2_OC2FastConfig:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM2_OC2FastConfig_0
   1007            {
   1008              TIM2->CCMR2 |= TIM_CCMR_OCxFE ;
   \   000003 7214 525A    BSET      L:0x525a, #0x2
   \   000007 87           RETF
   1009            }
   1010            else
   1011            {
   1012              TIM2->CCMR2 &= (uint8_t)(~TIM_CCMR_OCxFE) ;
   \                     ??TIM2_OC2FastConfig_0:
   \   000008 7215 525A    BRES      L:0x525a, #0x2
   1013            }
   1014          }
   \   00000C 87           RETF
   1015          
   1016          /**
   1017            * @brief  Configures the TIM2 Channel 1 polarity.
   1018            * @param  TIM2_OCPolarity: Specifies the OC1 Polarity.
   1019            *          This parameter can be one of the following values:
   1020            *            @arg TIM2_OCPolarity_High: Output compare polarity  = High
   1021            *            @arg TIM2_OCPolarity_Low: Output compare polarity  = Low 
   1022            * @retval None
   1023            */

   \                                 In section .far_func.text, align 1
   1024          void TIM2_OC1PolarityConfig(TIM2_OCPolarity_TypeDef TIM2_OCPolarity)
   1025          {
   1026            /* Check the parameters */
   1027            assert_param(IS_TIM2_OC_POLARITY(TIM2_OCPolarity));
   1028          
   1029            /* Set or Reset the CC1P Bit */
   1030            if (TIM2_OCPolarity == TIM2_OCPolarity_Low)
   \                     TIM2_OC1PolarityConfig:
   \   000000 A1 01        CP        A, #0x1
   \   000002 26 05        JRNE      L:??TIM2_OC1PolarityConfig_0
   1031            {
   1032              TIM2->CCER1 |= TIM_CCER1_CC1P ;
   \   000004 7212 525B    BSET      L:0x525b, #0x1
   \   000008 87           RETF
   1033            }
   1034            else
   1035            {
   1036              TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC1P) ;
   \                     ??TIM2_OC1PolarityConfig_0:
   \   000009 7213 525B    BRES      L:0x525b, #0x1
   1037            }
   1038          }
   \   00000D 87           RETF
   1039          
   1040          /**
   1041            * @brief  Configures the TIM2 Channel 2 polarity.
   1042            * @param  TIM2_OCPolarity: Specifies the OC2 Polarity.
   1043            *          This parameter can be one of the following values:
   1044            *            @arg TIM2_OCPolarity_High: Output compare polarity  = High
   1045            *            @arg TIM2_OCPolarity_Low: Output compare polarity  = Low 
   1046            * @retval None
   1047            */

   \                                 In section .far_func.text, align 1
   1048          void TIM2_OC2PolarityConfig(TIM2_OCPolarity_TypeDef TIM2_OCPolarity)
   1049          {
   1050            /* Check the parameters */
   1051            assert_param(IS_TIM2_OC_POLARITY(TIM2_OCPolarity));
   1052          
   1053            /* Set or Reset the CC2P Bit */
   1054            if (TIM2_OCPolarity == TIM2_OCPolarity_Low)
   \                     TIM2_OC2PolarityConfig:
   \   000000 A1 01        CP        A, #0x1
   \   000002 26 05        JRNE      L:??TIM2_OC2PolarityConfig_0
   1055            {
   1056              TIM2->CCER1 |= TIM_CCER1_CC2P ;
   \   000004 721A 525B    BSET      L:0x525b, #0x5
   \   000008 87           RETF
   1057            }
   1058            else
   1059            {
   1060              TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC2P) ;
   \                     ??TIM2_OC2PolarityConfig_0:
   \   000009 721B 525B    BRES      L:0x525b, #0x5
   1061            }
   1062          }
   \   00000D 87           RETF
   1063          
   1064          /**
   1065            * @brief  Enables or disables the TIM2 Capture Compare Channel x.
   1066            * @param  TIM2_Channel: Specifies the TIM2 Channel.
   1067            *          This parameter can be one of the following values:
   1068            *            @arg TIM2_Channel_1: Channel 1
   1069            *            @arg TIM2_Channel_2: Channel 2  
   1070            * @param  NewState: Specifies the TIM2 Channel CCxE bit new state.
   1071            *          This parameter can be ENABLE or DISABLE
   1072            * @retval None
   1073            */

   \                                 In section .far_func.text, align 1
   1074          void TIM2_CCxCmd(TIM2_Channel_TypeDef TIM2_Channel,
   1075                           FunctionalState NewState)
   1076          {
   1077            /* Check the parameters */
   1078            assert_param(IS_TIM2_CHANNEL(TIM2_Channel));
   1079            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1080          
   1081            if (TIM2_Channel == TIM2_Channel_1)
   \                     TIM2_CCxCmd:
   \   000000 4D           TNZ       A
   \   000001 26 0E        JRNE      L:??TIM2_CCxCmd_0
   1082            {
   1083              /* Set or Reset the CC1E Bit */
   1084              if (NewState != DISABLE)
   \   000003 3D ..        TNZ       S:?b0
   \   000005 27 05        JREQ      L:??TIM2_CCxCmd_1
   1085              {
   1086                TIM2->CCER1 |= TIM_CCER1_CC1E ;
   \   000007 7210 525B    BSET      L:0x525b, #0x0
   \   00000B 87           RETF
   1087              }
   1088              else
   1089              {
   1090                TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC1E) ;
   \                     ??TIM2_CCxCmd_1:
   \   00000C 7211 525B    BRES      L:0x525b, #0x0
   \   000010 87           RETF
   1091              }
   1092          
   1093            }
   1094            else /* if (TIM2_Channel == TIM2_Channel_2) */
   1095            {
   1096              /* Set or Reset the CC2E Bit */
   1097              if (NewState != DISABLE)
   \                     ??TIM2_CCxCmd_0:
   \   000011 3D ..        TNZ       S:?b0
   \   000013 27 05        JREQ      L:??TIM2_CCxCmd_2
   1098              {
   1099                TIM2->CCER1 |= TIM_CCER1_CC2E;
   \   000015 7218 525B    BSET      L:0x525b, #0x4
   \   000019 87           RETF
   1100              }
   1101              else
   1102              {
   1103                TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC2E) ;
   \                     ??TIM2_CCxCmd_2:
   \   00001A 7219 525B    BRES      L:0x525b, #0x4
   1104              }
   1105            }
   1106          }
   \   00001E 87           RETF
   1107          
   1108          /** @defgroup TIM2_Group3 Input Capture management functions
   1109           *  @brief    Input Capture management functions 
   1110           *
   1111          @verbatim   
   1112           ===============================================================================
   1113                                Input Capture management functions
   1114           ===============================================================================  
   1115             
   1116                 ===================================================================      
   1117                        TIM2 Driver: how to use it in Input Capture Mode
   1118                 =================================================================== 
   1119                 To use the Timer in Input Capture mode, the following steps are mandatory:
   1120                 
   1121                 1. Enable TIM2 clock using CLK_PeripheralClockConfig(CLK_Peripheral_TIM2, ENABLE) function.
   1122                 
   1123                 2. Configure the TIM2 pins in input mode by configuring the corresponding GPIO pins
   1124                 
   1125                 3. Configure the Time base unit as described in the first part of this driver, if needed,
   1126                    otherwise the Timer will run with the default configuration:
   1127                    - Autoreload value = 0xFFFF
   1128                    - Prescaler value = 0x0
   1129                    - Counter mode = Up counting
   1130                 
   1131                 4. Call TIM2_ICInit() to configure the desired channel to measure only 
   1132                    frequency or duty cycle of the input signal using the corresponding configuration: 
   1133                    - TIM2 Channel: TIM2_Channel
   1134                    - TIM2 Input Capture polarity: TIM2_ICPolarity
   1135                    - TIM2 Input Capture selection: TIM2_ICSelection
   1136                    - TIM2 Input Capture Prescaler: TIM2_ICPSC
   1137                    - TIM2 Input Capture filter value
   1138                    or,
   1139                    Call TIM2_PWMIConfig() to configure the desired channels with the 
   1140                    corresponding configuration and to measure the frequency and the duty
   1141                    cycle of the input signal.
   1142                    
   1143                 5. Enable global interrupts or the DMA to read the measured frequency. 
   1144                    
   1145                 6. Enable the corresponding interrupt (or DMA request) to read the captured value,
   1146                    using the function TIM2_ITConfig(TIM2_IT_CCx) (or TIM2_DMACmd(TIM2_DMASource_CCx))
   1147                 
   1148                 7. Call the TIM2_Cmd(ENABLE) function to enable the TIM2 counter.
   1149                 
   1150                 8. Use TIM2_GetCapturex() to read the captured value corresponding to
   1151                    channel x.
   1152                 
   1153                 Note1: All other functions can be used separately to modify, if needed,
   1154                    a specific feature of the Timer. 
   1155          
   1156          @endverbatim
   1157            * @{
   1158            */
   1159          
   1160          /**
   1161            * @brief  Initializes the TIM2 peripheral according to the specified parameters.
   1162            * @param  TIM2_Channel: TIM2 Channel
   1163            *          This parameter can be one of the following values:
   1164            *            @arg TIM2_Channel_1: Channel 1
   1165            *            @arg TIM2_Channel_2: Channel 2     
   1166            * @param  TIM2_ICPolarity: Input Capture Polarity
   1167            *          This parameter can be one of the following values:
   1168            *            @arg TIM2_ICPolarity_Rising: Input Capture on Rising Edge
   1169            *            @arg TIM2_ICPolarity_Falling: Input Capture on Falling Edge  
   1170            * @param  TIM2_ICSelection: Input Capture Selection
   1171            *          This parameter can be one of the following values:
   1172            *            @arg TIM2_ICSelection_DirectTI: Input Capture mapped on the direct input
   1173            *            @arg TIM2_ICSelection_IndirectTI: Input Capture mapped on the indirect input
   1174            *            @arg TIM2_ICSelection_TRGI: Input Capture mapped on the Trigger Input   
   1175            * @param  TIM2_ICPrescaler: Input Capture Prescaler
   1176            *          This parameter can be one of the following values:
   1177            *            @arg TIM2_ICPSC_DIV1: Input Capture Prescaler = 1 (one capture every 1 event)
   1178            *            @arg TIM2_ICPSC_DIV2: Input Capture Prescaler = 2 (one capture every 2 events)
   1179            *            @arg TIM2_ICPSC_DIV4: Input Capture Prescaler = 4 (one capture every 4 events)
   1180            *            @arg TIM2_ICPSC_DIV8: Input Capture Prescaler = 8 (one capture every 8 events)   
   1181            * @param  TIM2_ICFilter: This parameter must be a value between 0x00 and 0x0F.
   1182            * @retval None
   1183            */

   \                                 In section .far_func.text, align 1
   1184          void TIM2_ICInit(TIM2_Channel_TypeDef TIM2_Channel,
   1185                           TIM2_ICPolarity_TypeDef TIM2_ICPolarity,
   1186                           TIM2_ICSelection_TypeDef TIM2_ICSelection,
   1187                           TIM2_ICPSC_TypeDef TIM2_ICPrescaler,
   1188                           uint8_t TIM2_ICFilter)
   1189          {
   \                     TIM2_ICInit:
   \   000000 45 .. ..     MOV       S:?b4, S:?b0
   \   000003 45 .. ..     MOV       S:?b0, S:?b1
   \   000006 45 .. ..     MOV       S:?b5, S:?b2
   \   000009 45 .. ..     MOV       S:?b1, S:?b3
   1190            /* Check the parameters */
   1191            assert_param(IS_TIM2_CHANNEL(TIM2_Channel));
   1192          
   1193            if (TIM2_Channel == TIM2_Channel_1)
   \   00000C 4D           TNZ       A
   \   00000D 26 0C        JRNE      L:??TIM2_ICInit_0
   1194            {
   1195              /* TI1 Configuration */
   1196              TI1_Config(TIM2_ICPolarity, TIM2_ICSelection, TIM2_ICFilter);
   \   00000F B6 ..        LD        A, S:?b4
   \   000011 8D ......    CALLF     TI1_Config
   1197          
   1198              /* Set the Input Capture Prescaler value */
   1199              TIM2_SetIC1Prescaler(TIM2_ICPrescaler);
   \   000015 B6 ..        LD        A, S:?b5
   \   000017 AC ......    JPF       TIM2_SetIC1Prescaler
   1200            }
   1201            else /* if (TIM2_Channel == TIM2_Channel_2) */
   1202            {
   1203              /* TI2 Configuration */
   1204              TI2_Config(TIM2_ICPolarity, TIM2_ICSelection, TIM2_ICFilter);
   \                     ??TIM2_ICInit_0:
   \   00001B B6 ..        LD        A, S:?b4
   \   00001D 8D ......    CALLF     TI2_Config
   1205          
   1206              /* Set the Input Capture Prescaler value */
   1207              TIM2_SetIC2Prescaler(TIM2_ICPrescaler);
   \   000021 B6 ..        LD        A, S:?b5
   \   000023 AC ......    JPF       TIM2_SetIC2Prescaler
   1208            }
   1209          }
   1210          
   1211          /**
   1212            * @brief  Configures the TIM2 peripheral in PWM Input Mode according to the
   1213            *         specified parameters.
   1214            * @param  TIM2_Channel: TIM2 Channel
   1215            *          This parameter can be one of the following values:
   1216            *            @arg TIM2_Channel_1: Channel 1
   1217            *            @arg TIM2_Channel_2: Channel 2     
   1218            * @param  TIM2_ICPolarity: Input Capture Polarity
   1219            *          This parameter can be one of the following values:
   1220            *            @arg TIM2_ICPolarity_Rising: Input Capture on Rising Edge
   1221            *            @arg TIM2_ICPolarity_Falling: Input Capture on Falling Edge  
   1222            * @param  TIM2_ICSelection: Input Capture Selection
   1223            *          This parameter can be one of the following values:
   1224            *            @arg TIM2_ICSelection_DirectTI: Input Capture mapped on the direct input
   1225            *            @arg TIM2_ICSelection_IndirectTI: Input Capture mapped on the indirect input
   1226            *            @arg TIM2_ICSelection_TRGI: Input Capture mapped on the Trigger Input   
   1227            * @param  TIM2_ICPrescaler: Input Capture Prescaler
   1228            *          This parameter can be one of the following values:
   1229            *            @arg TIM2_ICPSC_DIV1: Input Capture Prescaler = 1 (one capture every 1 event)
   1230            *            @arg TIM2_ICPSC_DIV2: Input Capture Prescaler = 2 (one capture every 2 events)
   1231            *            @arg TIM2_ICPSC_DIV4: Input Capture Prescaler = 4 (one capture every 4 events)
   1232            *            @arg TIM2_ICPSC_DIV8: Input Capture Prescaler = 8 (one capture every 8 events) 
   1233            * @retval None
   1234            */

   \                                 In section .far_func.text, align 1, keep-with-next
   1235          void TIM2_PWMIConfig(TIM2_Channel_TypeDef TIM2_Channel,
   1236                               TIM2_ICPolarity_TypeDef TIM2_ICPolarity,
   1237                               TIM2_ICSelection_TypeDef TIM2_ICSelection,
   1238                               TIM2_ICPSC_TypeDef TIM2_ICPrescaler,
   1239                               uint8_t TIM2_ICFilter)
   1240          {
   \                     TIM2_PWMIConfig:
   \   000000 8D ......    CALLF     L:?push_w4
   \   000004 B7 ..        LD        S:?b6, A
   \   000006 45 .. ..     MOV       S:?b7, S:?b0
   \   000009 B6 ..        LD        A, S:?b1
   \   00000B 45 .. ..     MOV       S:?b8, S:?b2
   \   00000E 45 .. ..     MOV       S:?b9, S:?b3
   1241            uint8_t icpolarity = TIM2_ICPolarity_Rising;
   \   000011 3F ..        CLR       S:?b5
   1242            uint8_t icselection = TIM2_ICSelection_DirectTI;
   \   000013 35 01 ....   MOV       S:?b4, #0x1
   1243          
   1244            /* Check the parameters */
   1245            assert_param(IS_TIM2_CHANNEL(TIM2_Channel));
   1246          
   1247            /* Select the Opposite Input Polarity */
   1248            if (TIM2_ICPolarity == TIM2_ICPolarity_Rising)
   \   000017 3D ..        TNZ       S:?b7
   \   000019 26 06        JRNE      L:??TIM2_PWMIConfig_0
   1249            {
   1250              icpolarity = TIM2_ICPolarity_Falling;
   \   00001B 35 01 ....   MOV       S:?b5, #0x1
   \   00001F 20 02        JRA       L:??TIM2_PWMIConfig_1
   1251            }
   1252            else
   1253            {
   1254              icpolarity = TIM2_ICPolarity_Rising;
   \                     ??TIM2_PWMIConfig_0:
   \   000021 3F ..        CLR       S:?b5
   1255            }
   1256          
   1257            /* Select the Opposite Input */
   1258            if (TIM2_ICSelection == TIM2_ICSelection_DirectTI)
   \                     ??TIM2_PWMIConfig_1:
   \   000023 A1 01        CP        A, #0x1
   \   000025 26 06        JRNE      L:??TIM2_PWMIConfig_2
   1259            {
   1260              icselection = TIM2_ICSelection_IndirectTI;
   \   000027 35 02 ....   MOV       S:?b4, #0x2
   \   00002B 20 04        JRA       L:??TIM2_PWMIConfig_3
   1261            }
   1262            else
   1263            {
   1264              icselection = TIM2_ICSelection_DirectTI;
   \                     ??TIM2_PWMIConfig_2:
   \   00002D 35 01 ....   MOV       S:?b4, #0x1
   1265            }
   1266          
   1267            if (TIM2_Channel == TIM2_Channel_1)
   \                     ??TIM2_PWMIConfig_3:
   \   000031 3D ..        TNZ       S:?b6
   \   000033 26 27        JRNE      L:??TIM2_PWMIConfig_4
   1268            {
   1269              /* TI1 Configuration */
   1270              TI1_Config(TIM2_ICPolarity, TIM2_ICSelection,
   1271                         TIM2_ICFilter);
   \   000035 45 .. ..     MOV       S:?b1, S:?b9
   \   000038 B7 ..        LD        S:?b0, A
   \   00003A B6 ..        LD        A, S:?b7
   \   00003C 8D ......    CALLF     TI1_Config
   1272          
   1273              /* Set the Input Capture Prescaler value */
   1274              TIM2_SetIC1Prescaler(TIM2_ICPrescaler);
   \   000040 B6 ..        LD        A, S:?b8
   \   000042 8D ......    CALLF     TIM2_SetIC1Prescaler
   1275          
   1276              /* TI2 Configuration */
   1277              TI2_Config((TIM2_ICPolarity_TypeDef)icpolarity, (TIM2_ICSelection_TypeDef)icselection, TIM2_ICFilter);
   \   000046 45 .. ..     MOV       S:?b1, S:?b9
   \   000049 45 .. ..     MOV       S:?b0, S:?b4
   \   00004C B6 ..        LD        A, S:?b5
   \   00004E 8D ......    CALLF     TI2_Config
   1278          
   1279              /* Set the Input Capture Prescaler value */
   1280              TIM2_SetIC2Prescaler(TIM2_ICPrescaler);
   \   000052 B6 ..        LD        A, S:?b8
   \   000054 8D ......    CALLF     TIM2_SetIC2Prescaler
   \   000058 AC ......    JPF       L:?epilogue_w4
   1281            }
   1282            else
   1283            {
   1284              /* TI2 Configuration */
   1285              TI2_Config(TIM2_ICPolarity, TIM2_ICSelection,
   1286                         TIM2_ICFilter);
   \                     ??TIM2_PWMIConfig_4:
   \   00005C 45 .. ..     MOV       S:?b1, S:?b9
   \   00005F B7 ..        LD        S:?b0, A
   \   000061 B6 ..        LD        A, S:?b7
   \   000063 8D ......    CALLF     TI2_Config
   1287          
   1288              /* Set the Input Capture Prescaler value */
   1289              TIM2_SetIC2Prescaler(TIM2_ICPrescaler);
   \   000067 B6 ..        LD        A, S:?b8
   \   000069 8D ......    CALLF     TIM2_SetIC2Prescaler
   1290          
   1291              /* TI1 Configuration */
   1292              TI1_Config((TIM2_ICPolarity_TypeDef)icpolarity, (TIM2_ICSelection_TypeDef)icselection, TIM2_ICFilter);
   \   00006D 45 .. ..     MOV       S:?b1, S:?b9
   \   000070 45 .. ..     MOV       S:?b0, S:?b4
   \   000073 B6 ..        LD        A, S:?b5
   \   000075 8D ......    CALLF     TI1_Config
   1293          
   1294              /* Set the Input Capture Prescaler value */
   1295              TIM2_SetIC1Prescaler(TIM2_ICPrescaler);
   \   000079 B6 ..        LD        A, S:?b8
   \   00007B 8D ......    CALLF     TIM2_SetIC1Prescaler
   1296            }
   1297          }
   \   00007F AC ......    JPF       L:?epilogue_w4
   1298          
   1299          /**
   1300            * @brief  Gets the TIM2 Input Capture 1 value.
   1301            * @param  None
   1302            * @retval Capture Compare 1 Register value.
   1303            */

   \                                 In section .far_func.text, align 1, keep-with-next
   1304          uint16_t TIM2_GetCapture1(void)
   1305          {
   1306            uint16_t tmpccr1 = 0;
   \                     TIM2_GetCapture1:
   \   000000 905F         CLRW      Y
   1307            uint8_t tmpccr1l, tmpccr1h;
   1308          
   1309            tmpccr1h = TIM2->CCR1H;
   \   000002 C6 5261      LD        A, L:0x5261
   \   000005 B7 ..        LD        S:?b0, A
   1310            tmpccr1l = TIM2->CCR1L;
   \   000007 C6 5262      LD        A, L:0x5262
   1311          
   1312            tmpccr1 = (uint16_t)(tmpccr1l);
   \   00000A 5F           CLRW      X
   \   00000B 97           LD        XL, A
   \   00000C 9093         LDW       Y, X
   1313            tmpccr1 |= (uint16_t)((uint16_t)tmpccr1h << 8);
   \   00000E 5F           CLRW      X
   \   00000F 41           EXG       A, XL
   \   000010 B6 ..        LD        A, S:?b0
   \   000012 41           EXG       A, XL
   \   000013 4F           CLR       A
   \   000014 02           RLWA      X, A
   \   000015 BF ..        LDW       S:?w0, X
   \   000017 51           EXGW      X, Y
   \   000018 01           RRWA      X, A
   \   000019 BA ..        OR        A, S:?b1
   \   00001B 01           RRWA      X, A
   \   00001C BA ..        OR        A, S:?b0
   \   00001E 01           RRWA      X, A
   \   00001F 51           EXGW      X, Y
   1314            /* Get the Capture 1 Register value */
   1315            return ((uint16_t)tmpccr1);
   \   000020 93           LDW       X, Y
   \   000021 87           RETF
   1316          }
   1317          
   1318          /**
   1319            * @brief  Gets the TIM2 Input Capture 2 value.
   1320            * @param  None
   1321            * @retval Capture Compare 2 Register value.
   1322            */

   \                                 In section .far_func.text, align 1, keep-with-next
   1323          uint16_t TIM2_GetCapture2(void)
   1324          {
   1325            uint16_t tmpccr2 = 0;
   \                     TIM2_GetCapture2:
   \   000000 905F         CLRW      Y
   1326            uint8_t tmpccr2l, tmpccr2h;
   1327          
   1328            tmpccr2h = TIM2->CCR2H;
   \   000002 C6 5263      LD        A, L:0x5263
   \   000005 B7 ..        LD        S:?b0, A
   1329            tmpccr2l = TIM2->CCR2L;
   \   000007 C6 5264      LD        A, L:0x5264
   1330          
   1331            tmpccr2 = (uint16_t)(tmpccr2l);
   \   00000A 5F           CLRW      X
   \   00000B 97           LD        XL, A
   \   00000C 9093         LDW       Y, X
   1332            tmpccr2 |= (uint16_t)((uint16_t)tmpccr2h << 8);
   \   00000E 5F           CLRW      X
   \   00000F 41           EXG       A, XL
   \   000010 B6 ..        LD        A, S:?b0
   \   000012 41           EXG       A, XL
   \   000013 4F           CLR       A
   \   000014 02           RLWA      X, A
   \   000015 BF ..        LDW       S:?w0, X
   \   000017 51           EXGW      X, Y
   \   000018 01           RRWA      X, A
   \   000019 BA ..        OR        A, S:?b1
   \   00001B 01           RRWA      X, A
   \   00001C BA ..        OR        A, S:?b0
   \   00001E 01           RRWA      X, A
   \   00001F 51           EXGW      X, Y
   1333            /* Get the Capture 2 Register value */
   1334            return ((uint16_t)tmpccr2);
   \   000020 93           LDW       X, Y
   \   000021 87           RETF
   1335          }
   1336          
   1337          /**
   1338            * @brief  Sets the TIM2 Input Capture 1 prescaler.
   1339            * @param  TIM2_IC1Prescaler: Specifies the Input Capture prescaler new value
   1340            *          This parameter can be one of the following values:
   1341            *            @arg TIM2_ICPSC_DIV1: Input Capture Prescaler = 1 (one capture every 1 event)
   1342            *            @arg TIM2_ICPSC_DIV2: Input Capture Prescaler = 2 (one capture every 2 events)
   1343            *            @arg TIM2_ICPSC_DIV4: Input Capture Prescaler = 4 (one capture every 4 events)
   1344            *            @arg TIM2_ICPSC_DIV8: Input Capture Prescaler = 8 (one capture every 8 events) 
   1345            * @retval None
   1346            */

   \                                 In section .far_func.text, align 1, keep-with-next
   1347          void TIM2_SetIC1Prescaler(TIM2_ICPSC_TypeDef TIM2_IC1Prescaler)
   1348          {
   \                     TIM2_SetIC1Prescaler:
   \   000000 B7 ..        LD        S:?b0, A
   1349            uint8_t tmpccmr1 = 0;
   \   000002 3F ..        CLR       S:?b1
   1350          
   1351            /* Check the parameters */
   1352            assert_param(IS_TIM2_IC_PRESCALER(TIM2_IC1Prescaler));
   1353          
   1354            tmpccmr1 = TIM2->CCMR1;
   \   000004 C6 5259      LD        A, L:0x5259
   \   000007 B7 ..        LD        S:?b1, A
   1355          
   1356            /* Reset the IC1PSC Bits */
   1357            tmpccmr1 &= (uint8_t)(~TIM_CCMR_ICxPSC);
   \   000009 B6 ..        LD        A, S:?b1
   \   00000B A4 F3        AND       A, #0xf3
   \   00000D B7 ..        LD        S:?b1, A
   1358          
   1359            /* Set the IC1PSC value */
   1360            tmpccmr1 |= (uint8_t)TIM2_IC1Prescaler;
   \   00000F B6 ..        LD        A, S:?b0
   \   000011 BA ..        OR        A, S:?b1
   \   000013 B7 ..        LD        S:?b1, A
   1361          
   1362            TIM2->CCMR1 = tmpccmr1;
   \   000015 B6 ..        LD        A, S:?b1
   \   000017 C7 5259      LD        L:0x5259, A
   1363          }
   \   00001A 87           RETF
   1364          
   1365          /**
   1366            * @brief  Sets the TIM2 Input Capture 2 prescaler.
   1367            * @param  TIM2_IC2Prescaler: Specifies the Input Capture prescaler new value
   1368            *          This parameter can be one of the following values:
   1369            *            @arg TIM2_ICPSC_DIV1: Input Capture Prescaler = 1 (one capture every 1 event)
   1370            *            @arg TIM2_ICPSC_DIV2: Input Capture Prescaler = 2 (one capture every 2 events)
   1371            *            @arg TIM2_ICPSC_DIV4: Input Capture Prescaler = 4 (one capture every 4 events)
   1372            *            @arg TIM2_ICPSC_DIV8: Input Capture Prescaler = 8 (one capture every 8 events) 
   1373            * @retval None
   1374            */

   \                                 In section .far_func.text, align 1, keep-with-next
   1375          void TIM2_SetIC2Prescaler(TIM2_ICPSC_TypeDef TIM2_IC2Prescaler)
   1376          {
   \                     TIM2_SetIC2Prescaler:
   \   000000 B7 ..        LD        S:?b0, A
   1377            uint8_t tmpccmr2 = 0;
   \   000002 3F ..        CLR       S:?b1
   1378          
   1379            /* Check the parameters */
   1380            assert_param(IS_TIM2_IC_PRESCALER(TIM2_IC2Prescaler));
   1381          
   1382            tmpccmr2 = TIM2->CCMR2;
   \   000004 C6 525A      LD        A, L:0x525a
   \   000007 B7 ..        LD        S:?b1, A
   1383          
   1384            /* Reset the IC2PSC Bits */
   1385            tmpccmr2 &= (uint8_t)(~TIM_CCMR_ICxPSC);
   \   000009 B6 ..        LD        A, S:?b1
   \   00000B A4 F3        AND       A, #0xf3
   \   00000D B7 ..        LD        S:?b1, A
   1386          
   1387            /* Set the IC2PSC value */
   1388            tmpccmr2 |= (uint8_t)TIM2_IC2Prescaler;
   \   00000F B6 ..        LD        A, S:?b0
   \   000011 BA ..        OR        A, S:?b1
   \   000013 B7 ..        LD        S:?b1, A
   1389          
   1390            TIM2->CCMR2 = tmpccmr2;
   \   000015 B6 ..        LD        A, S:?b1
   \   000017 C7 525A      LD        L:0x525a, A
   1391          }
   \   00001A 87           RETF
   1392          
   1393          /**
   1394            * @}
   1395            */
   1396          
   1397          /** @defgroup TIM2_Group4 Interrupts DMA and flags management functions
   1398           *  @brief    Interrupts, DMA and flags management functions 
   1399           *
   1400          @verbatim   
   1401           ===============================================================================
   1402                           Interrupts, DMA and flags management functions
   1403           ===============================================================================  
   1404          
   1405          @endverbatim
   1406            * @{
   1407            */
   1408          
   1409          /**
   1410            * @brief  Enables or disables the specified TIM2 interrupts.
   1411            * @param  TIM2_IT: Specifies the TIM2 interrupts sources to be enabled or disabled.
   1412            *          This parameter can be any combination of the following values:
   1413            *            @arg TIM2_IT_Update: Update
   1414            *            @arg TIM2_IT_CC1: Capture Compare Channel1
   1415            *            @arg TIM2_IT_CC2: Capture Compare Channel2 
   1416            *            @arg TIM2_IT_Trigger: Trigger 
   1417            *            @arg TIM2_IT_Break: Break  
   1418            * @param  NewState: The new state of the TIM2 peripheral.
   1419            *          This parameter can be ENABLE or DISABLE
   1420            * @retval None
   1421            */

   \                                 In section .far_func.text, align 1
   1422          void TIM2_ITConfig(TIM2_IT_TypeDef TIM2_IT, FunctionalState NewState)
   1423          {
   1424            /* Check the parameters */
   1425            assert_param(IS_TIM2_IT(TIM2_IT));
   1426            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1427          
   1428            if (NewState != DISABLE)
   \                     TIM2_ITConfig:
   \   000000 3D ..        TNZ       S:?b0
   \   000002 27 07        JREQ      L:??TIM2_ITConfig_0
   1429            {
   1430              /* Enable the Interrupt sources */
   1431              TIM2->IER |= (uint8_t)TIM2_IT;
   \   000004 CA 5255      OR        A, L:0x5255
   \   000007 C7 5255      LD        L:0x5255, A
   \   00000A 87           RETF
   1432            }
   1433            else
   1434            {
   1435              /* Disable the Interrupt sources */
   1436              TIM2->IER &= (uint8_t)(~(uint8_t)TIM2_IT);
   \                     ??TIM2_ITConfig_0:
   \   00000B 43           CPL       A
   \   00000C C4 5255      AND       A, L:0x5255
   \   00000F C7 5255      LD        L:0x5255, A
   1437            }
   1438          }
   \   000012 87           RETF
   1439          
   1440          /**
   1441            * @brief  Configures the TIM2 event to be generated by software.
   1442            * @param  TIM2_EventSource: Specifies the event source.
   1443            *          This parameter can be any combination of the following values:
   1444            *            @arg TIM2_EventSource_Update: Update
   1445            *            @arg TIM2_EventSource_CC1: Capture Compare Channel1
   1446            *            @arg TIM2_EventSource_CC2: Capture Compare Channel2 
   1447            *            @arg TIM2_EventSource_Trigger: Trigger 
   1448            *            @arg TIM2_EventSource_Break: Break  
   1449            * @retval None
   1450            */

   \                                 In section .far_func.text, align 1
   1451          void TIM2_GenerateEvent(TIM2_EventSource_TypeDef TIM2_EventSource)
   1452          {
   1453            /* Check the parameters */
   1454            assert_param(IS_TIM2_EVENT_SOURCE((uint8_t)TIM2_EventSource));
   1455          
   1456            /* Set the event sources */
   1457            TIM2->EGR |= (uint8_t)TIM2_EventSource;
   \                     TIM2_GenerateEvent:
   \   000000 CA 5258      OR        A, L:0x5258
   \   000003 C7 5258      LD        L:0x5258, A
   1458          }
   \   000006 87           RETF
   1459          
   1460          /**
   1461            * @brief  Checks whether the specified TIM2 flag is set or not.
   1462            * @param  TIM2_FLAG: Specifies the flag to check.
   1463            *          This parameter can be any combination of the following values:
   1464            *            @arg TIM2_FLAG_Update: Update
   1465            *            @arg TIM2_FLAG_CC1: Capture Compare Channel1
   1466            *            @arg TIM2_FLAG_CC2: Capture Compare Channel2 
   1467            *            @arg TIM2_FLAG_Trigger: Trigger 
   1468            *            @arg TIM2_FLAG_Break: Break  
   1469            *            @arg TIM2_FLAG_CC1OF: Capture compare 1 over capture
   1470            *            @arg TIM2_FLAG_CC2OF: Capture compare 2 over capture   
   1471            * @retval FlagStatus: The new state of TIM2_FLAG (SET or RESET)
   1472            */

   \                                 In section .far_func.text, align 1
   1473          FlagStatus TIM2_GetFlagStatus(TIM2_FLAG_TypeDef TIM2_FLAG)
   1474          {
   1475            FlagStatus bitstatus = RESET;
   \                     TIM2_GetFlagStatus:
   \   000000 3F ..        CLR       S:?b0
   1476            uint8_t tim2_flag_l = 0, tim2_flag_h = 0;
   \   000002 3F ..        CLR       S:?b2
   \   000004 3F ..        CLR       S:?b1
   1477          
   1478            /* Check the parameters */
   1479            assert_param(IS_TIM2_GET_FLAG(TIM2_FLAG));
   1480          
   1481            tim2_flag_l = (uint8_t)(TIM2->SR1 & (uint8_t)(TIM2_FLAG));
   \   000006 9F           LD        A, XL
   \   000007 C4 5256      AND       A, L:0x5256
   \   00000A B7 ..        LD        S:?b2, A
   1482            tim2_flag_h = (uint8_t)(TIM2->SR2 & (uint8_t)((uint16_t)TIM2_FLAG >> 8));
   \   00000C 4F           CLR       A
   \   00000D 01           RRWA      X, A
   \   00000E 9F           LD        A, XL
   \   00000F C4 5257      AND       A, L:0x5257
   \   000012 B7 ..        LD        S:?b1, A
   1483          
   1484            if ((uint8_t)(tim2_flag_l | tim2_flag_h) != 0)
   \   000014 B6 ..        LD        A, S:?b1
   \   000016 BA ..        OR        A, S:?b2
   \   000018 A1 00        CP        A, #0x0
   \   00001A 27 06        JREQ      L:??TIM2_GetFlagStatus_0
   1485            {
   1486              bitstatus = SET;
   \   00001C 35 01 ....   MOV       S:?b0, #0x1
   \   000020 20 02        JRA       L:??TIM2_GetFlagStatus_1
   1487            }
   1488            else
   1489            {
   1490              bitstatus = RESET;
   \                     ??TIM2_GetFlagStatus_0:
   \   000022 3F ..        CLR       S:?b0
   1491            }
   1492            return ((FlagStatus)bitstatus);
   \                     ??TIM2_GetFlagStatus_1:
   \   000024 B6 ..        LD        A, S:?b0
   \   000026 87           RETF
   1493          }
   1494          
   1495          /**
   1496            * @brief  Clears the TIM’s pending flags.
   1497            * @param  TIM2_FLAG: Specifies the flag to clear.
   1498            *          This parameter can be any combination of the following values:
   1499            *            @arg TIM2_FLAG_Update: Update
   1500            *            @arg TIM2_FLAG_CC1: Capture Compare Channel1
   1501            *            @arg TIM2_FLAG_CC2: Capture Compare Channel2 
   1502            *            @arg TIM2_FLAG_Trigger: Trigger 
   1503            *            @arg TIM2_FLAG_Break: Break  
   1504            * @retval None
   1505            */

   \                                 In section .far_func.text, align 1
   1506          void TIM2_ClearFlag(TIM2_FLAG_TypeDef TIM2_FLAG)
   1507          {
   1508            /* Check the parameters */
   1509            assert_param(IS_TIM2_CLEAR_FLAG((uint16_t)TIM2_FLAG));
   1510            /* Clear the flags (rc_w0) clear this bit by writing 0. Writing ‘1’ has no effect*/
   1511            TIM2->SR1 = (uint8_t)(~(uint8_t)(TIM2_FLAG));
   \                     TIM2_ClearFlag:
   \   000000 9F           LD        A, XL
   \   000001 43           CPL       A
   \   000002 C7 5256      LD        L:0x5256, A
   1512            TIM2->SR2 = (uint8_t)(~(uint8_t)((uint16_t)TIM2_FLAG >> 8));
   \   000005 4F           CLR       A
   \   000006 01           RRWA      X, A
   \   000007 9F           LD        A, XL
   \   000008 43           CPL       A
   \   000009 C7 5257      LD        L:0x5257, A
   1513          }
   \   00000C 87           RETF
   1514          
   1515          /**
   1516            * @brief  Checks whether the TIM2 interrupt has occurred or not.
   1517            * @param  TIM2_IT: Specifies the TIM2 interrupt source to check.
   1518            *          This parameter can be any combination of the following values:
   1519            *            @arg TIM2_IT_Update: Update
   1520            *            @arg TIM2_IT_CC1: Capture Compare Channel1
   1521            *            @arg TIM2_IT_CC2: Capture Compare Channel2 
   1522            *            @arg TIM2_IT_Trigger: Trigger 
   1523            *            @arg TIM2_IT_Break: Break  
   1524            * @retval ITStatus: The new state of the TIM2_IT (SET or RESET)
   1525            */

   \                                 In section .far_func.text, align 1
   1526          ITStatus TIM2_GetITStatus(TIM2_IT_TypeDef TIM2_IT)
   1527          {
   \                     TIM2_GetITStatus:
   \   000000 B7 ..        LD        S:?b3, A
   1528            ITStatus bitstatus = RESET;
   \   000002 3F ..        CLR       S:?b0
   1529          
   1530            uint8_t TIM2_itStatus = 0x0, TIM2_itEnable = 0x0;
   \   000004 3F ..        CLR       S:?b2
   \   000006 3F ..        CLR       S:?b1
   1531          
   1532            /* Check the parameters */
   1533            assert_param(IS_TIM2_GET_IT(TIM2_IT));
   1534          
   1535            TIM2_itStatus = (uint8_t)(TIM2->SR1 & (uint8_t)TIM2_IT);
   \   000008 B6 ..        LD        A, S:?b3
   \   00000A C4 5256      AND       A, L:0x5256
   \   00000D B7 ..        LD        S:?b2, A
   1536          
   1537            TIM2_itEnable = (uint8_t)(TIM2->IER & (uint8_t)TIM2_IT);
   \   00000F B6 ..        LD        A, S:?b3
   \   000011 C4 5255      AND       A, L:0x5255
   \   000014 B7 ..        LD        S:?b1, A
   1538          
   1539            if ((TIM2_itStatus != (uint8_t)RESET ) && (TIM2_itEnable != (uint8_t)RESET))
   \   000016 3D ..        TNZ       S:?b2
   \   000018 27 0A        JREQ      L:??TIM2_GetITStatus_0
   \   00001A 3D ..        TNZ       S:?b1
   \   00001C 27 06        JREQ      L:??TIM2_GetITStatus_0
   1540            {
   1541              bitstatus = (ITStatus)SET;
   \   00001E 35 01 ....   MOV       S:?b0, #0x1
   \   000022 20 02        JRA       L:??TIM2_GetITStatus_1
   1542            }
   1543            else
   1544            {
   1545              bitstatus = (ITStatus)RESET;
   \                     ??TIM2_GetITStatus_0:
   \   000024 3F ..        CLR       S:?b0
   1546            }
   1547            return ((ITStatus)bitstatus);
   \                     ??TIM2_GetITStatus_1:
   \   000026 B6 ..        LD        A, S:?b0
   \   000028 87           RETF
   1548          }
   1549          
   1550          /**
   1551            * @brief  Clears the TIM's interrupt pending bits.
   1552            * @param  TIM2_IT: Specifies the pending bit to clear.
   1553            *          This parameter can be any combination of the following values:
   1554            *            @arg TIM2_IT_Update: Update
   1555            *            @arg TIM2_IT_CC1: Capture Compare Channel1
   1556            *            @arg TIM2_IT_CC2: Capture Compare Channel2 
   1557            *            @arg TIM2_IT_Trigger: Trigger 
   1558            *            @arg TIM2_IT_Break: Break  
   1559            * @retval None
   1560            */

   \                                 In section .far_func.text, align 1
   1561          void TIM2_ClearITPendingBit(TIM2_IT_TypeDef TIM2_IT)
   1562          {
   1563            /* Check the parameters */
   1564            assert_param(IS_TIM2_IT(TIM2_IT));
   1565          
   1566            /* Clear the IT pending Bit */
   1567            TIM2->SR1 = (uint8_t)(~(uint8_t)TIM2_IT);
   \                     TIM2_ClearITPendingBit:
   \   000000 43           CPL       A
   \   000001 C7 5256      LD        L:0x5256, A
   1568          }
   \   000004 87           RETF
   1569          
   1570          /**
   1571            * @brief  Enables or disables the TIM2 DMA Requests.
   1572            * @param  TIM2_DMASource: specifies the DMA Request sources.
   1573            *          This parameter can be any combination of the following values:
   1574            *            @arg TIM2_DMASource_Update: TIM2 DMA Update Request
   1575            *            @arg TIM2_DMASource_CC1: TIM2 DMA CC1 Request
   1576            *            @arg TIM2_DMASource_CC2: TIM2 DMA CC2 Request 
   1577            * @param  NewState: new state of the DMA Request sources.
   1578            *          This parameter can be: ENABLE or DISABLE.
   1579            * @retval None
   1580            */

   \                                 In section .far_func.text, align 1
   1581          void TIM2_DMACmd( TIM2_DMASource_TypeDef TIM2_DMASource, FunctionalState NewState)
   1582          {
   1583            /* Check the parameters */
   1584            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1585            assert_param(IS_TIM2_DMA_SOURCE(TIM2_DMASource));
   1586          
   1587            if (NewState != DISABLE)
   \                     TIM2_DMACmd:
   \   000000 3D ..        TNZ       S:?b0
   \   000002 27 07        JREQ      L:??TIM2_DMACmd_0
   1588            {
   1589              /* Enable the DMA sources */
   1590              TIM2->DER |= TIM2_DMASource;
   \   000004 CA 5254      OR        A, L:0x5254
   \   000007 C7 5254      LD        L:0x5254, A
   \   00000A 87           RETF
   1591            }
   1592            else
   1593            {
   1594              /* Disable the DMA sources */
   1595              TIM2->DER &= (uint8_t)(~TIM2_DMASource);
   \                     ??TIM2_DMACmd_0:
   \   00000B 43           CPL       A
   \   00000C C4 5254      AND       A, L:0x5254
   \   00000F C7 5254      LD        L:0x5254, A
   1596            }
   1597          }
   \   000012 87           RETF
   1598          
   1599          /**
   1600            * @brief  Selects the TIM2 peripheral Capture Compare DMA source.
   1601            * @param   NewState: new state of the Capture Compare DMA source.
   1602            *           This parameter can be: ENABLE or DISABLE.
   1603            * @retval None
   1604            */

   \                                 In section .far_func.text, align 1
   1605          void TIM2_SelectCCDMA(FunctionalState NewState)
   1606          {
   1607            /* Check the parameters */
   1608            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1609          
   1610            if (NewState != DISABLE)
   \                     TIM2_SelectCCDMA:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM2_SelectCCDMA_0
   1611            {
   1612              /* Set the CCDS Bit */
   1613              TIM2->CR2 |= TIM_CR2_CCDS;
   \   000003 7216 5251    BSET      L:0x5251, #0x3
   \   000007 87           RETF
   1614            }
   1615            else
   1616            {
   1617              /* Reset the CCDS Bit */
   1618              TIM2->CR2 &= (uint8_t)(~TIM_CR2_CCDS);
   \                     ??TIM2_SelectCCDMA_0:
   \   000008 7217 5251    BRES      L:0x5251, #0x3
   1619            }
   1620          }
   \   00000C 87           RETF
   1621          
   1622          /**
   1623            * @}
   1624            */
   1625          
   1626          /** @defgroup TIM2_Group5 Clocks management functions
   1627           *  @brief    Clocks management functions
   1628           *
   1629          @verbatim   
   1630           ===============================================================================
   1631                                   Clocks management functions
   1632           ===============================================================================  
   1633          
   1634          @endverbatim
   1635            * @{
   1636            */
   1637          
   1638          /**
   1639            * @brief  Enables the TIM2 internal Clock.
   1640            * @par Parameters:
   1641            * None
   1642            * @retval None
   1643            */

   \                                 In section .far_func.text, align 1
   1644          void TIM2_InternalClockConfig(void)
   1645          {
   1646            /* Disable slave mode to clock the prescaler directly with the internal clock */
   1647            TIM2->SMCR &=  (uint8_t)(~TIM_SMCR_SMS);
   \                     TIM2_InternalClockConfig:
   \   000000 C6 5252      LD        A, L:0x5252
   \   000003 A4 F8        AND       A, #0xf8
   \   000005 C7 5252      LD        L:0x5252, A
   1648          }
   \   000008 87           RETF
   1649          
   1650          /**
   1651            * @brief  Configures the TIM2 Trigger as External Clock.
   1652            * @param  TIM2_TIxExternalCLKSource: Specifies Trigger source.
   1653            *          This parameter can be one of the following values:
   1654            *            @arg TIM2_TIxExternalCLK1Source_TI1ED: External Clock mode 1 source = TI1ED
   1655            *            @arg TIM2_TIxExternalCLK1Source_TI1: External Clock mode 1 source = TI1 
   1656            *            @arg TIM2_TIxExternalCLK1Source_TI2: External Clock mode 1 source = TI2  
   1657            * @param  TIM2_ICPolarity: Specifies the TIx Polarity.
   1658            *          This parameter can be one of the following values:
   1659            *            @arg TIM2_ICPolarity_Rising: Input Capture on Rising Edge
   1660            *            @arg TIM2_ICPolarity_Falling: Input Capture on Falling Edge  
   1661            * @param  ICFilter: Specifies the filter value.
   1662            *          This parameter must be a value between 0x00 and 0x0F
   1663            * @retval None
   1664            */

   \                                 In section .far_func.text, align 1
   1665          void TIM2_TIxExternalClockConfig(TIM2_TIxExternalCLK1Source_TypeDef TIM2_TIxExternalCLKSource,
   1666                                           TIM2_ICPolarity_TypeDef TIM2_ICPolarity,
   1667                                           uint8_t ICFilter)
   1668          {
   \                     TIM2_TIxExternalClockConfig:
   \   000000 B7 ..        LD        S:?b4, A
   \   000002 45 .. ..     MOV       S:?b2, S:?b0
   1669            /* Check the parameters */
   1670            assert_param(IS_TIM2_TIXCLK_SOURCE(TIM2_TIxExternalCLKSource));
   1671            assert_param(IS_TIM2_IC_POLARITY(TIM2_ICPolarity));
   1672            assert_param(IS_TIM2_IC_FILTER(ICFilter));
   1673          
   1674            /* Configure the TIM2 Input Clock Source */
   1675            if (TIM2_TIxExternalCLKSource == TIM2_TIxExternalCLK1Source_TI2)
   \   000005 B6 ..        LD        A, S:?b4
   \   000007 A1 60        CP        A, #0x60
   \   000009 26 0C        JRNE      L:??TIM2_TIxExternalClockConfig_0
   1676            {
   1677              TI2_Config(TIM2_ICPolarity, TIM2_ICSelection_DirectTI, ICFilter);
   \   00000B 35 01 ....   MOV       S:?b0, #0x1
   \   00000F B6 ..        LD        A, S:?b2
   \   000011 8D ......    CALLF     TI2_Config
   \   000015 20 0A        JRA       L:??TIM2_TIxExternalClockConfig_1
   1678            }
   1679            else
   1680            {
   1681              TI1_Config(TIM2_ICPolarity, TIM2_ICSelection_DirectTI, ICFilter);
   \                     ??TIM2_TIxExternalClockConfig_0:
   \   000017 35 01 ....   MOV       S:?b0, #0x1
   \   00001B B6 ..        LD        A, S:?b2
   \   00001D 8D ......    CALLF     TI1_Config
   1682            }
   1683          
   1684            /* Select the Trigger source */
   1685            TIM2_SelectInputTrigger((TIM2_TRGSelection_TypeDef)TIM2_TIxExternalCLKSource);
   \                     ??TIM2_TIxExternalClockConfig_1:
   \   000021 B6 ..        LD        A, S:?b4
   \   000023 8D ......    CALLF     TIM2_SelectInputTrigger
   1686          
   1687            /* Select the External clock mode1 */
   1688            TIM2->SMCR |= (uint8_t)(TIM2_SlaveMode_External1);
   \   000027 C6 5252      LD        A, L:0x5252
   \   00002A AA 07        OR        A, #0x7
   \   00002C C7 5252      LD        L:0x5252, A
   1689          }
   \   00002F 87           RETF
   1690          
   1691          /**
   1692            * @brief  Configures the TIM2 External clock Mode1.
   1693            * @param  TIM2_ExtTRGPrescaler: Specifies the external Trigger Prescaler.
   1694            *          This parameter can be one of the following values:
   1695            *            @arg TIM2_ExtTRGPSC_OFF: No External Trigger prescaler
   1696            *            @arg TIM2_ExtTRGPSC_DIV2: External Trigger prescaler = 2 (ETRP frequency divided by 2)
   1697            *            @arg TIM2_ExtTRGPSC_DIV4: External Trigger prescaler = 4 (ETRP frequency divided by 4) 
   1698            *            @arg TIM2_ExtTRGPSC_DIV8: External Trigger prescaler = 8 (ETRP frequency divided by 8)   
   1699            * @param  TIM2_ExtTRGPolarity: Specifies the external Trigger Polarity.
   1700            *          This parameter can be one of the following values:
   1701            *            @arg TIM2_ExtTRGPolarity_Inverted: External Trigger Polarity = inverted
   1702            *            @arg TIM2_ExtTRGPolarity_NonInverted: External Trigger Polarity = non inverted
   1703            * @param  ExtTRGFilter: Specifies the External Trigger Filter.
   1704            *          This parameter must be a value between 0x00 and 0x0F
   1705            * @retval None
   1706            */

   \                                 In section .far_func.text, align 1
   1707          void TIM2_ETRClockMode1Config(TIM2_ExtTRGPSC_TypeDef TIM2_ExtTRGPrescaler,
   1708                                        TIM2_ExtTRGPolarity_TypeDef TIM2_ExtTRGPolarity,
   1709                                        uint8_t ExtTRGFilter)
   1710          {
   1711            /* Configure the ETR Clock source */
   1712            TIM2_ETRConfig(TIM2_ExtTRGPrescaler, TIM2_ExtTRGPolarity, ExtTRGFilter);
   \                     TIM2_ETRClockMode1Config:
   \   000000 8D ......    CALLF     TIM2_ETRConfig
   1713          
   1714            /* Select the External clock mode1 */
   1715            TIM2->SMCR &= (uint8_t)(~TIM_SMCR_SMS);
   \   000004 C6 5252      LD        A, L:0x5252
   \   000007 A4 F8        AND       A, #0xf8
   \   000009 C7 5252      LD        L:0x5252, A
   1716            TIM2->SMCR |= (uint8_t)(TIM2_SlaveMode_External1);
   \   00000C C6 5252      LD        A, L:0x5252
   \   00000F AA 07        OR        A, #0x7
   \   000011 C7 5252      LD        L:0x5252, A
   1717          
   1718            /* Select the Trigger selection: ETRF */
   1719            TIM2->SMCR &= (uint8_t)(~TIM_SMCR_TS);
   \   000014 C6 5252      LD        A, L:0x5252
   \   000017 A4 8F        AND       A, #0x8f
   \   000019 C7 5252      LD        L:0x5252, A
   1720            TIM2->SMCR |= (uint8_t)((TIM2_TRGSelection_TypeDef)TIM2_TRGSelection_ETRF);
   \   00001C C6 5252      LD        A, L:0x5252
   \   00001F AA 70        OR        A, #0x70
   \   000021 C7 5252      LD        L:0x5252, A
   1721          }
   \   000024 87           RETF
   1722          
   1723          /**
   1724            * @brief  Configures the TIM2 External clock Mode2.
   1725            * @param  TIM2_ExtTRGPrescaler: Specifies the external Trigger Prescaler.
   1726            *          This parameter can be one of the following values:
   1727            *            @arg TIM2_ExtTRGPSC_OFF: No External Trigger prescaler
   1728            *            @arg TIM2_ExtTRGPSC_DIV2: External Trigger prescaler = 2 (ETRP frequency divided by 2)
   1729            *            @arg TIM2_ExtTRGPSC_DIV4: External Trigger prescaler = 4 (ETRP frequency divided by 4) 
   1730            *            @arg TIM2_ExtTRGPSC_DIV8: External Trigger prescaler = 8 (ETRP frequency divided by 8) 
   1731            * @param  TIM2_ExtTRGPolarity: Specifies the external Trigger Polarity.
   1732            *          This parameter can be one of the following values:
   1733            *            @arg TIM2_ExtTRGPolarity_Inverted: External Trigger Polarity = inverted
   1734            *            @arg TIM2_ExtTRGPolarity_NonInverted: External Trigger Polarity = non inverted
   1735            * @param  ExtTRGFilter: Specifies the External Trigger Filter.
   1736            *          This parameter must be a value between 0x00 and 0x0F
   1737            * @retval None
   1738            */

   \                                 In section .far_func.text, align 1
   1739          void TIM2_ETRClockMode2Config(TIM2_ExtTRGPSC_TypeDef TIM2_ExtTRGPrescaler,
   1740                                        TIM2_ExtTRGPolarity_TypeDef TIM2_ExtTRGPolarity,
   1741                                        uint8_t ExtTRGFilter)
   1742          {
   1743            /* Configure the ETR Clock source */
   1744            TIM2_ETRConfig(TIM2_ExtTRGPrescaler, TIM2_ExtTRGPolarity, ExtTRGFilter);
   \                     TIM2_ETRClockMode2Config:
   \   000000 8D ......    CALLF     TIM2_ETRConfig
   1745          
   1746            /* Enable the External clock mode2 */
   1747            TIM2->ETR |= TIM_ETR_ECE ;
   \   000004 721C 5253    BSET      L:0x5253, #0x6
   1748          }
   \   000008 87           RETF
   1749          
   1750          /**
   1751            * @}
   1752            */
   1753          
   1754          /** @defgroup TIM2_Group6 Synchronization management functions
   1755           *  @brief    Synchronization management functions 
   1756           *
   1757          @verbatim   
   1758           ===============================================================================
   1759                                 Synchronization management functions
   1760           ===============================================================================  
   1761                             
   1762                 ===================================================================      
   1763                        TIM2 Driver: how to use it in synchronization Mode
   1764                 =================================================================== 
   1765                 Case of two/several Timers
   1766                 **************************
   1767                 1. If TIM2 is used as master to other timers use the following functions:
   1768                    - TIM2_SelectOutputTrigger()
   1769                    - TIM2_SelectMasterSlaveMode()
   1770                 2. If TIM2 is used as slave to other timers use the following functions:
   1771                    - TIM2_SelectInputTrigger()
   1772                    - TIM2_SelectSlaveMode()
   1773                    
   1774                 Case of Timers and external trigger (TRIG pin)
   1775                 ********************************************       
   1776                 1. Configure the External trigger using TIM2_ETRConfig()
   1777                 2. Configure the Slave Timer using the following functions:
   1778                    - TIM2_SelectInputTrigger()
   1779                    - TIM2_SelectSlaveMode()
   1780          
   1781          @endverbatim
   1782            * @{
   1783            */
   1784          
   1785          /**
   1786            * @brief  Selects the TIM2 Input Trigger source.
   1787            * @param  TIM2_InputTriggerSource: Specifies Input Trigger source.
   1788            *          This parameter can be one of the following values:
   1789            *            @arg TIM2_TRGSelection_TIM4: TRIG Input source =  TIM TRIG Output
   1790            *            @arg TIM2_TRGSelection_TIM1: TRIG Input source =  TIM TRIG Output
   1791            *            @arg TIM2_TRGSelection_TIM2: TRIG Input source =  TIM TRIG Output
   1792            *            @arg TIM2_TRGSelection_TIM2: TRIG Input source =  TIM TRIG Output
   1793            *            @arg TIM2_TRGSelection_TI1F_ED: TRIG Input source = TI1F_ED (TI1 Edge Detector)
   1794            *            @arg TIM2_TRGSelection_TI1FP1: TRIG Input source = TI1FP1 (Filtered Timer Input 1)
   1795            *            @arg TIM2_TRGSelection_TI2FP2: TRIG Input source = TI2FP2 (Filtered Timer Input 2)
   1796            *            @arg TIM2_TRGSelection_ETRF: TRIG Input source =  ETRF (External Trigger Input )      
   1797            * @retval None
   1798            */

   \                                 In section .far_func.text, align 1
   1799          void TIM2_SelectInputTrigger(TIM2_TRGSelection_TypeDef TIM2_InputTriggerSource)
   1800          {
   \                     TIM2_SelectInputTrigger:
   \   000000 B7 ..        LD        S:?b0, A
   1801            uint8_t tmpsmcr = 0;
   \   000002 3F ..        CLR       S:?b1
   1802          
   1803            /* Check the parameters */
   1804            assert_param(IS_TIM2_TRIGGER_SELECTION(TIM2_InputTriggerSource));
   1805          
   1806            tmpsmcr = TIM2->SMCR;
   \   000004 C6 5252      LD        A, L:0x5252
   \   000007 B7 ..        LD        S:?b1, A
   1807          
   1808            /* Select the Trigger Source */
   1809            tmpsmcr &= (uint8_t)(~TIM_SMCR_TS);
   \   000009 B6 ..        LD        A, S:?b1
   \   00000B A4 8F        AND       A, #0x8f
   \   00000D B7 ..        LD        S:?b1, A
   1810            tmpsmcr |= (uint8_t)TIM2_InputTriggerSource;
   \   00000F B6 ..        LD        A, S:?b0
   \   000011 BA ..        OR        A, S:?b1
   \   000013 B7 ..        LD        S:?b1, A
   1811          
   1812            TIM2->SMCR = (uint8_t)tmpsmcr;
   \   000015 B6 ..        LD        A, S:?b1
   \   000017 C7 5252      LD        L:0x5252, A
   1813          }
   \   00001A 87           RETF
   1814          
   1815          /**
   1816            * @brief  Selects the TIM2 Trigger Output Mode.
   1817            * @param  TIM2_TRGOSource: Specifies the Trigger Output source.
   1818            *          This parameter can be one of the following values:
   1819            *            @arg TIM2_TRGOSource_Reset: Trigger Output source = Reset 
   1820            *            @arg TIM2_TRGOSource_Enable: Trigger Output source = TIM2 is enabled 
   1821            *            @arg TIM2_TRGOSource_Update: Trigger Output source = Update event
   1822            *            @arg TIM2_TRGOSource_OC1: Trigger Output source = output compare channel1
   1823            *            @arg TIM2_TRGOSource_OC1REF: Trigger Output source = output compare channel 1 reference
   1824            *            @arg TIM2_TRGOSource_OC2REF: Trigger Output source = output compare channel 2 reference   
   1825            * @retval None
   1826            */

   \                                 In section .far_func.text, align 1
   1827          void TIM2_SelectOutputTrigger(TIM2_TRGOSource_TypeDef TIM2_TRGOSource)
   1828          {
   \                     TIM2_SelectOutputTrigger:
   \   000000 B7 ..        LD        S:?b0, A
   1829            uint8_t tmpcr2 = 0;
   \   000002 3F ..        CLR       S:?b1
   1830          
   1831            /* Check the parameters */
   1832            assert_param(IS_TIM2_TRGO_SOURCE(TIM2_TRGOSource));
   1833          
   1834            tmpcr2 = TIM2->CR2;
   \   000004 C6 5251      LD        A, L:0x5251
   \   000007 B7 ..        LD        S:?b1, A
   1835          
   1836            /* Reset the MMS Bits */
   1837            tmpcr2 &= (uint8_t)(~TIM_CR2_MMS);
   \   000009 B6 ..        LD        A, S:?b1
   \   00000B A4 8F        AND       A, #0x8f
   \   00000D B7 ..        LD        S:?b1, A
   1838          
   1839            /* Select the TRGO source */
   1840            tmpcr2 |=  (uint8_t)TIM2_TRGOSource;
   \   00000F B6 ..        LD        A, S:?b0
   \   000011 BA ..        OR        A, S:?b1
   \   000013 B7 ..        LD        S:?b1, A
   1841          
   1842            TIM2->CR2 = tmpcr2;
   \   000015 B6 ..        LD        A, S:?b1
   \   000017 C7 5251      LD        L:0x5251, A
   1843          }
   \   00001A 87           RETF
   1844          
   1845          /**
   1846            * @brief  Selects the TIM2 Slave Mode.
   1847            * @param  TIM2_SlaveMode: Specifies the TIM2 Slave Mode.
   1848            *          This parameter can be one of the following values:
   1849            *            @arg TIM2_SlaveMode_Reset: Slave Mode Selection  = Reset
   1850            *            @arg TIM2_SlaveMode_Gated: Slave Mode Selection  = Gated
   1851            *            @arg TIM2_SlaveMode_Trigger: Slave Mode Selection  = Trigger
   1852            *            @arg TIM2_SlaveMode_External1: Slave Mode Selection  = External 1  
   1853            * @retval None
   1854            */

   \                                 In section .far_func.text, align 1
   1855          void TIM2_SelectSlaveMode(TIM2_SlaveMode_TypeDef TIM2_SlaveMode)
   1856          {
   \                     TIM2_SelectSlaveMode:
   \   000000 B7 ..        LD        S:?b0, A
   1857            uint8_t tmpsmcr = 0;
   \   000002 3F ..        CLR       S:?b1
   1858          
   1859            /* Check the parameters */
   1860            assert_param(IS_TIM2_SLAVE_MODE(TIM2_SlaveMode));
   1861          
   1862            tmpsmcr = TIM2->SMCR;
   \   000004 C6 5252      LD        A, L:0x5252
   \   000007 B7 ..        LD        S:?b1, A
   1863          
   1864            /* Reset the SMS Bits */
   1865            tmpsmcr &= (uint8_t)(~TIM_SMCR_SMS);
   \   000009 B6 ..        LD        A, S:?b1
   \   00000B A4 F8        AND       A, #0xf8
   \   00000D B7 ..        LD        S:?b1, A
   1866          
   1867            /* Select the Slave Mode */
   1868            tmpsmcr |= (uint8_t)TIM2_SlaveMode;
   \   00000F B6 ..        LD        A, S:?b0
   \   000011 BA ..        OR        A, S:?b1
   \   000013 B7 ..        LD        S:?b1, A
   1869          
   1870            TIM2->SMCR = tmpsmcr;
   \   000015 B6 ..        LD        A, S:?b1
   \   000017 C7 5252      LD        L:0x5252, A
   1871          }
   \   00001A 87           RETF
   1872          
   1873          /**
   1874            * @brief  Sets or Resets the TIM2 Master/Slave Mode.
   1875            * @param  NewState: The new state of the synchronization between TIM2 and its slaves (through TRGO).
   1876            *          This parameter can be ENABLE or DISABLE
   1877            * @retval None
   1878            */

   \                                 In section .far_func.text, align 1
   1879          void TIM2_SelectMasterSlaveMode(FunctionalState NewState)
   1880          {
   1881            /* Check the parameters */
   1882            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1883          
   1884            /* Set or Reset the MSM Bit */
   1885            if (NewState != DISABLE)
   \                     TIM2_SelectMasterSlaveMode:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM2_SelectMasterSlaveMode_0
   1886            {
   1887              TIM2->SMCR |= TIM_SMCR_MSM;
   \   000003 721E 5252    BSET      L:0x5252, #0x7
   \   000007 87           RETF
   1888            }
   1889            else
   1890            {
   1891              TIM2->SMCR &= (uint8_t)(~TIM_SMCR_MSM);
   \                     ??TIM2_SelectMasterSlaveMode_0:
   \   000008 721F 5252    BRES      L:0x5252, #0x7
   1892            }
   1893          }
   \   00000C 87           RETF
   1894          
   1895          /**
   1896            * @brief  Configures the TIM2 External Trigger.
   1897            * @param  TIM2_ExtTRGPrescaler: Specifies the external Trigger Prescaler.
   1898            *          This parameter can be one of the following values:
   1899            *            @arg TIM2_ExtTRGPSC_OFF: No External Trigger prescaler
   1900            *            @arg TIM2_ExtTRGPSC_DIV2: External Trigger prescaler = 2 (ETRP frequency divided by 2)
   1901            *            @arg TIM2_ExtTRGPSC_DIV4: External Trigger prescaler = 4 (ETRP frequency divided by 4)
   1902            *            @arg TIM2_ExtTRGPSC_DIV8: External Trigger prescaler = 8 (ETRP frequency divided by 8)    
   1903            * @param  TIM2_ExtTRGPolarity: Specifies the external Trigger Polarity.
   1904            *          This parameter can be one of the following values:
   1905            *            @arg TIM2_ExtTRGPolarity_Inverted: External Trigger Polarity = inverted
   1906            *            @arg TIM2_ExtTRGPolarity_NonInverted: External Trigger Polarity = non inverted
   1907            * @param  ExtTRGFilter: Specifies the External Trigger Filter.
   1908            *          This parameter must be a value between 0x00 and 0x0F
   1909            * @retval None
   1910            */

   \                                 In section .far_func.text, align 1
   1911          void TIM2_ETRConfig(TIM2_ExtTRGPSC_TypeDef TIM2_ExtTRGPrescaler,
   1912                              TIM2_ExtTRGPolarity_TypeDef TIM2_ExtTRGPolarity,
   1913                              uint8_t ExtTRGFilter)
   1914          {
   \                     TIM2_ETRConfig:
   \   000000 B7 ..        LD        S:?b2, A
   \   000002 B6 ..        LD        A, S:?b0
   1915            /* Check the parameters */
   1916            assert_param(IS_TIM2_EXT_PRESCALER(TIM2_ExtTRGPrescaler));
   1917            assert_param(IS_TIM2_EXT_POLARITY(TIM2_ExtTRGPolarity));
   1918            assert_param(IS_TIM2_EXT_FILTER(ExtTRGFilter));
   1919          
   1920            /* Set the Prescaler, the Filter value and the Polarity */
   1921            TIM2->ETR |= (uint8_t)((uint8_t)((uint8_t)TIM2_ExtTRGPrescaler | (uint8_t)TIM2_ExtTRGPolarity)
   1922                                   | (uint8_t)ExtTRGFilter);
   \   000004 BA ..        OR        A, S:?b2
   \   000006 BA ..        OR        A, S:?b1
   \   000008 CA 5253      OR        A, L:0x5253
   \   00000B C7 5253      LD        L:0x5253, A
   1923          }
   \   00000E 87           RETF
   1924          
   1925          /**
   1926            * @}
   1927            */
   1928          
   1929          /** @defgroup TIM2_Group7 Specific interface management functions
   1930           *  @brief    Specific interface management functions 
   1931           *
   1932          @verbatim   
   1933           ===============================================================================
   1934                              Specific interface management functions
   1935           ===============================================================================  
   1936          
   1937          @endverbatim
   1938            * @{
   1939            */
   1940          
   1941          /**
   1942            * @brief  Configures the TIM2 Encoder Interface.
   1943            * @param  TIM2_EncoderMode: Specifies the TIM2 Encoder Mode.
   1944            *          This parameter can be one of the following values:
   1945            *            @arg TIM2_EncoderMode_TI1: Encoder mode 1
   1946            *            @arg TIM2_EncoderMode_TI2: Encoder mode 2
   1947            *            @arg TIM2_EncoderMode_TI12: Encoder mode 3   
   1948            * @param  TIM2_IC1Polarity: Specifies the IC1 Polarity.
   1949            *          This parameter can be one of the following values:
   1950            *            @arg TIM2_ICPolarity_Rising: Input Capture on Rising Edge
   1951            *            @arg TIM2_ICPolarity_Falling: Input Capture on Falling Edge  
   1952            * @param  TIM2_IC2Polarity: Specifies the IC2 Polarity.
   1953            *          This parameter can be one of the following values:
   1954            *            @arg TIM2_ICPolarity_Rising: Input Capture on Rising Edge
   1955            *            @arg TIM2_ICPolarity_Falling: Input Capture on Falling Edge  
   1956            * @retval None
   1957            */

   \                                 In section .far_func.text, align 1
   1958          void TIM2_EncoderInterfaceConfig(TIM2_EncoderMode_TypeDef TIM2_EncoderMode,
   1959                                           TIM2_ICPolarity_TypeDef TIM2_IC1Polarity,
   1960                                           TIM2_ICPolarity_TypeDef TIM2_IC2Polarity)
   1961          {
   \                     TIM2_EncoderInterfaceConfig:
   \   000000 B7 ..        LD        S:?b4, A
   1962            uint8_t tmpsmcr = 0;
   \   000002 3F ..        CLR       S:?b5
   1963            uint8_t tmpccmr1 = 0;
   \   000004 3F ..        CLR       S:?b2
   1964            uint8_t tmpccmr2 = 0;
   \   000006 3F ..        CLR       S:?b3
   1965          
   1966            /* Check the parameters */
   1967            assert_param(IS_TIM2_ENCODER_MODE(TIM2_EncoderMode));
   1968            assert_param(IS_TIM2_IC_POLARITY(TIM2_IC1Polarity));
   1969            assert_param(IS_TIM2_IC_POLARITY(TIM2_IC2Polarity));
   1970          
   1971            tmpsmcr = TIM2->SMCR;
   \   000008 C6 5252      LD        A, L:0x5252
   \   00000B B7 ..        LD        S:?b5, A
   1972            tmpccmr1 = TIM2->CCMR1;
   \   00000D C6 5259      LD        A, L:0x5259
   \   000010 B7 ..        LD        S:?b2, A
   1973            tmpccmr2 = TIM2->CCMR2;
   \   000012 C6 525A      LD        A, L:0x525a
   \   000015 B7 ..        LD        S:?b3, A
   1974          
   1975            /* Set the encoder Mode */
   1976            tmpsmcr &= (uint8_t)(TIM_SMCR_MSM | TIM_SMCR_TS)  ;
   \   000017 B6 ..        LD        A, S:?b5
   \   000019 A4 F0        AND       A, #0xf0
   \   00001B B7 ..        LD        S:?b5, A
   1977            tmpsmcr |= (uint8_t)TIM2_EncoderMode;
   \   00001D B6 ..        LD        A, S:?b4
   \   00001F BA ..        OR        A, S:?b5
   \   000021 B7 ..        LD        S:?b5, A
   1978          
   1979            /* Select the Capture Compare 1 and the Capture Compare 2 as input */
   1980            tmpccmr1 &= (uint8_t)(~TIM_CCMR_CCxS);
   \   000023 B6 ..        LD        A, S:?b2
   \   000025 A4 FC        AND       A, #0xfc
   \   000027 B7 ..        LD        S:?b2, A
   1981            tmpccmr2 &= (uint8_t)(~TIM_CCMR_CCxS);
   \   000029 B6 ..        LD        A, S:?b3
   \   00002B A4 FC        AND       A, #0xfc
   \   00002D B7 ..        LD        S:?b3, A
   1982            tmpccmr1 |= TIM_CCMR_TIxDirect_Set;
   \   00002F B6 ..        LD        A, S:?b2
   \   000031 AA 01        OR        A, #0x1
   \   000033 B7 ..        LD        S:?b2, A
   1983            tmpccmr2 |= TIM_CCMR_TIxDirect_Set;
   \   000035 B6 ..        LD        A, S:?b3
   \   000037 AA 01        OR        A, #0x1
   \   000039 B7 ..        LD        S:?b3, A
   1984          
   1985            /* Set the TI1 and the TI2 Polarities */
   1986            if (TIM2_IC1Polarity == TIM2_ICPolarity_Falling)
   \   00003B B6 ..        LD        A, S:?b0
   \   00003D A1 01        CP        A, #0x1
   \   00003F 26 06        JRNE      L:??TIM2_EncoderInterfaceConfig_0
   1987            {
   1988              TIM2->CCER1 |= TIM_CCER1_CC1P ;
   \   000041 7212 525B    BSET      L:0x525b, #0x1
   \   000045 20 04        JRA       L:??TIM2_EncoderInterfaceConfig_1
   1989            }
   1990            else
   1991            {
   1992              TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC1P) ;
   \                     ??TIM2_EncoderInterfaceConfig_0:
   \   000047 7213 525B    BRES      L:0x525b, #0x1
   1993            }
   1994          
   1995            if (TIM2_IC2Polarity == TIM2_ICPolarity_Falling)
   \                     ??TIM2_EncoderInterfaceConfig_1:
   \   00004B B6 ..        LD        A, S:?b1
   \   00004D A1 01        CP        A, #0x1
   \   00004F 26 06        JRNE      L:??TIM2_EncoderInterfaceConfig_2
   1996            {
   1997              TIM2->CCER1 |= TIM_CCER1_CC2P ;
   \   000051 721A 525B    BSET      L:0x525b, #0x5
   \   000055 20 04        JRA       L:??TIM2_EncoderInterfaceConfig_3
   1998            }
   1999            else
   2000            {
   2001              TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC2P) ;
   \                     ??TIM2_EncoderInterfaceConfig_2:
   \   000057 721B 525B    BRES      L:0x525b, #0x5
   2002            }
   2003          
   2004            TIM2->SMCR = tmpsmcr;
   \                     ??TIM2_EncoderInterfaceConfig_3:
   \   00005B B6 ..        LD        A, S:?b5
   \   00005D C7 5252      LD        L:0x5252, A
   2005            TIM2->CCMR1 = tmpccmr1;
   \   000060 B6 ..        LD        A, S:?b2
   \   000062 C7 5259      LD        L:0x5259, A
   2006            TIM2->CCMR2 = tmpccmr2;
   \   000065 B6 ..        LD        A, S:?b3
   \   000067 C7 525A      LD        L:0x525a, A
   2007          }
   \   00006A 87           RETF
   2008          
   2009          /**
   2010            * @brief  Enables or Disables the TIM’s Hall sensor interface.
   2011            * @param  NewState: The new state of the TIM2 Hall sensor interface.
   2012            *          This parameter can be ENABLE or DISABLE
   2013            * @retval None
   2014            */

   \                                 In section .far_func.text, align 1
   2015          void TIM2_SelectHallSensor(FunctionalState NewState)
   2016          {
   2017            /* Check the parameters */
   2018            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2019          
   2020            /* Set or Reset the TI1S Bit */
   2021            if (NewState != DISABLE)
   \                     TIM2_SelectHallSensor:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM2_SelectHallSensor_0
   2022            {
   2023              TIM2->CR2 |= TIM_CR2_TI1S;
   \   000003 721E 5251    BSET      L:0x5251, #0x7
   \   000007 87           RETF
   2024            }
   2025            else
   2026            {
   2027              TIM2->CR2 &= (uint8_t)(~TIM_CR2_TI1S);
   \                     ??TIM2_SelectHallSensor_0:
   \   000008 721F 5251    BRES      L:0x5251, #0x7
   2028            }
   2029          }
   \   00000C 87           RETF
   2030          
   2031          /**
   2032            * @}
   2033            */
   2034          
   2035          /**
   2036            * @brief  Configure the TI1 as Input.
   2037            * @param  TIM2_ICPolarity: Input Capture Polarity
   2038            *          This parameter can be one of the following values:
   2039            *            @arg TIM2_ICPolarity_Rising: Input Capture on Rising Edge
   2040            *            @arg TIM2_ICPolarity_Falling: Input Capture on Falling Edge  
   2041            * @param  TIM2_ICSelection: Specifies the input to be used.
   2042            *          This parameter can be one of the following values:
   2043            *            @arg TIM2_ICSelection_DirectTI: Input Capture mapped on the direct input
   2044            *            @arg TIM2_ICSelection_IndirectTI: Input Capture mapped on the indirect input
   2045            *            @arg TIM2_ICSelection_TRGI: Input Capture mapped on the Trigger Input   
   2046            * @param  TIM2_ICFilter: Specifies the Input Capture Filter.
   2047            *          This parameter must be a value between 0x00 and 0x0F.
   2048            * @retval None
   2049            */

   \                                 In section .far_func.text, align 1
   2050          static void TI1_Config(TIM2_ICPolarity_TypeDef TIM2_ICPolarity, \
   2051                                 TIM2_ICSelection_TypeDef TIM2_ICSelection, \
   2052                                 uint8_t TIM2_ICFilter)
   2053          {
   \                     TI1_Config:
   \   000000 B7 ..        LD        S:?b2, A
   2054            uint8_t tmpccmr1 = 0;
   \   000002 3F ..        CLR       S:?b3
   2055            uint8_t tmpicpolarity = TIM2_ICPolarity;
   2056            tmpccmr1 = TIM2->CCMR1;
   \   000004 C6 5259      LD        A, L:0x5259
   \   000007 B7 ..        LD        S:?b3, A
   2057          
   2058            /* Check the parameters */
   2059            assert_param(IS_TIM2_IC_POLARITY(TIM2_ICPolarity));
   2060            assert_param(IS_TIM2_IC_SELECTION(TIM2_ICSelection));
   2061            assert_param(IS_TIM2_IC_FILTER(TIM2_ICFilter));
   2062          
   2063            /* Disable the Channel 1: Reset the CCE Bit */
   2064            TIM2->CCER1 &=  (uint8_t)(~TIM_CCER1_CC1E);
   \   000009 7211 525B    BRES      L:0x525b, #0x0
   2065          
   2066            /* Select the Input and set the filter */
   2067            tmpccmr1 &= (uint8_t)(~TIM_CCMR_CCxS) & (uint8_t)(~TIM_CCMR_ICxF);
   \   00000D B6 ..        LD        A, S:?b3
   \   00000F A4 0C        AND       A, #0xc
   \   000011 B7 ..        LD        S:?b3, A
   2068            tmpccmr1 |= (uint8_t)(((uint8_t)(TIM2_ICSelection)) | ((uint8_t)(TIM2_ICFilter << 4)));
   \   000013 B6 ..        LD        A, S:?b1
   \   000015 4E           SWAP      A
   \   000016 A4 F0        AND       A, #0xf0
   \   000018 BA ..        OR        A, S:?b0
   \   00001A BA ..        OR        A, S:?b3
   \   00001C B7 ..        LD        S:?b3, A
   2069          
   2070            TIM2->CCMR1 = tmpccmr1;
   \   00001E B6 ..        LD        A, S:?b3
   \   000020 C7 5259      LD        L:0x5259, A
   2071          
   2072            /* Select the Polarity */
   2073            if (tmpicpolarity == (uint8_t)(TIM2_ICPolarity_Falling))
   \   000023 B6 ..        LD        A, S:?b2
   \   000025 A1 01        CP        A, #0x1
   \   000027 26 06        JRNE      L:??TI1_Config_0
   2074            {
   2075              TIM2->CCER1 |= TIM_CCER1_CC1P;
   \   000029 7212 525B    BSET      L:0x525b, #0x1
   \   00002D 20 04        JRA       L:??TI1_Config_1
   2076            }
   2077            else
   2078            {
   2079              TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC1P);
   \                     ??TI1_Config_0:
   \   00002F 7213 525B    BRES      L:0x525b, #0x1
   2080            }
   2081          
   2082            /* Set the CCE Bit */
   2083            TIM2->CCER1 |=  TIM_CCER1_CC1E;
   \                     ??TI1_Config_1:
   \   000033 7210 525B    BSET      L:0x525b, #0x0
   2084          }
   \   000037 87           RETF
   2085          
   2086          /**
   2087            * @brief  Configure the TI2 as Input.
   2088            * @param  TIM2_ICPolarity: Input Capture Polarity
   2089            *          This parameter can be one of the following values:
   2090            *            @arg TIM2_ICPolarity_Rising: Input Capture on Rising Edge
   2091            *            @arg TIM2_ICPolarity_Falling: Input Capture on Falling Edge  
   2092            * @param  TIM2_ICSelection: Specifies the input to be used.
   2093            *          This parameter can be one of the following values:
   2094            *            @arg TIM2_ICSelection_DirectTI: Input Capture mapped on the direct input
   2095            *            @arg TIM2_ICSelection_IndirectTI: Input Capture mapped on the indirect input
   2096            *            @arg TIM2_ICSelection_TRGI: Input Capture mapped on the Trigger Input   
   2097            * @param  TIM2_ICFilter: Specifies the Input Capture Filter.
   2098            *          This parameter must be a value between 0x00 and 0x0F.
   2099            * @retval None
   2100            */

   \                                 In section .far_func.text, align 1
   2101          static void TI2_Config(TIM2_ICPolarity_TypeDef TIM2_ICPolarity,
   2102                                 TIM2_ICSelection_TypeDef TIM2_ICSelection,
   2103                                 uint8_t TIM2_ICFilter)
   2104          {
   \                     TI2_Config:
   \   000000 B7 ..        LD        S:?b2, A
   2105            uint8_t tmpccmr2 = 0;
   \   000002 3F ..        CLR       S:?b3
   2106            uint8_t tmpicpolarity = TIM2_ICPolarity;
   2107          
   2108            /* Check the parameters */
   2109            assert_param(IS_TIM2_IC_POLARITY(TIM2_ICPolarity));
   2110            assert_param(IS_TIM2_IC_SELECTION(TIM2_ICSelection));
   2111            assert_param(IS_TIM2_IC_FILTER(TIM2_ICFilter));
   2112          
   2113            tmpccmr2 = TIM2->CCMR2;
   \   000004 C6 525A      LD        A, L:0x525a
   \   000007 B7 ..        LD        S:?b3, A
   2114          
   2115            /* Disable the Channel 2: Reset the CCE Bit */
   2116            TIM2->CCER1 &=  (uint8_t)(~TIM_CCER1_CC2E);
   \   000009 7219 525B    BRES      L:0x525b, #0x4
   2117          
   2118            /* Select the Input and set the filter */
   2119            tmpccmr2 &= (uint8_t)(~TIM_CCMR_CCxS) & (uint8_t)(~TIM_CCMR_ICxF);
   \   00000D B6 ..        LD        A, S:?b3
   \   00000F A4 0C        AND       A, #0xc
   \   000011 B7 ..        LD        S:?b3, A
   2120            tmpccmr2 |= (uint8_t)(((uint8_t)(TIM2_ICSelection)) | ((uint8_t)(TIM2_ICFilter << 4)));
   \   000013 B6 ..        LD        A, S:?b1
   \   000015 4E           SWAP      A
   \   000016 A4 F0        AND       A, #0xf0
   \   000018 BA ..        OR        A, S:?b0
   \   00001A BA ..        OR        A, S:?b3
   \   00001C B7 ..        LD        S:?b3, A
   2121          
   2122            TIM2->CCMR2 = tmpccmr2;
   \   00001E B6 ..        LD        A, S:?b3
   \   000020 C7 525A      LD        L:0x525a, A
   2123          
   2124            /* Select the Polarity */
   2125            if (tmpicpolarity == TIM2_ICPolarity_Falling)
   \   000023 B6 ..        LD        A, S:?b2
   \   000025 A1 01        CP        A, #0x1
   \   000027 26 06        JRNE      L:??TI2_Config_0
   2126            {
   2127              TIM2->CCER1 |= TIM_CCER1_CC2P ;
   \   000029 721A 525B    BSET      L:0x525b, #0x5
   \   00002D 20 04        JRA       L:??TI2_Config_1
   2128            }
   2129            else
   2130            {
   2131              TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC2P) ;
   \                     ??TI2_Config_0:
   \   00002F 721B 525B    BRES      L:0x525b, #0x5
   2132            }
   2133          
   2134            /* Set the CCE Bit */
   2135            TIM2->CCER1 |=  TIM_CCER1_CC2E;
   \                     ??TI2_Config_1:
   \   000033 7218 525B    BSET      L:0x525b, #0x4
   2136          }
   \   000037 87           RETF
   2137          
   2138          /**
   2139            * @}
   2140            */ 
   2141          
   2142          /**
   2143            * @}
   2144            */ 
   2145            
   2146          /**
   2147            * @}
   2148            */
   2149          
   2150          /**
   2151            * @}
   2152            */
   2153          
   2154          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Section sizes:

   Bytes  Function/Label
   -----  --------------
      56  TI1_Config
      56  TI2_Config
      13  TIM2_ARRPreloadConfig
      22  TIM2_BKRConfig
      31  TIM2_CCxCmd
      13  TIM2_ClearFlag
       5  TIM2_ClearITPendingBit
      13  TIM2_Cmd
      27  TIM2_CounterModeConfig
      13  TIM2_CtrlPWMOutputs
      19  TIM2_DMACmd
     101  TIM2_DeInit
      37  TIM2_ETRClockMode1Config
       9  TIM2_ETRClockMode2Config
      15  TIM2_ETRConfig
     107  TIM2_EncoderInterfaceConfig
      27  TIM2_ForcedOC1Config
      27  TIM2_ForcedOC2Config
       7  TIM2_GenerateEvent
      34  TIM2_GetCapture1
      34  TIM2_GetCapture2
      34  TIM2_GetCounter
      39  TIM2_GetFlagStatus
      41  TIM2_GetITStatus
       4  TIM2_GetPrescaler
      39  TIM2_ICInit
      19  TIM2_ITConfig
       9  TIM2_InternalClockConfig
      13  TIM2_OC1FastConfig
      93  TIM2_OC1Init
      14  TIM2_OC1PolarityConfig
      13  TIM2_OC1PreloadConfig
      13  TIM2_OC2FastConfig
      93  TIM2_OC2Init
      14  TIM2_OC2PolarityConfig
      13  TIM2_OC2PreloadConfig
     131  TIM2_PWMIConfig
      19  TIM2_PrescalerConfig
      13  TIM2_SelectCCDMA
      13  TIM2_SelectHallSensor
      27  TIM2_SelectInputTrigger
      13  TIM2_SelectMasterSlaveMode
      45  TIM2_SelectOCxM
      14  TIM2_SelectOnePulseMode
      27  TIM2_SelectOutputTrigger
      27  TIM2_SelectSlaveMode
      15  TIM2_SetAutoreload
      15  TIM2_SetCompare1
      15  TIM2_SetCompare2
      15  TIM2_SetCounter
      27  TIM2_SetIC1Prescaler
      27  TIM2_SetIC2Prescaler
      48  TIM2_TIxExternalClockConfig
      42  TIM2_TimeBaseInit
      13  TIM2_UpdateDisableConfig
      14  TIM2_UpdateRequestConfig

 
 1 677 bytes in section .far_func.text
 
 1 677 bytes of CODE memory

Errors: none
Warnings: none
