###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.42.1.142 for STM8               01/Jul/2016  17:30:49 #
# Copyright 2010-2013 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  E:\hwpro-2016\20160627_L\stm8l15x_lib\src\stm8l15x_rtc.c #
#    Command line =  E:\hwpro-2016\20160627_L\stm8l15x_lib\src\stm8l15x_rtc.c #
#                     -e -Ol --no_cse --no_unroll --no_inline                 #
#                    --no_code_motion --no_tbaa --no_cross_call --debug       #
#                    --code_model medium --data_model medium -o               #
#                    E:\hwpro-2016\20160627_L\iar\Debug\Obj\ --dlib_config    #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.5\stm8\LIB\dlstm8mmn.h" -D STM8L15X_MD -lC             #
#                    E:\hwpro-2016\20160627_L\iar\Debug\List\ -I              #
#                    E:\hwpro-2016\20160627_L\iar\..\stm8l15x_lib\inc\ -I     #
#                    E:\hwpro-2016\20160627_L\iar\..\user\inc\ -I             #
#                    E:\hwpro-2016\20160627_L\iar\..\utils\xprintf\ -I        #
#                    E:\hwpro-2016\20160627_L\iar\..\drivers\ -I              #
#                    E:\hwpro-2016\20160627_L\iar\..\utils\ -I                #
#                    E:\hwpro-2016\20160627_L\iar\..\app\ --vregs 16          #
#    List file    =  E:\hwpro-2016\20160627_L\iar\Debug\List\stm8l15x_rtc.lst #
#    Object file  =  E:\hwpro-2016\20160627_L\iar\Debug\Obj\stm8l15x_rtc.o    #
#                                                                             #
#                                                                             #
###############################################################################

E:\hwpro-2016\20160627_L\stm8l15x_lib\src\stm8l15x_rtc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm8l15x_rtc.c
      4            * @author  MCD Application Team
      5            * @version V1.6.1
      6            * @date    30-September-2014
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Real-Time Clock (RTC) peripheral:           
      9            *           - Initialization
     10            *           - Calendar (Time and Date) configuration
     11            *           - Alarm configuration
     12            *           - WakeUp Timer configuration
     13            *           - Daylight Saving configuration
     14            *           - Output pin Configuration
     15            *           - Smooth Calibration configuration
     16            *           - Tampers configuration
     17            *           - Output Type configuration
     18            *           - Interrupts and flags management       
     19            *                     
     20            *  @verbatim
     21            *       
     22            *          ===================================================================      
     23            *                                    RTC Domain Reset
     24            *          ===================================================================          
     25            *          After power-on reset, the RTC domain (RTC registers) is reset.        
     26            *         
     27            *          ===================================================================      
     28            *                                  RTC Operating Condition      
     29            *          ===================================================================            
     30            *          As long as the supply voltage remains in the operating range, 
     31            *          the RTC never stops, regardless of the device status (Run mode, 
     32            *          low power modes or under reset).
     33            *              
     34            *          ===================================================================      
     35            *                                   RTC Domain Access     
     36            *          ===================================================================         
     37            *          After reset, the RTC domain (RTC registers) is protected against 
     38            *          possible stray write accesses. 
     39            *          To enable access to the RTC registers, proceed as follows:
     40            *            - Select the RTC clock source using the CLK_RTCClockConfig()
     41            *              function : HSE, HSI, LSE or LSI.
     42            *              CLK_RTCClockConfig(CLK_RTCCLKSource_HSI, CLK_RTCCLKDiv_1)    
     43            *            - Enable RTC Clock using the CLK_PeripheralClockConfig() function 
     44            *               : CLK_PeripheralClockConfig(CLK_Peripheral_RTC, ENABLE).
     45            *              
     46            *          ===================================================================      
     47            *                                   RTC Driver: how to use it
     48            *          ===================================================================          
     49            *            - Enable the RTC domain access (see description in the section above)
     50            *            - Configure the RTC Prescaler (Asynchronous and Synchronous) and
     51            *              RTC hour format using the RTC_Init() function.
     52            *                
     53            *          Time and Date configuration
     54            *          ===========================    
     55            *            - To configure the RTC Calendar (Time and Date) use the RTC_SetTime()
     56            *              and RTC_SetDate() functions.
     57            *            - To read the RTC Calendar, use the RTC_GetTime() and RTC_GetDate()
     58            *              functions.
     59            *            - Use the RTC_DayLightSavingConfig() function to add or sub 1hour
     60            *              to the RTC Calendar.    
     61            *                
     62            *          Alarm configuration
     63            *          ===================    
     64            *            - To configure the RTC Alarm use the RTC_SetAlarm() function.
     65            *            - Enable the selected RTC Alarm using the RTC_AlarmCmd() function  
     66            *            - To read the RTC Alarm, use the RTC_GetAlarm() function.
     67            *              
     68            *          RTC Wakeup configuration
     69            *          ========================    
     70            *            - Configure the RTC Wakeup Clock source use the RTC_WakeUpClockConfig()
     71            *              function.
     72            *            - Configure the RTC WakeUp Counter using the RTC_SetWakeUpCounter() 
     73            *              function  
     74            *            - Enable the RTC WakeUp using the RTC_WakeUpCmd() function  
     75            *            - To read the RTC WakeUp Counter register, use the RTC_GetWakeUpCounter() 
     76            *              function.
     77            *                
     78            *          Outputs configuration
     79            *          =====================  
     80            *          The RTC has 2 different outputs:
     81            *            - AFO_ALARM: this output is used to manage the RTC Alarm and 
     82            *              WaKeUp signals.          
     83            *              To output the selected RTC signal on RTC_ALARM pin, use the 
     84            *              RTC_OutputConfig() function.                
     85            *            - AFO_CALIB: this output is used to manage the RTC Clock divided 
     86            *              by 64 (512Hz) signal or divided by 32768 (1Hz) which can be 
     87            *              configured using RTC_CalibOutputConfig() function.
     88            *              To output the RTC Clock on RTC_CALIB pin, use the 
     89            *              RTC_CalibOutputCmd() function.                
     90            *                                                           
     91            *          Smooth Calibration configuration                    
     92            *          =================================    
     93            *            - Configure the RTC Smooth Calibration Value and the corresponding
     94            *              sign using the RTC_SmoothCalibConfig() function.
     95          
     96            *                
     97            *
     98            *          Tamper configuration                     
     99            *          ====================    
    100            *            - Configure the RTC Tamper Level using the RTC_TamperConfig() 
    101            *              function.
    102            *            - Enable the RTC Tamper using the RTC_TamperCmd() function.
    103            *
    104            *                                  
    105            *          ===================================================================      
    106            *                                  RTC and low power modes
    107            *          =================================================================== 
    108            *           The MCU can be woken up from a low power mode by an RTC alternate 
    109            *           function.
    110            *           The RTC alternate functions are the RTC alarms, 
    111            *           RTC wakeup and RTC tamper event detection.
    112            *           These RTC alternate functions can wake up the system from the 
    113            *           lowpower modes.
    114            *           The system can also wake up from low power modes without depending 
    115            *           on an external interrupt (Auto-wakeup mode), by using the RTC alarm 
    116            *           or the RTC wakeup events.
    117            *           The RTC provides a programmable time base for waking up from the 
    118            *           halt or wfe or wfi modes at regular intervals.
    119            *           
    120            *                         
    121            *  @endverbatim
    122            *                      
    123            ******************************************************************************
    124            * @attention
    125            *
    126            * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
    127            *
    128            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
    129            * You may not use this file except in compliance with the License.
    130            * You may obtain a copy of the License at:
    131            *
    132            *        http://www.st.com/software_license_agreement_liberty_v2
    133            *
    134            * Unless required by applicable law or agreed to in writing, software 
    135            * distributed under the License is distributed on an "AS IS" BASIS, 
    136            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    137            * See the License for the specific language governing permissions and
    138            * limitations under the License.
    139            *
    140            ******************************************************************************
    141            */    
    142          
    143          /* Includes ------------------------------------------------------------------*/
    144          #include "stm8l15x_rtc.h"
    145          
    146          /** @addtogroup STM8L15x_StdPeriph_Driver
    147            * @{
    148            */
    149            
    150          /** @defgroup RTC 
    151            * @brief RTC driver modules
    152            * @{
    153            */
    154            
    155          /* Private typedef -----------------------------------------------------------*/
    156          /* Private define ------------------------------------------------------------*/
    157          #define INIT_TIMEOUT       ((uint16_t)0xFFFF)
    158          #define RSF_TIMEOUT        ((uint16_t)0xFFFF)
    159          #define INITF_TIMEOUT      ((uint16_t)0xFFFF)
    160          #define WUTWF_TIMEOUT      ((uint16_t)0xFFFF)
    161          #define ALRAWF_TIMEOUT     ((uint16_t)0xFFFF)
    162          #define RECALPF_TIMEOUT    ((uint16_t)0xFFFF)
    163          #define SHPF_TIMEOUT       ((uint16_t)0xFFFF)
    164          
    165          #define TEN_VALUE_BCD      ((uint8_t)0x10)
    166          #define TEN_VALUE_BIN      ((uint8_t)0x0A)
    167          
    168          /* Private macro -------------------------------------------------------------*/
    169          /* Private variables ---------------------------------------------------------*/
    170          
    171          /** @defgroup RTC_Private_Functions_Prototype
    172            * @{
    173            */
    174          static uint8_t ByteToBcd2(uint8_t Value);
    175          static uint8_t Bcd2ToByte(uint8_t Value);
    176          
    177          /**
    178           * @}
    179           */
    180          
    181          /** @defgroup RTC_Private_Functions
    182            * @{
    183            */
    184          
    185          /** @defgroup RTC_Group1 Initialization and Configuration functions
    186           *  @brief   Initialization and Configuration functions 
    187           *
    188          @verbatim   
    189           ===============================================================================
    190                           Initialization and Configuration functions
    191           ===============================================================================  
    192          
    193            This section provide functions allowing to initialize and configure the RTC
    194            Prescaler (Synchronous and Asynchronous), RTC Hour format, disable RTC registers
    195            Write protection, enter and exit the RTC initialization mode, RTC registers
    196            synchronization check and reference clock detection enable.
    197            
    198            1. The RTC Prescaler is programmed to generate the RTC 1Hz time base. It is
    199               split into 2 programmable prescaler to minimize power consumption.
    200               - A 7-bit asynchronous prescaler and A 13-bit or 15-bit synchronous 
    201                 prescaler depending to density of the mcu package.
    202               - When both prescaler are used, it is recommended to configure the 
    203                 asynchronous prescaler to a high value to minimize consumption.
    204          
    205            2. All RTC registers are Write protected. Writing to the RTC registers
    206               is enabled by writing a key into the Write Protection register, RTC_WPR.
    207          
    208            3. To Configure the RTC Calendar, user application should enter initialization
    209               mode. In this mode, the Calendar counter is stopped and its value can be 
    210               updated. When the initialization sequence is complete, the Calendar restarts 
    211               counting after 4 RTCCLK cycles.
    212          
    213            4. To read the Calendar through the shadow registers after Calendar initialization,
    214               Calendar update or after wakeup from low power modes the software must first 
    215               clear the RSF flag. The software must then wait until it is set again before 
    216               reading the Calendar, which means that the Calendar registers have been 
    217               correctly copied into the RTC_TR and RTC_DR shadow registers.
    218               The RTC_WaitForSynchro() function implements the above software sequence 
    219               (RSF clear and RSF check).
    220          
    221          @endverbatim
    222            * @{
    223            */
    224          /**
    225          * @brief  Deinitializes the RTC registers to their default reset values.
    226          * @note   This function doesn't reset the RTC Clock source.  
    227          * @param  None
    228          * @retval An ErrorStatus enumeration value:
    229          *          - SUCCESS: RTC registers are deinitialized
    230          *          - ERROR: RTC registers are not deinitialized
    231          */

   \                                 In section .far_func.text, align 1
    232          ErrorStatus RTC_DeInit(void)
    233          {
    234            ErrorStatus status = ERROR;
   \                     RTC_DeInit:
   \   000000 3F ..        CLR       S:?b2
    235            uint16_t wutwfcount = 0;
   \   000002 3F ..        CLR       S:?b1
   \   000004 3F ..        CLR       S:?b0
    236            uint16_t recalpfcount = 0;
   \   000006 905F         CLRW      Y
    237          
    238            /* Disable the write protection for RTC registers */
    239            RTC->WPR = 0xCA;
   \   000008 35 CA 5159   MOV       L:0x5159, #0xca
    240            RTC->WPR = 0x53;
   \   00000C 35 53 5159   MOV       L:0x5159, #0x53
    241          
    242            /* Set Initialization mode */
    243            if (RTC_EnterInitMode() == ERROR)
   \   000010 8D ......    CALLF     RTC_EnterInitMode
   \   000014 A1 00        CP        A, #0x0
   \   000016 26 09        JRNE      L:??RTC_DeInit_0
    244            {
    245              status = ERROR;
   \   000018 3F ..        CLR       S:?b2
    246              /* Enable the write protection for RTC registers */
    247              RTC->WPR = 0xFF; 
   \   00001A 35 FF 5159   MOV       L:0x5159, #0xff
   \   00001E CC ....      JP        L:??RTC_DeInit_1
    248            }
    249            else
    250            {
    251              /* Reset TR registers */
    252              RTC->TR1 = RTC_TR1_RESET_VALUE;
   \                     ??RTC_DeInit_0:
   \   000021 35 00 5140   MOV       L:0x5140, #0x0
    253              RTC->TR2 = RTC_TR2_RESET_VALUE;
   \   000025 35 00 5141   MOV       L:0x5141, #0x0
    254              RTC->TR3 = RTC_TR3_RESET_VALUE;
   \   000029 35 00 5142   MOV       L:0x5142, #0x0
    255          
    256              /* Reset DR registers */
    257              RTC->DR1 = RTC_DR1_RESET_VALUE;
   \   00002D 35 01 5144   MOV       L:0x5144, #0x1
    258              RTC->DR2 = RTC_DR2_RESET_VALUE;
   \   000031 35 21 5145   MOV       L:0x5145, #0x21
    259              RTC->DR3 = RTC_DR3_RESET_VALUE;
   \   000035 35 00 5146   MOV       L:0x5146, #0x0
    260          
    261              /* Reset SPER & ARPER registers */
    262              RTC->SPRERH = RTC_SPRERH_RESET_VALUE;
   \   000039 35 00 5150   MOV       L:0x5150, #0x0
    263              RTC->SPRERL = RTC_SPRERL_RESET_VALUE;
   \   00003D 35 FF 5151   MOV       L:0x5151, #0xff
    264              RTC->APRER  = RTC_APRER_RESET_VALUE;
   \   000041 35 7F 5152   MOV       L:0x5152, #0x7f
    265          
    266              RTC->TCR1 = RTC_TCR1_RESET_VALUE;
   \   000045 35 00 516C   MOV       L:0x516c, #0x0
    267              RTC->TCR2 = RTC_TCR2_RESET_VALUE;
   \   000049 35 00 516D   MOV       L:0x516d, #0x0
    268          
    269              /* Reset All CR1 bits except CR1[2:0] */
    270          
    271              RTC->CR1 = RTC_CR1_RESET_VALUE;
   \   00004D 35 00 5148   MOV       L:0x5148, #0x0
    272              RTC->CR2 = RTC_CR2_RESET_VALUE;
   \   000051 35 00 5149   MOV       L:0x5149, #0x0
    273              RTC->CR3 = RTC_CR3_RESET_VALUE;
   \   000055 35 00 514A   MOV       L:0x514a, #0x0
   \   000059 20 09        JRA       L:??RTC_DeInit_2
    274          
    275              /* Wait till RTC WUTWF flag is set or if Time out is reached exit */
    276              while (((RTC->ISR1 & RTC_ISR1_WUTWF) == RESET) && ( wutwfcount != WUTWF_TIMEOUT))
    277              {
    278                wutwfcount++;
   \                     ??RTC_DeInit_3:
   \   00005B BE ..        LDW       X, S:?w0
   \   00005D 5C           INCW      X
   \   00005E BF ..        LDW       S:?w0, X
    279                RTC->ISR1 = 0;
   \   000060 35 00 514C   MOV       L:0x514c, #0x0
    280              }
   \                     ??RTC_DeInit_2:
   \   000064 7204 514C 07 BTJT      L:0x514c, #0x2, L:??RTC_DeInit_4
   \   000069 BE ..        LDW       X, S:?w0
   \   00006B A3 FFFF      CPW       X, #0xffff
   \   00006E 26 EB        JRNE      L:??RTC_DeInit_3
    281          
    282              if ((RTC->ISR1 & RTC_ISR1_WUTWF) == RESET)
   \                     ??RTC_DeInit_4:
   \   000070 7204 514C 08 BTJT      L:0x514c, #0x2, L:??RTC_DeInit_5
    283              {
    284                status = ERROR;
   \   000075 3F ..        CLR       S:?b2
    285                /* Enable the write protection for RTC registers */
    286                RTC->WPR = 0xFF; 
   \   000077 35 FF 5159   MOV       L:0x5159, #0xff
   \   00007B 20 6B        JRA       L:??RTC_DeInit_1
    287              }
    288              else
    289              {
    290                /* Reset All CR1 bits */
    291                RTC->CR1 = RTC_CR1_RESET_VALUE;
   \                     ??RTC_DeInit_5:
   \   00007D 35 00 5148   MOV       L:0x5148, #0x0
    292          
    293                /* Reset WUTR registers */
    294                RTC->WUTRH = RTC_WUTRH_RESET_VALUE;
   \   000081 35 FF 5154   MOV       L:0x5154, #0xff
    295                RTC->WUTRL = RTC_WUTRL_RESET_VALUE;
   \   000085 35 FF 5155   MOV       L:0x5155, #0xff
    296          
    297                /* Reset ALARM registers */
    298                RTC->ALRMAR1 = RTC_ALRMAR1_RESET_VALUE;
   \   000089 35 00 515C   MOV       L:0x515c, #0x0
    299                RTC->ALRMAR2 = RTC_ALRMAR2_RESET_VALUE;
   \   00008D 35 00 515D   MOV       L:0x515d, #0x0
    300                RTC->ALRMAR3 = RTC_ALRMAR3_RESET_VALUE;
   \   000091 35 00 515E   MOV       L:0x515e, #0x0
    301                RTC->ALRMAR4 = RTC_ALRMAR4_RESET_VALUE;
   \   000095 35 00 515F   MOV       L:0x515f, #0x0
    302          
    303                RTC->ALRMASSRH = RTC_ALRMASSRH_RESET_VALUE;
   \   000099 35 00 5164   MOV       L:0x5164, #0x0
    304                RTC->ALRMASSRL = RTC_ALRMASSRL_RESET_VALUE;
   \   00009D 35 00 5165   MOV       L:0x5165, #0x0
    305                RTC->ALRMASSMSKR = RTC_ALRMASSMSKR_RESET_VALUE;
   \   0000A1 35 00 5166   MOV       L:0x5166, #0x0
    306          
    307                /* Reset ISR register and exit initialization mode */
    308                RTC->ISR1 = (uint8_t)0x00;
   \   0000A5 35 00 514C   MOV       L:0x514c, #0x0
    309                RTC->ISR2 = RTC_ISR2_RESET_VALUE;
   \   0000A9 35 00 514D   MOV       L:0x514d, #0x0
    310          
    311                if ((RTC->ISR1 & RTC_ISR1_RECALPF) != RESET)
   \   0000AD 7202 514C 06 BTJT      L:0x514c, #0x1, L:??RTC_DeInit_6
   \   0000B2 20 0F        JRA       L:??RTC_DeInit_7
    312                {
    313                  while (((RTC->ISR1 & RTC_ISR1_RECALPF) != RESET) && (recalpfcount != RECALPF_TIMEOUT))
    314                  {
    315                    recalpfcount++;
   \                     ??RTC_DeInit_8:
   \   0000B4 93           LDW       X, Y
   \   0000B5 5C           INCW      X
   \   0000B6 9093         LDW       Y, X
    316                  }
   \                     ??RTC_DeInit_6:
   \   0000B8 7203 514C 06 BTJF      L:0x514c, #0x1, L:??RTC_DeInit_7
   \   0000BD 90A3 FFFF    CPW       Y, #0xffff
   \   0000C1 26 F1        JRNE      L:??RTC_DeInit_8
    317                }
    318                if ((RTC->ISR1 & RTC_ISR1_RECALPF) == RESET)
   \                     ??RTC_DeInit_7:
   \   0000C3 7202 514C 1A BTJT      L:0x514c, #0x1, L:??RTC_DeInit_9
    319                {
    320                  RTC->CALRH = RTC_CALRH_RESET_VALUE;
   \   0000C8 35 00 516A   MOV       L:0x516a, #0x0
    321                  RTC->CALRL = RTC_CALRL_RESET_VALUE;
   \   0000CC 35 00 516B   MOV       L:0x516b, #0x0
    322          
    323                  if (RTC_WaitForSynchro() == ERROR)
   \   0000D0 8D ......    CALLF     RTC_WaitForSynchro
   \   0000D4 A1 00        CP        A, #0x0
   \   0000D6 26 04        JRNE      L:??RTC_DeInit_10
    324                  {
    325                    status = ERROR;
   \   0000D8 3F ..        CLR       S:?b2
   \   0000DA 20 08        JRA       L:??RTC_DeInit_11
    326                  }
    327                  else
    328                  {
    329                    status = SUCCESS;
   \                     ??RTC_DeInit_10:
   \   0000DC 35 01 ....   MOV       S:?b2, #0x1
   \   0000E0 20 02        JRA       L:??RTC_DeInit_11
    330                  }
    331                }
    332                else
    333                {
    334                  status = ERROR;
   \                     ??RTC_DeInit_9:
   \   0000E2 3F ..        CLR       S:?b2
    335                }
    336          
    337                /* Enable the write protection for RTC registers */
    338                RTC->WPR = 0xFF; 
   \                     ??RTC_DeInit_11:
   \   0000E4 35 FF 5159   MOV       L:0x5159, #0xff
    339              }
    340            }
    341          
    342            /* return Deinitialize RTC registers status*/
    343            return (ErrorStatus)status;
   \                     ??RTC_DeInit_1:
   \   0000E8 B6 ..        LD        A, S:?b2
   \   0000EA 87           RETF
    344          }
    345          
    346          
    347          
    348          /**
    349          * @brief  Initializes the RTC registers according to the specified parameters
    350          *         in RTC_InitStruct.
    351          * @param  RTC_InitStruct: pointer to a RTC_InitTypeDef structure that contains
    352          *         the configuration information for the RTC peripheral.
    353          * @note   The RTC Prescaler register is write protected and can be written in 
    354          *         initialization mode only.  
    355          * @retval An ErrorStatus enumeration value:
    356          *          - SUCCESS: RTC registers are initialized
    357          *          - ERROR: RTC registers are not initialized
    358          */

   \                                 In section .far_func.text, align 1
    359          ErrorStatus RTC_Init(RTC_InitTypeDef* RTC_InitStruct)
    360          {
   \                     RTC_Init:
   \   000000 9093         LDW       Y, X
    361            ErrorStatus status = ERROR;
   \   000002 3F ..        CLR       S:?b0
    362          
    363            /* Check the parameters */
    364            assert_param(IS_RTC_HOUR_FORMAT(RTC_InitStruct->RTC_HourFormat));
    365            assert_param(IS_RTC_ASYNCH_PREDIV(RTC_InitStruct->RTC_AsynchPrediv));
    366            assert_param(IS_RTC_SYNCH_PREDIV(RTC_InitStruct->RTC_SynchPrediv));
    367          
    368            /* Disable the write protection for RTC registers */
    369            RTC->WPR = 0xCA;
   \   000004 35 CA 5159   MOV       L:0x5159, #0xca
    370            RTC->WPR = 0x53;
   \   000008 35 53 5159   MOV       L:0x5159, #0x53
    371          
    372            /* Set Initialization mode */
    373            if (RTC_EnterInitMode() == ERROR)
   \   00000C 8D ......    CALLF     RTC_EnterInitMode
   \   000010 A1 00        CP        A, #0x0
   \   000012 26 04        JRNE      L:??RTC_Init_0
    374            {
    375              status = ERROR;
   \   000014 3F ..        CLR       S:?b0
   \   000016 20 2E        JRA       L:??RTC_Init_1
    376            }
    377            else
    378            {
    379              /* Clear the bits to be configured first */
    380              RTC->CR1 &= ((uint8_t)~( RTC_CR1_FMT ));
   \                     ??RTC_Init_0:
   \   000018 721D 5148    BRES      L:0x5148, #0x6
    381          
    382              /* Set RTC_CR1 register */
    383              RTC->CR1 |=  ((uint8_t)(RTC_InitStruct->RTC_HourFormat));
   \   00001C 90F6         LD        A, (Y)
   \   00001E CA 5148      OR        A, L:0x5148
   \   000021 C7 5148      LD        L:0x5148, A
    384          
    385              /* Set Prescalers registers */
    386              RTC->SPRERH = (uint8_t)(RTC_InitStruct->RTC_SynchPrediv >> 8);
   \   000024 93           LDW       X, Y
   \   000025 1C 0002      ADDW      X, #0x2
   \   000028 FE           LDW       X, (X)
   \   000029 4F           CLR       A
   \   00002A 01           RRWA      X, A
   \   00002B 9F           LD        A, XL
   \   00002C C7 5150      LD        L:0x5150, A
    387              RTC->SPRERL = (uint8_t)(RTC_InitStruct->RTC_SynchPrediv);
   \   00002F 93           LDW       X, Y
   \   000030 1C 0002      ADDW      X, #0x2
   \   000033 FE           LDW       X, (X)
   \   000034 9F           LD        A, XL
   \   000035 C7 5151      LD        L:0x5151, A
    388              RTC->APRER =  (uint8_t)(RTC_InitStruct->RTC_AsynchPrediv);
   \   000038 93           LDW       X, Y
   \   000039 5C           INCW      X
   \   00003A F6           LD        A, (X)
   \   00003B C7 5152      LD        L:0x5152, A
    389          
    390              /* Exit Initialization mode */
    391              RTC->ISR1 &= (uint8_t)~RTC_ISR1_INIT;
   \   00003E 721F 514C    BRES      L:0x514c, #0x7
    392          
    393              status = SUCCESS;
   \   000042 35 01 ....   MOV       S:?b0, #0x1
    394            }
    395          
    396            /* Enable the write protection for RTC registers */
    397            RTC->WPR = 0xFF; 
   \                     ??RTC_Init_1:
   \   000046 35 FF 5159   MOV       L:0x5159, #0xff
    398          
    399            /* return Initialize the RTC registers status*/
    400            return (ErrorStatus)(status);
   \   00004A B6 ..        LD        A, S:?b0
   \   00004C 87           RETF
    401          }
    402          
    403          /**
    404          * @brief  Fills each RTC_InitStruct member with its default value
    405          *         Hour format = 24h / Prescalers configured to their reset values.
    406          * @param  RTC_InitStruct: pointer to a RTC_InitTypeDef structure which will be
    407          *         initialized.
    408          * @retval None
    409          */

   \                                 In section .far_func.text, align 1
    410          void RTC_StructInit(RTC_InitTypeDef* RTC_InitStruct)
    411          {
    412            /* Initialize the RTC_Hourformat member */
    413            RTC_InitStruct->RTC_HourFormat = RTC_HourFormat_24;
   \                     RTC_StructInit:
   \   000000 4F           CLR       A
   \   000001 F7           LD        (X), A
    414          
    415            /* Initialize the RTC_AsynchPrediv member */
    416            RTC_InitStruct->RTC_AsynchPrediv = RTC_APRER_RESET_VALUE;
   \   000002 9093         LDW       Y, X
   \   000004 905C         INCW      Y
   \   000006 A6 7F        LD        A, #0x7f
   \   000008 90F7         LD        (Y), A
    417          
    418            /* Initialize the RTC_SynchPrediv member */
    419            RTC_InitStruct->RTC_SynchPrediv = RTC_SPRERL_RESET_VALUE;
   \   00000A 1C 0002      ADDW      X, #0x2
   \   00000D 90AE 00FF    LDW       Y, #0xff
   \   000011 FF           LDW       (X), Y
    420          }
   \   000012 87           RETF
    421          
    422          /**
    423          * @brief  Enables or disables the RTC registers write protection.
    424          * @param  NewState: new state of the write protection.
    425            *         This parameter can be: ENABLE or DISABLE.
    426          * @note   Writing a wrong key reactivates the write protection.
    427          * @note   The protection mechanism is not affected by system reset.  
    428          * @retval None
    429          */

   \                                 In section .far_func.text, align 1
    430          void RTC_WriteProtectionCmd(FunctionalState NewState)
    431          {
    432            /* Check the parameters */
    433            assert_param(IS_FUNCTIONAL_STATE(NewState));
    434          
    435            if (NewState != DISABLE)
   \                     RTC_WriteProtectionCmd:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??RTC_WriteProtectionCmd_0
    436            {
    437              /* Enable the write protection for RTC registers */
    438              RTC->WPR = RTC_WPR_EnableKey;
   \   000003 35 FF 5159   MOV       L:0x5159, #0xff
   \   000007 87           RETF
    439            }
    440            else
    441            {
    442              /* Disable the write protection for RTC registers */
    443              RTC->WPR = RTC_WPR_DisableKey1;
   \                     ??RTC_WriteProtectionCmd_0:
   \   000008 35 CA 5159   MOV       L:0x5159, #0xca
    444              RTC->WPR = RTC_WPR_DisableKey2;
   \   00000C 35 53 5159   MOV       L:0x5159, #0x53
    445            }
    446          }
   \   000010 87           RETF
    447          
    448          
    449          /**
    450          * @brief  Enters the RTC Initialization mode.
    451          * @note   The RTC Initialization mode is write protected, use the 
    452          *         RTC_WriteProtectionCmd(DISABLE) before calling this function. 
    453          * @param  None
    454          * @retval An ErrorStatus enumeration value:
    455          *          - SUCCESS: RTC is in Init mode
    456          *          - ERROR: RTC is not in Init mode
    457          */

   \                                 In section .far_func.text, align 1
    458          ErrorStatus RTC_EnterInitMode(void)
    459          {
    460            ErrorStatus status = ERROR;
   \                     RTC_EnterInitMode:
   \   000000 4F           CLR       A
    461            uint16_t initfcount = 0;
   \   000001 5F           CLRW      X
    462          
    463            /* Check if the Initialization mode is set */
    464            if ((RTC->ISR1 & RTC_ISR1_INITF) == RESET)
   \   000002 720C 514C 11 BTJT      L:0x514c, #0x6, L:??RTC_EnterInitMode_0
    465            {
    466              /* Set the Initialization mode */
    467              RTC->ISR1 = (uint8_t)RTC_ISR1_INIT;
   \   000007 35 80 514C   MOV       L:0x514c, #0x80
   \   00000B 20 01        JRA       L:??RTC_EnterInitMode_1
    468          
    469              /* Wait until INITF flag is set */
    470              while (((RTC->ISR1 & RTC_ISR1_INITF) == RESET) && ( initfcount != INITF_TIMEOUT))
    471              {
    472                initfcount++;
   \                     ??RTC_EnterInitMode_2:
   \   00000D 5C           INCW      X
    473              }
   \                     ??RTC_EnterInitMode_1:
   \   00000E 720C 514C 05 BTJT      L:0x514c, #0x6, L:??RTC_EnterInitMode_0
   \   000013 A3 FFFF      CPW       X, #0xffff
   \   000016 26 F5        JRNE      L:??RTC_EnterInitMode_2
    474            }
    475          
    476            if ((RTC->ISR1 & RTC_ISR1_INITF) == RESET)
   \                     ??RTC_EnterInitMode_0:
   \   000018 720C 514C 02 BTJT      L:0x514c, #0x6, L:??RTC_EnterInitMode_3
    477            {
    478              status = ERROR;
   \   00001D 4F           CLR       A
   \   00001E 87           RETF
    479            }
    480            else
    481            {
    482              status = SUCCESS;
   \                     ??RTC_EnterInitMode_3:
   \   00001F A6 01        LD        A, #0x1
    483            }
    484          
    485            return (ErrorStatus)status;
   \   000021 87           RETF
    486          }
    487          
    488          
    489          /**
    490          * @brief  Exits the RTC Initialization mode.
    491          * @note   When the initialization sequence is complete, the Calendar restarts 
    492          *         counting after 4 RTCCLK cycles.  
    493          * @note   The RTC Initialization mode is write protected, use the 
    494          *         RTC_WriteProtectionCmd(DISABLE) before calling this function.     
    495          * @param  None
    496          * @retval None
    497          */

   \                                 In section .far_func.text, align 1
    498          void RTC_ExitInitMode(void)
    499          {
    500            /* Exit Initialization mode */
    501            RTC->ISR1 &= (uint8_t)~RTC_ISR1_INIT;
   \                     RTC_ExitInitMode:
   \   000000 721F 514C    BRES      L:0x514c, #0x7
    502          }
   \   000004 87           RETF
    503          
    504          
    505          /**
    506          * @brief  Waits until the RTC Calendar registers (Time and Date)
    507          *         are synchronized with RTC clock.
    508          * @note   This function is meaningless when BYPASS feature is enabled in RTC_CR1
    509          *         register.
    510          * @note   To read the Calendar through the shadow registers after Calendar 
    511          *         initialization, Calendar update or after wakeup from low power modes 
    512          *         the software must first clear the RSF flag. 
    513          *         The software must then wait until it is set again before reading 
    514          *         the Calendar (if not yet done), which means that the Calendar registers
    515          *         have been correctly copied into the RTC_TRx and RTC_DRx shadow registers.
    516          * @note   RTC_SetTime() and RTC_SetDate() functions call RTC_WaitForSynchro() function
    517          *         after updating the Calendar. In Run mode, User can use RTC_GetDate(), 
    518          *         RTC_GetTime() and/or RTC_GetSubSecond() without need to call 
    519          *         RTC_WaitForSynchro() function. After waking up from low power mode, this 
    520          *         function must be called before calling RTC_GetDate(), RTC_GetTime() or 
    521          *         RTC_GetSubSecond() functions.   
    522          * @param  None
    523          * @retval An ErrorStatus enumeration value:
    524          *          - SUCCESS: RTC registers are synchronized
    525          *          - ERROR: RTC registers are not synchronized
    526          */

   \                                 In section .far_func.text, align 1
    527          ErrorStatus RTC_WaitForSynchro(void)
    528          {
    529            uint16_t rsfcount = 0;
   \                     RTC_WaitForSynchro:
   \   000000 5F           CLRW      X
    530            ErrorStatus status = ERROR;
   \   000001 3F ..        CLR       S:?b0
    531            
    532            /* Disable the write protection for RTC registers */
    533            RTC->WPR = 0xCA;
   \   000003 35 CA 5159   MOV       L:0x5159, #0xca
    534            RTC->WPR = 0x53;
   \   000007 35 53 5159   MOV       L:0x5159, #0x53
    535          
    536            /* Clear RSF flag by writing 0 in RSF bit  */
    537            RTC->ISR1 &= (uint8_t)~(RTC_ISR1_RSF | RTC_ISR1_INIT);
   \   00000B C6 514C      LD        A, L:0x514c
   \   00000E A4 5F        AND       A, #0x5f
   \   000010 C7 514C      LD        L:0x514c, A
   \   000013 20 01        JRA       L:??RTC_WaitForSynchro_0
    538          
    539            /* Wait the registers to be synchronised */
    540            while (((RTC->ISR1 & RTC_ISR1_RSF) == RESET) && ( rsfcount != RSF_TIMEOUT))
    541            {
    542              rsfcount++;
   \                     ??RTC_WaitForSynchro_1:
   \   000015 5C           INCW      X
    543            }
   \                     ??RTC_WaitForSynchro_0:
   \   000016 720A 514C 05 BTJT      L:0x514c, #0x5, L:??RTC_WaitForSynchro_2
   \   00001B A3 FFFF      CPW       X, #0xffff
   \   00001E 26 F5        JRNE      L:??RTC_WaitForSynchro_1
    544          
    545            /* Check if RSF flag occurs*/
    546            if ((RTC->ISR1 & RTC_ISR1_RSF) != RESET)
   \                     ??RTC_WaitForSynchro_2:
   \   000020 720B 514C 06 BTJF      L:0x514c, #0x5, L:??RTC_WaitForSynchro_3
    547            {
    548              status = SUCCESS;
   \   000025 35 01 ....   MOV       S:?b0, #0x1
   \   000029 20 02        JRA       L:??RTC_WaitForSynchro_4
    549            }
    550            else
    551            {
    552              status = ERROR;
   \                     ??RTC_WaitForSynchro_3:
   \   00002B 3F ..        CLR       S:?b0
    553            }
    554          
    555            /* Enable the write protection for RTC registers */
    556            RTC->WPR = 0xFF; 
   \                     ??RTC_WaitForSynchro_4:
   \   00002D 35 FF 5159   MOV       L:0x5159, #0xff
    557            
    558            return (ErrorStatus)status;
   \   000031 B6 ..        LD        A, S:?b0
   \   000033 87           RETF
    559          }
    560          
    561          
    562          /**
    563          * @brief  Enables or Disables the RTC Ratio.
    564          * @param  NewState: new state of the Ratio feature.
    565            *         This parameter can be: ENABLE or DISABLE.
    566          * @retval None
    567          */

   \                                 In section .far_func.text, align 1
    568          void RTC_RatioCmd(FunctionalState NewState)
    569          {
    570            /* Check the parameters */
    571            assert_param(IS_FUNCTIONAL_STATE(NewState));
    572          
    573            /* Disable the write protection for RTC registers */
    574            RTC->WPR = 0xCA;
   \                     RTC_RatioCmd:
   \   000000 35 CA 5159   MOV       L:0x5159, #0xca
    575            RTC->WPR = 0x53;
   \   000004 35 53 5159   MOV       L:0x5159, #0x53
    576          
    577            if (NewState != DISABLE)
   \   000008 4D           TNZ       A
   \   000009 27 06        JREQ      L:??RTC_RatioCmd_0
    578            {
    579              /* Set the RATIO bit */
    580              RTC->CR1 |= (uint8_t)RTC_CR1_RATIO;
   \   00000B 721A 5148    BSET      L:0x5148, #0x5
   \   00000F 20 04        JRA       L:??RTC_RatioCmd_1
    581            }
    582            else
    583            {
    584              /* Reset the RATIO bit */
    585              RTC->CR1 &= (uint8_t)~RTC_CR1_RATIO;
   \                     ??RTC_RatioCmd_0:
   \   000011 721B 5148    BRES      L:0x5148, #0x5
    586            }
    587          
    588            /* Enable the write protection for RTC registers */
    589            RTC->WPR = 0xFF; 
   \                     ??RTC_RatioCmd_1:
   \   000015 35 FF 5159   MOV       L:0x5159, #0xff
    590          }
   \   000019 87           RETF
    591          
    592          /**
    593          * @brief  Enables or Disables the Bypass Shadow feature.
    594          * @param  NewState: new state of the Bypass Shadow feature.
    595            *         This parameter can be: ENABLE or DISABLE.
    596          * @retval None
    597          */

   \                                 In section .far_func.text, align 1
    598          void RTC_BypassShadowCmd(FunctionalState NewState)
    599          {
    600            /* Check the parameters */
    601            assert_param(IS_FUNCTIONAL_STATE(NewState));
    602          
    603            /* Disable the write protection for RTC registers */
    604            RTC->WPR = 0xCA;
   \                     RTC_BypassShadowCmd:
   \   000000 35 CA 5159   MOV       L:0x5159, #0xca
    605            RTC->WPR = 0x53;
   \   000004 35 53 5159   MOV       L:0x5159, #0x53
    606          
    607            if (NewState != DISABLE)
   \   000008 4D           TNZ       A
   \   000009 27 06        JREQ      L:??RTC_BypassShadowCmd_0
    608            {
    609              /* Set the BYPSHAD bit */
    610              RTC->CR1 |= (uint8_t)RTC_CR1_BYPSHAD;
   \   00000B 7218 5148    BSET      L:0x5148, #0x4
   \   00000F 20 04        JRA       L:??RTC_BypassShadowCmd_1
    611            }
    612            else
    613            {
    614              /* Reset the BYPSHAD bit */
    615              RTC->CR1 &= (uint8_t)~RTC_CR1_BYPSHAD;
   \                     ??RTC_BypassShadowCmd_0:
   \   000011 7219 5148    BRES      L:0x5148, #0x4
    616            }
    617          
    618            /* Enable the write protection for RTC registers */
    619            RTC->WPR = 0xFF; 
   \                     ??RTC_BypassShadowCmd_1:
   \   000015 35 FF 5159   MOV       L:0x5159, #0xff
    620          }
   \   000019 87           RETF
    621          
    622          
    623          
    624          
    625          /**
    626            * @}
    627            */
    628          
    629          /** @defgroup RTC_Group2 Time and Date configuration functions
    630           *  @brief   Time and Date configuration functions 
    631           *
    632          @verbatim   
    633           ===============================================================================
    634                             Time and Date configuration functions
    635           ===============================================================================  
    636          
    637            This section provide functions allowing to program and read the RTC Calendar
    638            (Time and Date).
    639          
    640          @endverbatim
    641            * @{
    642            */
    643          
    644          
    645          /**
    646          * @brief Sets the RTC current time.
    647          * @note   After updating the Calendar, this routine clears the RSF flag and waits
    648          *         until it is set again (using RTC_WaitForSynchro() function) , which means
    649          *         that the Calendar registers have been correctly copied into the RTC_TRx
    650          *         and RTC_DRx shadow registers. 
    651          * @param  RTC_Format: specifies the format of the entered parameters.
    652          *         This parameter can be one of the @ref RTC_Format_TypeDef enumeration.
    653          * @param  RTC_TimeStruct:  pointer to a  @ref RTC_TimeTypeDef structure that
    654          *         contains the time configuration information for the RTC
    655          * @retval An ErrorStatus enumeration value:
    656          *          - SUCCESS: RTC Time register is configured
    657          *          - ERROR: RTC Time register is not configured
    658          */

   \                                 In section .far_func.text, align 1
    659          ErrorStatus RTC_SetTime(RTC_Format_TypeDef RTC_Format,
    660                                  RTC_TimeTypeDef* RTC_TimeStruct)
    661          {
   \                     RTC_SetTime:
   \   000000 8D ......    CALLF     L:?push_w4
   \   000004 3B ....      PUSH      S:?b10
   \   000007 B7 ..        LD        S:?b10, A
   \   000009 BF ..        LDW       S:?w4, X
    662            ErrorStatus status = ERROR;
   \   00000B 4F           CLR       A
    663            uint8_t temp = 0;
   \   00000C 3F ..        CLR       S:?b2
    664          
    665            /* Check the parameters */
    666            assert_param(IS_RTC_FORMAT(RTC_Format));
    667          
    668            if (RTC_Format == RTC_Format_BIN)
   \   00000E 3D ..        TNZ       S:?b10
    669            {
    670              /* Check Hour Format (24h or 12h)*/
    671              if ((RTC->CR1 & RTC_CR1_FMT) != RESET)
    672              {
    673                assert_param(IS_RTC_HOUR12_MAX(RTC_TimeStruct->RTC_Hours));
    674                assert_param(IS_RTC_HOUR12_MIN(RTC_TimeStruct->RTC_Hours));
    675              }
    676              else
    677              {
    678                assert_param(IS_RTC_HOUR24(RTC_TimeStruct->RTC_Hours));
    679              }
    680              assert_param(IS_RTC_MINUTES(RTC_TimeStruct->RTC_Minutes));
    681              assert_param(IS_RTC_SECONDS(RTC_TimeStruct->RTC_Seconds));
    682            }
    683            else
    684            {
    685              /* Check Hour Format (24h or 12h)*/
    686              if ((RTC->CR1 & RTC_CR1_FMT) != RESET)
    687              {
    688                assert_param(IS_RTC_HOUR12_MAX(Bcd2ToByte(RTC_TimeStruct->RTC_Hours)));
    689                assert_param(IS_RTC_HOUR12_MIN(Bcd2ToByte(RTC_TimeStruct->RTC_Hours)));
    690              }
    691              else
    692              {
    693                assert_param(IS_RTC_HOUR24(Bcd2ToByte(RTC_TimeStruct->RTC_Hours)));
    694              }
    695              assert_param(IS_RTC_MINUTES(Bcd2ToByte(RTC_TimeStruct->RTC_Minutes)));
    696              assert_param(IS_RTC_SECONDS(Bcd2ToByte(RTC_TimeStruct->RTC_Seconds)));
    697            }
    698          
    699          
    700            /* Disable the write protection for RTC registers */
    701            RTC->WPR = 0xCA;
   \   000010 35 CA 5159   MOV       L:0x5159, #0xca
    702            RTC->WPR = 0x53;
   \   000014 35 53 5159   MOV       L:0x5159, #0x53
    703          
    704            /* Set Initialization mode */
    705            if (RTC_EnterInitMode() == ERROR)
   \   000018 8D ......    CALLF     RTC_EnterInitMode
   \   00001C A1 00        CP        A, #0x0
   \   00001E 26 07        JRNE      L:??RTC_SetTime_0
    706            {
    707              status = ERROR;
   \   000020 4F           CLR       A
    708              /* Enable the write protection for RTC registers */
    709              RTC->WPR = 0xFF; 
   \   000021 35 FF 5159   MOV       L:0x5159, #0xff
   \   000025 20 74        JRA       L:??RTC_SetTime_1
    710            }
    711            else
    712            {
    713              /* Check Hour Format is 12h)*/
    714              if ((RTC->CR1 & RTC_CR1_FMT) != RESET)
   \                     ??RTC_SetTime_0:
   \   000027 720D 5148 0A BTJF      L:0x5148, #0x6, L:??RTC_SetTime_2
    715              {
    716                assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12));
    717                temp = RTC_TimeStruct->RTC_H12;
   \   00002C BE ..        LDW       X, S:?w4
   \   00002E 1C 0003      ADDW      X, #0x3
   \   000031 F6           LD        A, (X)
   \   000032 B7 ..        LD        S:?b2, A
   \   000034 20 02        JRA       L:??RTC_SetTime_3
    718              }
    719              else
    720              {
    721                temp = 0;
   \                     ??RTC_SetTime_2:
   \   000036 3F ..        CLR       S:?b2
    722              }
    723              /* Check the input parameters format */
    724              if (RTC_Format != RTC_Format_BIN)
   \                     ??RTC_SetTime_3:
   \   000038 3D ..        TNZ       S:?b10
   \   00003A 27 1A        JREQ      L:??RTC_SetTime_4
    725              {
    726                RTC->TR1 = (uint8_t)(RTC_TimeStruct->RTC_Seconds);
   \   00003C BE ..        LDW       X, S:?w4
   \   00003E 1C 0002      ADDW      X, #0x2
   \   000041 F6           LD        A, (X)
   \   000042 C7 5140      LD        L:0x5140, A
    727                RTC->TR2 = (uint8_t)(RTC_TimeStruct->RTC_Minutes) ;
   \   000045 BE ..        LDW       X, S:?w4
   \   000047 5C           INCW      X
   \   000048 F6           LD        A, (X)
   \   000049 C7 5141      LD        L:0x5141, A
    728                RTC->TR3 = (uint8_t)( temp | RTC_TimeStruct->RTC_Hours) ;
   \   00004C 92C6 ..      LD        A, [S:?w4.w]
   \   00004F BA ..        OR        A, S:?b2
   \   000051 C7 5142      LD        L:0x5142, A
   \   000054 20 24        JRA       L:??RTC_SetTime_5
    729              }
    730              else
    731              {
    732                RTC->TR1 = (uint8_t)(ByteToBcd2(RTC_TimeStruct->RTC_Seconds));
   \                     ??RTC_SetTime_4:
   \   000056 BE ..        LDW       X, S:?w4
   \   000058 1C 0002      ADDW      X, #0x2
   \   00005B F6           LD        A, (X)
   \   00005C 8D ......    CALLF     ByteToBcd2
   \   000060 C7 5140      LD        L:0x5140, A
    733                RTC->TR2 = (uint8_t)(ByteToBcd2(RTC_TimeStruct->RTC_Minutes)) ;
   \   000063 BE ..        LDW       X, S:?w4
   \   000065 5C           INCW      X
   \   000066 F6           LD        A, (X)
   \   000067 8D ......    CALLF     ByteToBcd2
   \   00006B C7 5141      LD        L:0x5141, A
    734                RTC->TR3 = (uint8_t)( temp | ByteToBcd2(RTC_TimeStruct->RTC_Hours));
   \   00006E 92C6 ..      LD        A, [S:?w4.w]
   \   000071 8D ......    CALLF     ByteToBcd2
   \   000075 BA ..        OR        A, S:?b2
   \   000077 C7 5142      LD        L:0x5142, A
    735              }
    736              /* Read DR3 register to unfreeze calender registers */
    737              (void)(RTC->DR3);
   \                     ??RTC_SetTime_5:
   \   00007A C6 5146      LD        A, L:0x5146
    738          
    739              /* Exit Initialization mode */
    740              RTC->ISR1 &= (uint8_t)~RTC_ISR1_INIT;
   \   00007D 721F 514C    BRES      L:0x514c, #0x7
    741          
    742              /* Enable the write protection for RTC registers */
    743              RTC->WPR = 0xFF; 
   \   000081 35 FF 5159   MOV       L:0x5159, #0xff
    744          
    745              /* if RTC_CR1_BYPSHAD bit = 0, wait for synchro else this check is not needed */
    746              if ((RTC->CR1 & RTC_CR1_BYPSHAD) == RESET)
   \   000085 7208 5148 0F BTJT      L:0x5148, #0x4, L:??RTC_SetTime_6
    747              {
    748                if (RTC_WaitForSynchro() == ERROR)
   \   00008A 8D ......    CALLF     RTC_WaitForSynchro
   \   00008E A1 00        CP        A, #0x0
   \   000090 26 03        JRNE      L:??RTC_SetTime_7
    749                {
    750                  status = ERROR;
   \   000092 4F           CLR       A
   \   000093 20 06        JRA       L:??RTC_SetTime_1
    751                }
    752                else
    753                {
    754                  status = SUCCESS;
   \                     ??RTC_SetTime_7:
   \   000095 A6 01        LD        A, #0x1
   \   000097 20 02        JRA       L:??RTC_SetTime_1
    755                }
    756              }
    757              else
    758              {
    759                status = SUCCESS;
   \                     ??RTC_SetTime_6:
   \   000099 A6 01        LD        A, #0x1
    760              }
    761            }
    762          
    763            return (ErrorStatus)status;
   \                     ??RTC_SetTime_1:
   \   00009B 32 ....      POP       S:?b10
   \   00009E AC ......    JPF       L:?epilogue_w4
    764          }
    765          
    766          
    767          
    768          /**
    769          * @brief  Fills each RTC_TimeStruct member with its default value
    770          *         (Time = 00h:00min:00sec).
    771          * @param  RTC_TimeStruct: pointer to a @ref RTC_TimeTypeDef structure which will be
    772          *         initialized.
    773          * @retval None
    774          */

   \                                 In section .far_func.text, align 1
    775          void RTC_TimeStructInit(RTC_TimeTypeDef* RTC_TimeStruct)
    776          {
    777            /* Time = 00h:00min:00sec*/
    778            RTC_TimeStruct->RTC_H12 = RTC_H12_AM;
   \                     RTC_TimeStructInit:
   \   000000 9093         LDW       Y, X
   \   000002 72A9 0003    ADDW      Y, #0x3
   \   000006 4F           CLR       A
   \   000007 90F7         LD        (Y), A
    779            RTC_TimeStruct->RTC_Hours = 0;
   \   000009 4F           CLR       A
   \   00000A F7           LD        (X), A
    780            RTC_TimeStruct->RTC_Minutes = 0;
   \   00000B 9093         LDW       Y, X
   \   00000D 905C         INCW      Y
   \   00000F 4F           CLR       A
   \   000010 90F7         LD        (Y), A
    781            RTC_TimeStruct->RTC_Seconds = 0;
   \   000012 1C 0002      ADDW      X, #0x2
   \   000015 4F           CLR       A
   \   000016 F7           LD        (X), A
    782          }
   \   000017 87           RETF
    783          
    784                    
    785          /**
    786          * @brief  Gets the RTC current Time.
    787          * @note   To read the Calendar after wake up from low power mode, user software 
    788          *         must first check that the RSF flag is set in RTC_ISR1, using 
    789          *         RTC_WaitForSynchro() function, which means that the Calendar registers
    790          *         have been correctly copied into the shadow registers (RTC_TRx and RTC_DRx).
    791          * @param  RTC_Format: specifies the format of the returned parameters.
    792          *         This parameter can be one of the @ref RTC_Format_TypeDef enumeration.
    793          * @param  RTC_TimeStruct: pointer to a @ref RTC_TimeTypeDef structure that
    794          *         will contain the returned current time configuration.
    795          * @retval None
    796          
    797          */

   \                                 In section .far_func.text, align 1
    798          void RTC_GetTime(RTC_Format_TypeDef RTC_Format,
    799                           RTC_TimeTypeDef* RTC_TimeStruct)
    800          {
   \                     RTC_GetTime:
   \   000000 B7 ..        LD        S:?b1, A
   \   000002 9093         LDW       Y, X
    801            uint8_t  tmpreg = 0;
   \   000004 3F ..        CLR       S:?b0
    802          
    803            /* Check the parameters */
    804            assert_param(IS_RTC_FORMAT(RTC_Format));
    805          
    806            /* Fill the structure fields with the read parameters */
    807            /* Get RTC seconds */
    808            RTC_TimeStruct->RTC_Seconds = RTC->TR1;
   \   000006 93           LDW       X, Y
   \   000007 1C 0002      ADDW      X, #0x2
   \   00000A C6 5140      LD        A, L:0x5140
   \   00000D F7           LD        (X), A
    809          
    810            /* Get RTC Minutes */
    811            RTC_TimeStruct->RTC_Minutes = RTC->TR2;
   \   00000E 93           LDW       X, Y
   \   00000F 5C           INCW      X
   \   000010 C6 5141      LD        A, L:0x5141
   \   000013 F7           LD        (X), A
    812          
    813            /* Get the RTC_TR3 register */
    814            tmpreg = (uint8_t)RTC->TR3;
   \   000014 C6 5142      LD        A, L:0x5142
   \   000017 B7 ..        LD        S:?b0, A
    815          
    816            /* Read DR3 register to unfreeze calender registers */
    817            (void) (RTC->DR3) ;
   \   000019 C6 5146      LD        A, L:0x5146
   \   00001C B7 ..        LD        S:?b2, A
    818          
    819          
    820            /* Get RTC Hours */
    821            RTC_TimeStruct->RTC_Hours = (uint8_t)(tmpreg & (uint8_t)~(RTC_TR3_PM));
   \   00001E B6 ..        LD        A, S:?b0
   \   000020 A4 BF        AND       A, #0xbf
   \   000022 90F7         LD        (Y), A
    822          
    823            /* Get RTC H12 state */
    824            RTC_TimeStruct->RTC_H12 = (RTC_H12_TypeDef)(tmpreg & RTC_TR3_PM);
   \   000024 B6 ..        LD        A, S:?b0
   \   000026 A4 40        AND       A, #0x40
   \   000028 93           LDW       X, Y
   \   000029 1C 0003      ADDW      X, #0x3
   \   00002C F7           LD        (X), A
    825          
    826            /* Check the input parameters format */
    827            if (RTC_Format == RTC_Format_BIN)
   \   00002D 3D ..        TNZ       S:?b1
   \   00002F 26 20        JRNE      L:??RTC_GetTime_0
    828            {
    829              /* Convert the structure parameters to Binary format */
    830              RTC_TimeStruct->RTC_Hours = (uint8_t)Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
   \   000031 90F6         LD        A, (Y)
   \   000033 8D ......    CALLF     Bcd2ToByte
   \   000037 90F7         LD        (Y), A
    831              RTC_TimeStruct->RTC_Minutes = (uint8_t)Bcd2ToByte(RTC_TimeStruct->RTC_Minutes);
   \   000039 93           LDW       X, Y
   \   00003A 5C           INCW      X
   \   00003B F6           LD        A, (X)
   \   00003C 8D ......    CALLF     Bcd2ToByte
   \   000040 93           LDW       X, Y
   \   000041 5C           INCW      X
   \   000042 F7           LD        (X), A
    832              RTC_TimeStruct->RTC_Seconds = (uint8_t)Bcd2ToByte(RTC_TimeStruct->RTC_Seconds);
   \   000043 93           LDW       X, Y
   \   000044 1C 0002      ADDW      X, #0x2
   \   000047 F6           LD        A, (X)
   \   000048 8D ......    CALLF     Bcd2ToByte
   \   00004C 93           LDW       X, Y
   \   00004D 1C 0002      ADDW      X, #0x2
   \   000050 F7           LD        (X), A
    833            }
    834          }
   \                     ??RTC_GetTime_0:
   \   000051 87           RETF
    835          
    836          /**
    837          * @brief  Gets the RTC current Calendar Subseconds value.
    838          * @note   To read the Calendar after wake up from low power mode, user software 
    839          *         must first check that the RSF flag is set in RTC_ISR1, using 
    840          *         RTC_WaitForSynchro() function, which means that the Calendar registers
    841          *         have been correctly copied into the shadow registers (RTC_TRx and RTC_DRx).
    842          * @param  None
    843          * @retval RTC current Calendar Subseconds value.
    844          */

   \                                 In section .far_func.text, align 1
    845          uint16_t RTC_GetSubSecond(void)
    846          {
    847            uint8_t ssrhreg = 0, ssrlreg = 0;
   \                     RTC_GetSubSecond:
   \   000000 3F ..        CLR       S:?b3
   \   000002 3F ..        CLR       S:?b2
    848            uint16_t ssrreg = 0;
   \   000004 3F ..        CLR       S:?b1
   \   000006 3F ..        CLR       S:?b0
    849          
    850            /* Get subseconds values from the correspondent registers*/
    851            ssrhreg = RTC->SSRH;
   \   000008 C6 5157      LD        A, L:0x5157
   \   00000B B7 ..        LD        S:?b3, A
    852            ssrlreg = RTC->SSRL;
   \   00000D C6 5158      LD        A, L:0x5158
   \   000010 B7 ..        LD        S:?b2, A
    853          
    854            /* Read DR3 register to unfreeze calender registers */
    855            (void) (RTC->DR3);
   \   000012 C6 5146      LD        A, L:0x5146
   \   000015 B7 ..        LD        S:?b4, A
    856          
    857          
    858            ssrreg = (uint16_t)((uint16_t)((uint16_t)ssrhreg << 8) | (uint16_t)(ssrlreg));
   \   000017 5F           CLRW      X
   \   000018 41           EXG       A, XL
   \   000019 B6 ..        LD        A, S:?b3
   \   00001B 41           EXG       A, XL
   \   00001C 4F           CLR       A
   \   00001D 02           RLWA      X, A
   \   00001E 905F         CLRW      Y
   \   000020 61           EXG       A, YL
   \   000021 B6 ..        LD        A, S:?b2
   \   000023 61           EXG       A, YL
   \   000024 90BF ..      LDW       S:?w1, Y
   \   000027 01           RRWA      X, A
   \   000028 BA ..        OR        A, S:?b3
   \   00002A 01           RRWA      X, A
   \   00002B BA ..        OR        A, S:?b2
   \   00002D 01           RRWA      X, A
   \   00002E BF ..        LDW       S:?w0, X
    859            return (uint16_t)(ssrreg);
   \   000030 BE ..        LDW       X, S:?w0
   \   000032 87           RETF
    860          }
    861          
    862          /**
    863          * @brief  Set the RTC current date.
    864          * @note   After updating the Calendar, this routine clears the RSF flag and waits
    865          *         until it is set again (using RTC_WaitForSynchro() function) , which means
    866          *         that the Calendar registers have been correctly copied into the RTC_TRx
    867          *         and RTC_DRx shadow registers.   
    868          * @param  RTC_Format: specifies the format of the entered parameters.
    869          *         This parameter can be one of the @ref RTC_Format_TypeDef enumeration.
    870          * @param  RTC_DateStruct:  pointer to a  @ref RTC_TimeTypeDef structure that
    871          *         contains the date configuration information for the RTC.
    872          * @retval An ErrorStatus enumeration value:
    873          *          - SUCCESS: RTC Date register is configured
    874          *          - ERROR: RTC Date register is not configured
    875          */

   \                                 In section .far_func.text, align 1
    876          ErrorStatus RTC_SetDate(RTC_Format_TypeDef RTC_Format,
    877                                  RTC_DateTypeDef* RTC_DateStruct)
    878          {
   \                     RTC_SetDate:
   \   000000 8D ......    CALLF     L:?push_w4
   \   000004 3B ....      PUSH      S:?b10
   \   000007 B7 ..        LD        S:?b10, A
   \   000009 BF ..        LDW       S:?w4, X
    879            ErrorStatus status = ERROR;
   \   00000B 4F           CLR       A
    880          
    881            if ((RTC_Format == RTC_Format_BIN) && ((RTC_DateStruct->RTC_Month & TEN_VALUE_BCD) == TEN_VALUE_BCD))
   \   00000C 3D ..        TNZ       S:?b10
   \   00000E 26 16        JRNE      L:??RTC_SetDate_0
   \   000010 BE ..        LDW       X, S:?w4
   \   000012 5C           INCW      X
   \   000013 F6           LD        A, (X)
   \   000014 A4 10        AND       A, #0x10
   \   000016 A1 00        CP        A, #0x0
   \   000018 27 0C        JREQ      L:??RTC_SetDate_0
    882            {
    883              RTC_DateStruct->RTC_Month = (RTC_Month_TypeDef)((RTC_DateStruct->RTC_Month & (uint8_t)~(TEN_VALUE_BCD)) + TEN_VALUE_BIN);
   \   00001A BE ..        LDW       X, S:?w4
   \   00001C 5C           INCW      X
   \   00001D F6           LD        A, (X)
   \   00001E A4 EF        AND       A, #0xef
   \   000020 AB 0A        ADD       A, #0xa
   \   000022 BE ..        LDW       X, S:?w4
   \   000024 5C           INCW      X
   \   000025 F7           LD        (X), A
    884            }
    885          
    886            /* Check the parameters */
    887            assert_param(IS_RTC_FORMAT(RTC_Format));
    888            if (RTC_Format == RTC_Format_BIN)
   \                     ??RTC_SetDate_0:
   \   000026 3D ..        TNZ       S:?b10
    889            {
    890              assert_param(IS_RTC_YEAR(RTC_DateStruct->RTC_Year));
    891              assert_param(IS_RTC_MONTH_MIN(RTC_DateStruct->RTC_Month));
    892              assert_param(IS_RTC_MONTH_MAX(RTC_DateStruct->RTC_Month));
    893              assert_param(IS_RTC_DATE_MIN(RTC_DateStruct->RTC_Date));
    894              assert_param(IS_RTC_DATE_MAX(RTC_DateStruct->RTC_Date));
    895            }
    896            else
    897            {
    898              assert_param(IS_RTC_YEAR(Bcd2ToByte(RTC_DateStruct->RTC_Year)));
    899              assert_param(IS_RTC_MONTH_MAX(Bcd2ToByte((uint8_t)RTC_DateStruct->RTC_Month)));
    900              assert_param(IS_RTC_MONTH_MIN(Bcd2ToByte((uint8_t)RTC_DateStruct->RTC_Month)));
    901              assert_param(IS_RTC_DATE_MIN(Bcd2ToByte((uint8_t)RTC_DateStruct->RTC_Date)));
    902              assert_param(IS_RTC_DATE_MAX(Bcd2ToByte((uint8_t)RTC_DateStruct->RTC_Date)));
    903            }
    904            assert_param(IS_RTC_WEEKDAY(RTC_DateStruct->RTC_WeekDay));
    905          
    906            /* Disable the write protection for RTC registers */
    907            RTC->WPR = 0xCA;
   \   000028 35 CA 5159   MOV       L:0x5159, #0xca
    908            RTC->WPR = 0x53;
   \   00002C 35 53 5159   MOV       L:0x5159, #0x53
    909          
    910            /* Set Initialization mode */
    911            if (RTC_EnterInitMode() == ERROR)
   \   000030 8D ......    CALLF     RTC_EnterInitMode
   \   000034 A1 00        CP        A, #0x0
   \   000036 26 07        JRNE      L:??RTC_SetDate_1
    912            {
    913              status = ERROR;
   \   000038 4F           CLR       A
    914              /* Enable the write protection for RTC registers */
    915              RTC->WPR = 0xFF; 
   \   000039 35 FF 5159   MOV       L:0x5159, #0xff
   \   00003D 20 77        JRA       L:??RTC_SetDate_2
    916            }
    917            else
    918            {
    919              (void)(RTC->TR1);
   \                     ??RTC_SetDate_1:
   \   00003F C6 5140      LD        A, L:0x5140
    920              /* Set the RTC_DR registers */
    921              /* Check the input parameters format */
    922              if (RTC_Format != RTC_Format_BIN)
   \   000042 3D ..        TNZ       S:?b10
   \   000044 27 22        JREQ      L:??RTC_SetDate_3
    923              {
    924                RTC->DR1 = (uint8_t)(RTC_DateStruct->RTC_Date);
   \   000046 BE ..        LDW       X, S:?w4
   \   000048 1C 0002      ADDW      X, #0x2
   \   00004B F6           LD        A, (X)
   \   00004C C7 5144      LD        L:0x5144, A
    925                RTC->DR2 = (uint8_t)((RTC_DateStruct->RTC_Month) | (uint8_t)((RTC_DateStruct->RTC_WeekDay) << 5));
   \   00004F 92C6 ..      LD        A, [S:?w4.w]
   \   000052 4E           SWAP      A
   \   000053 A4 F0        AND       A, #0xf0
   \   000055 48           SLL       A
   \   000056 BE ..        LDW       X, S:?w4
   \   000058 5C           INCW      X
   \   000059 FA           OR        A, (X)
   \   00005A C7 5145      LD        L:0x5145, A
    926                RTC->DR3 = (uint8_t)((RTC_DateStruct->RTC_Year));
   \   00005D BE ..        LDW       X, S:?w4
   \   00005F 1C 0003      ADDW      X, #0x3
   \   000062 F6           LD        A, (X)
   \   000063 C7 5146      LD        L:0x5146, A
   \   000066 20 30        JRA       L:??RTC_SetDate_4
    927              }
    928              else
    929              {
    930                RTC->DR1 = (uint8_t)(ByteToBcd2 ((uint8_t)RTC_DateStruct->RTC_Date));
   \                     ??RTC_SetDate_3:
   \   000068 BE ..        LDW       X, S:?w4
   \   00006A 1C 0002      ADDW      X, #0x2
   \   00006D F6           LD        A, (X)
   \   00006E 8D ......    CALLF     ByteToBcd2
   \   000072 C7 5144      LD        L:0x5144, A
    931                RTC->DR2 = (uint8_t)((ByteToBcd2((uint8_t)RTC_DateStruct->RTC_Month)) | (uint8_t)((RTC_DateStruct->RTC_WeekDay) << 5));
   \   000075 BE ..        LDW       X, S:?w4
   \   000077 5C           INCW      X
   \   000078 F6           LD        A, (X)
   \   000079 8D ......    CALLF     ByteToBcd2
   \   00007D B7 ..        LD        S:?b0, A
   \   00007F 92C6 ..      LD        A, [S:?w4.w]
   \   000082 4E           SWAP      A
   \   000083 A4 F0        AND       A, #0xf0
   \   000085 48           SLL       A
   \   000086 BA ..        OR        A, S:?b0
   \   000088 C7 5145      LD        L:0x5145, A
    932                RTC->DR3 = (uint8_t)(ByteToBcd2((uint8_t)RTC_DateStruct->RTC_Year));
   \   00008B BE ..        LDW       X, S:?w4
   \   00008D 1C 0003      ADDW      X, #0x3
   \   000090 F6           LD        A, (X)
   \   000091 8D ......    CALLF     ByteToBcd2
   \   000095 C7 5146      LD        L:0x5146, A
    933              }
    934          
    935              /* Exit Initialization mode */
    936              RTC->ISR1 &= (uint8_t)~RTC_ISR1_INIT;
   \                     ??RTC_SetDate_4:
   \   000098 721F 514C    BRES      L:0x514c, #0x7
    937          
    938              /* Enable the write protection for RTC registers */
    939              RTC->WPR = 0xFF; 
   \   00009C 35 FF 5159   MOV       L:0x5159, #0xff
    940          
    941              /* if  RTC_CR1_BYPSHAD bit = 0, wait for synchro else this check is not needed */
    942              if ((RTC->CR1 & RTC_CR1_BYPSHAD) == RESET)
   \   0000A0 7208 5148 0F BTJT      L:0x5148, #0x4, L:??RTC_SetDate_5
    943              {
    944                if (RTC_WaitForSynchro() == ERROR)
   \   0000A5 8D ......    CALLF     RTC_WaitForSynchro
   \   0000A9 A1 00        CP        A, #0x0
   \   0000AB 26 03        JRNE      L:??RTC_SetDate_6
    945                {
    946                  status = ERROR;
   \   0000AD 4F           CLR       A
   \   0000AE 20 06        JRA       L:??RTC_SetDate_2
    947                }
    948                else
    949                {
    950                  status = SUCCESS;
   \                     ??RTC_SetDate_6:
   \   0000B0 A6 01        LD        A, #0x1
   \   0000B2 20 02        JRA       L:??RTC_SetDate_2
    951                }
    952              }
    953              else
    954              {
    955                status = SUCCESS;
   \                     ??RTC_SetDate_5:
   \   0000B4 A6 01        LD        A, #0x1
    956              }
    957            }
    958          
    959            return (ErrorStatus)status;
   \                     ??RTC_SetDate_2:
   \   0000B6 32 ....      POP       S:?b10
   \   0000B9 AC ......    JPF       L:?epilogue_w4
    960          }
    961          /**
    962          * @brief  Fills each RTC_DateStruct member with its default value
    963          *         (Monday 01 January xx00).
    964          * @param  RTC_DateStruct: pointer to a @ref RTC_DateTypeDef structure which will be
    965          *         initialized.
    966          * @retval None
    967          */

   \                                 In section .far_func.text, align 1
    968          void RTC_DateStructInit(RTC_DateTypeDef* RTC_DateStruct)
    969          {
    970            /* * (Monday 01 January xx00)*/
    971            RTC_DateStruct->RTC_WeekDay = RTC_Weekday_Monday;
   \                     RTC_DateStructInit:
   \   000000 A6 01        LD        A, #0x1
   \   000002 F7           LD        (X), A
    972            RTC_DateStruct->RTC_Date = 1;
   \   000003 9093         LDW       Y, X
   \   000005 72A9 0002    ADDW      Y, #0x2
   \   000009 A6 01        LD        A, #0x1
   \   00000B 90F7         LD        (Y), A
    973            RTC_DateStruct->RTC_Month = RTC_Month_January;
   \   00000D 9093         LDW       Y, X
   \   00000F 905C         INCW      Y
   \   000011 A6 01        LD        A, #0x1
   \   000013 90F7         LD        (Y), A
    974            RTC_DateStruct->RTC_Year = 0;
   \   000015 1C 0003      ADDW      X, #0x3
   \   000018 4F           CLR       A
   \   000019 F7           LD        (X), A
    975          }
   \   00001A 87           RETF
    976          /**
    977          * @brief  Get the RTC current date.
    978          * @note   To read the Calendar after wake up from low power mode, user software 
    979          *         must first check that the RSF flag is set in RTC_ISR1, using 
    980          *         RTC_WaitForSynchro() function, which means that the Calendar registers
    981          *         have been correctly copied into the shadow registers (RTC_TRx and RTC_DRx).
    982          * @param  RTC_Format: specifies the format of the returned parameters.
    983          *         This parameter can be one of the @ref RTC_Format_TypeDef enumeration.
    984          * @param  RTC_DateStruct: pointer to a @ref RTC_DateTypeDef structure that
    985          *         will contain the returned current Date configuration.
    986          * @retval None
    987          */

   \                                 In section .far_func.text, align 1
    988          void RTC_GetDate(RTC_Format_TypeDef RTC_Format,
    989                           RTC_DateTypeDef* RTC_DateStruct)
    990          {
   \                     RTC_GetDate:
   \   000000 B7 ..        LD        S:?b1, A
   \   000002 9093         LDW       Y, X
    991            uint8_t tmpreg = 0;
   \   000004 3F ..        CLR       S:?b0
    992          
    993            /* Check the parameters */
    994            assert_param(IS_RTC_FORMAT(RTC_Format));
    995          
    996            /* Fill the structure fields with the read parameters */
    997            (void) (RTC->TR1) ;
   \   000006 C6 5140      LD        A, L:0x5140
   \   000009 B7 ..        LD        S:?b2, A
    998            RTC_DateStruct->RTC_Date = (uint8_t)(RTC->DR1);
   \   00000B 93           LDW       X, Y
   \   00000C 1C 0002      ADDW      X, #0x2
   \   00000F C6 5144      LD        A, L:0x5144
   \   000012 F7           LD        (X), A
    999            tmpreg = (uint8_t)RTC->DR2;
   \   000013 C6 5145      LD        A, L:0x5145
   \   000016 B7 ..        LD        S:?b0, A
   1000            RTC_DateStruct->RTC_Year = (uint8_t)(RTC->DR3);
   \   000018 93           LDW       X, Y
   \   000019 1C 0003      ADDW      X, #0x3
   \   00001C C6 5146      LD        A, L:0x5146
   \   00001F F7           LD        (X), A
   1001          
   1002          
   1003            RTC_DateStruct->RTC_Month = (RTC_Month_TypeDef)(tmpreg & (uint8_t)(RTC_DR2_MT | RTC_DR2_MU));
   \   000020 B6 ..        LD        A, S:?b0
   \   000022 A4 1F        AND       A, #0x1f
   \   000024 93           LDW       X, Y
   \   000025 5C           INCW      X
   \   000026 F7           LD        (X), A
   1004            RTC_DateStruct->RTC_WeekDay = (RTC_Weekday_TypeDef)((uint8_t)((uint8_t)tmpreg & (uint8_t)(RTC_DR2_WDU)) >> (uint8_t)5);
   \   000027 B6 ..        LD        A, S:?b0
   \   000029 4E           SWAP      A
   \   00002A A4 0F        AND       A, #0xf
   \   00002C 44           SRL       A
   \   00002D 90F7         LD        (Y), A
   1005          
   1006            /* Check the input parameters format */
   1007            if (RTC_Format == RTC_Format_BIN)
   \   00002F 3D ..        TNZ       S:?b1
   \   000031 26 26        JRNE      L:??RTC_GetDate_0
   1008            {
   1009              /* Convert the structure parameters to Binary format */
   1010              RTC_DateStruct->RTC_Year = (uint8_t)Bcd2ToByte((uint8_t)RTC_DateStruct->RTC_Year);
   \   000033 93           LDW       X, Y
   \   000034 1C 0003      ADDW      X, #0x3
   \   000037 F6           LD        A, (X)
   \   000038 8D ......    CALLF     Bcd2ToByte
   \   00003C 93           LDW       X, Y
   \   00003D 1C 0003      ADDW      X, #0x3
   \   000040 F7           LD        (X), A
   1011              RTC_DateStruct->RTC_Month = (RTC_Month_TypeDef)Bcd2ToByte((uint8_t)RTC_DateStruct->RTC_Month);
   \   000041 93           LDW       X, Y
   \   000042 5C           INCW      X
   \   000043 F6           LD        A, (X)
   \   000044 8D ......    CALLF     Bcd2ToByte
   \   000048 93           LDW       X, Y
   \   000049 5C           INCW      X
   \   00004A F7           LD        (X), A
   1012              RTC_DateStruct->RTC_Date = (uint8_t)(Bcd2ToByte((uint8_t)RTC_DateStruct->RTC_Date));
   \   00004B 93           LDW       X, Y
   \   00004C 1C 0002      ADDW      X, #0x2
   \   00004F F6           LD        A, (X)
   \   000050 8D ......    CALLF     Bcd2ToByte
   \   000054 93           LDW       X, Y
   \   000055 1C 0002      ADDW      X, #0x2
   \   000058 F7           LD        (X), A
   1013            }
   1014          }
   \                     ??RTC_GetDate_0:
   \   000059 87           RETF
   1015          
   1016          /**
   1017            * @}
   1018            */
   1019          
   1020          /** @defgroup RTC_Group3 Alarms configuration functions
   1021           *  @brief   Alarms (Alarm A and Alarm B) configuration functions 
   1022           *
   1023          @verbatim   
   1024           ===============================================================================
   1025                        Alarms (Alarm A and Alarm B) configuration functions
   1026           ===============================================================================  
   1027          
   1028            This section provide functions allowing to program and read the RTC Alarms.
   1029          
   1030          @endverbatim
   1031            * @{
   1032            */
   1033            
   1034          /**
   1035            * @brief  Sets the RTC Alarm configuration.
   1036            * @note   Before configuring the Alarm settings, the Alarm Unit must be disabled
   1037            *         (if enabled) using RTC_AlarmCmd(DISABLE) function.
   1038            * @param  RTC_Format: specifies the format of the entered parameters.
   1039            *         This parameter can be one of the @ref RTC_Format_TypeDef enumeration.
   1040            * @param  RTC_AlarmStruct:  pointer to a  @ref RTC_AlarmTypeDef structure that
   1041            *         contains the Alarm configuration information for the RTC.
   1042            * @retval None.
   1043            */

   \                                 In section .far_func.text, align 1
   1044          void RTC_SetAlarm(RTC_Format_TypeDef RTC_Format,
   1045                            RTC_AlarmTypeDef* RTC_AlarmStruct)
   1046          {
   \                     RTC_SetAlarm:
   \   000000 B7 ..        LD        S:?b1, A
   1047            uint8_t tmpreg1 = 0;
   \   000002 3F ..        CLR       S:?b4
   1048            uint8_t tmpreg2 = 0;
   \   000004 3F ..        CLR       S:?b3
   1049            uint8_t tmpreg3 = 0;
   \   000006 3F ..        CLR       S:?b2
   1050            uint8_t tmpreg4 = 0;
   \   000008 3F ..        CLR       S:?b0
   1051          
   1052            /* Check the parameters */
   1053            assert_param(IS_RTC_ALARM_MASK(RTC_AlarmStruct->RTC_AlarmMask));
   1054            assert_param(IS_RTC_FORMAT(RTC_Format));
   1055            assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
   1056            assert_param(IS_RTC_ALARM_DATEWEEKDAY_SEL(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel));
   1057          
   1058          
   1059            if (RTC_Format == RTC_Format_BIN)
   \   00000A 3D ..        TNZ       S:?b1
   1060            {
   1061              /* Check Hour Format (24h or 12h)*/
   1062              if ((RTC->CR1 & RTC_CR1_FMT) != RESET)
   1063              {
   1064                assert_param(IS_RTC_HOUR12_MAX(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
   1065                assert_param(IS_RTC_HOUR12_MIN(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
   1066              }
   1067              else
   1068              {
   1069                assert_param(IS_RTC_HOUR24(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
   1070              }
   1071              assert_param(IS_RTC_MINUTES(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes));
   1072              assert_param(IS_RTC_SECONDS(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds));
   1073            }
   1074            else
   1075            {
   1076              /* Check Hour Format (24h or 12h)*/
   1077              if ((RTC->CR1 & RTC_CR1_FMT) != RESET)
   1078              {
   1079                assert_param(IS_RTC_HOUR12_MAX(Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours)));
   1080                assert_param(IS_RTC_HOUR12_MIN(Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours)));
   1081              }
   1082              else
   1083              {
   1084                assert_param(IS_RTC_HOUR24(Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours)));
   1085              }
   1086          
   1087              assert_param(IS_RTC_MINUTES(Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes)));
   1088          
   1089              assert_param(IS_RTC_SECONDS(Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)));
   1090          
   1091            }
   1092          
   1093            /* if Date/Weekday field is not masked */
   1094            if ((RTC_AlarmStruct->RTC_AlarmMask & RTC_AlarmMask_DateWeekDay) == RESET )
   \   00000C 9093         LDW       Y, X
   \   00000E 72A9 0004    ADDW      Y, #0x4
   \   000012 90F6         LD        A, (Y)
   \   000014 A4 10        AND       A, #0x10
   \   000016 A1 00        CP        A, #0x0
   \   000018 26 0A        JRNE      L:??RTC_SetAlarm_0
   1095            {
   1096              if (RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_WeekDay)
   \   00001A 9093         LDW       Y, X
   \   00001C 72A9 0005    ADDW      Y, #0x5
   \   000020 90F6         LD        A, (Y)
   \   000022 A1 40        CP        A, #0x40
   1097              {
   1098                assert_param(IS_RTC_WEEKDAY(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
   1099              }
   1100              else
   1101              {
   1102                assert_param(IS_RTC_DATE_MIN(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
   1103                assert_param(IS_RTC_DATE_MAX(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
   1104              }
   1105            }
   1106          
   1107            /* Disable the write protection for RTC registers */
   1108            RTC->WPR = 0xCA;
   \                     ??RTC_SetAlarm_0:
   \   000024 35 CA 5159   MOV       L:0x5159, #0xca
   1109            RTC->WPR = 0x53;
   \   000028 35 53 5159   MOV       L:0x5159, #0x53
   1110          
   1111          
   1112            /* Check the input parameters format & Configure the Alarm register */
   1113            if (RTC_Format != RTC_Format_BIN)
   \   00002C 3D ..        TNZ       S:?b1
   \   00002E 27 65        JREQ      L:??RTC_SetAlarm_1
   1114            {
   1115              tmpreg1 = (uint8_t)((uint8_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
   1116                                  (uint8_t)((uint8_t)(RTC_AlarmStruct->RTC_AlarmMask) & (uint8_t)RTC_ALRMAR1_MSK1));
   \   000030 9093         LDW       Y, X
   \   000032 72A9 0004    ADDW      Y, #0x4
   \   000036 90F6         LD        A, (Y)
   \   000038 A4 80        AND       A, #0x80
   \   00003A 9093         LDW       Y, X
   \   00003C 72A9 0002    ADDW      Y, #0x2
   \   000040 90FA         OR        A, (Y)
   \   000042 B7 ..        LD        S:?b4, A
   1117          
   1118              tmpreg2 = (uint8_t)((uint8_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) | \
   1119                                  (uint8_t)((uint8_t)(RTC_AlarmStruct->RTC_AlarmMask << 1) & (uint8_t)RTC_ALRMAR2_MSK2));
   \   000044 9093         LDW       Y, X
   \   000046 72A9 0004    ADDW      Y, #0x4
   \   00004A 90F6         LD        A, (Y)
   \   00004C 48           SLL       A
   \   00004D A4 80        AND       A, #0x80
   \   00004F 9093         LDW       Y, X
   \   000051 905C         INCW      Y
   \   000053 90FA         OR        A, (Y)
   \   000055 B7 ..        LD        S:?b3, A
   1120          
   1121              tmpreg3 = (uint8_t)((uint8_t)((uint8_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) | \
   1122                                            (uint8_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12)) | \
   1123                                  (uint8_t)((uint8_t)(RTC_AlarmStruct->RTC_AlarmMask << 2) & (uint8_t)RTC_ALRMAR3_MSK3));
   \   000057 9093         LDW       Y, X
   \   000059 72A9 0004    ADDW      Y, #0x4
   \   00005D 90F6         LD        A, (Y)
   \   00005F 48           SLL       A
   \   000060 48           SLL       A
   \   000061 A4 80        AND       A, #0x80
   \   000063 88           PUSH      A
   \   000064 9093         LDW       Y, X
   \   000066 72A9 0003    ADDW      Y, #0x3
   \   00006A 90F6         LD        A, (Y)
   \   00006C FA           OR        A, (X)
   \   00006D B7 ..        LD        S:?b1, A
   \   00006F 84           POP       A
   \   000070 BA ..        OR        A, S:?b1
   \   000072 B7 ..        LD        S:?b2, A
   1124          
   1125              tmpreg4 = (uint8_t)((uint8_t)((uint8_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDay) | \
   1126                                            (uint8_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel)) | \
   1127                                  (uint8_t)((uint8_t)(RTC_AlarmStruct->RTC_AlarmMask << 3) & (uint8_t)RTC_ALRMAR4_MSK4));
   \   000074 9093         LDW       Y, X
   \   000076 72A9 0005    ADDW      Y, #0x5
   \   00007A 90F6         LD        A, (Y)
   \   00007C 9093         LDW       Y, X
   \   00007E 72A9 0006    ADDW      Y, #0x6
   \   000082 90FA         OR        A, (Y)
   \   000084 B7 ..        LD        S:?b0, A
   \   000086 1C 0004      ADDW      X, #0x4
   \   000089 F6           LD        A, (X)
   \   00008A 48           SLL       A
   \   00008B 48           SLL       A
   \   00008C 48           SLL       A
   \   00008D A4 80        AND       A, #0x80
   \   00008F BA ..        OR        A, S:?b0
   \   000091 B7 ..        LD        S:?b0, A
   \   000093 20 7B        JRA       L:??RTC_SetAlarm_2
   1128          
   1129            }
   1130            else
   1131            {
   1132              tmpreg1 = (uint8_t)((ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
   1133                                  (uint8_t)(RTC_AlarmStruct->RTC_AlarmMask & RTC_ALRMAR1_MSK1));
   \                     ??RTC_SetAlarm_1:
   \   000095 9093         LDW       Y, X
   \   000097 72A9 0002    ADDW      Y, #0x2
   \   00009B 90F6         LD        A, (Y)
   \   00009D 8D ......    CALLF     ByteToBcd2
   \   0000A1 B7 ..        LD        S:?b0, A
   \   0000A3 9093         LDW       Y, X
   \   0000A5 72A9 0004    ADDW      Y, #0x4
   \   0000A9 90F6         LD        A, (Y)
   \   0000AB A4 80        AND       A, #0x80
   \   0000AD BA ..        OR        A, S:?b0
   \   0000AF B7 ..        LD        S:?b4, A
   1134          
   1135              tmpreg2 = (uint8_t)((ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes)) | \
   1136                                  (uint8_t)((uint8_t)(RTC_AlarmStruct->RTC_AlarmMask << 1) & (uint8_t)RTC_ALRMAR2_MSK2));
   \   0000B1 9093         LDW       Y, X
   \   0000B3 72A9 0004    ADDW      Y, #0x4
   \   0000B7 90F6         LD        A, (Y)
   \   0000B9 48           SLL       A
   \   0000BA A4 80        AND       A, #0x80
   \   0000BC 88           PUSH      A
   \   0000BD 9093         LDW       Y, X
   \   0000BF 905C         INCW      Y
   \   0000C1 90F6         LD        A, (Y)
   \   0000C3 8D ......    CALLF     ByteToBcd2
   \   0000C7 B7 ..        LD        S:?b0, A
   \   0000C9 84           POP       A
   \   0000CA BA ..        OR        A, S:?b0
   \   0000CC B7 ..        LD        S:?b3, A
   1137          
   1138              tmpreg3 = (uint8_t)((uint8_t)((ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours)) | \
   1139                                            (uint8_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12)) | \
   1140                                  (uint8_t)((uint8_t)(RTC_AlarmStruct->RTC_AlarmMask << 2) & (uint8_t)RTC_ALRMAR3_MSK3));
   \   0000CE F6           LD        A, (X)
   \   0000CF 8D ......    CALLF     ByteToBcd2
   \   0000D3 9093         LDW       Y, X
   \   0000D5 72A9 0003    ADDW      Y, #0x3
   \   0000D9 90FA         OR        A, (Y)
   \   0000DB B7 ..        LD        S:?b0, A
   \   0000DD 9093         LDW       Y, X
   \   0000DF 72A9 0004    ADDW      Y, #0x4
   \   0000E3 90F6         LD        A, (Y)
   \   0000E5 48           SLL       A
   \   0000E6 48           SLL       A
   \   0000E7 A4 80        AND       A, #0x80
   \   0000E9 BA ..        OR        A, S:?b0
   \   0000EB B7 ..        LD        S:?b2, A
   1141          
   1142              tmpreg4 = (uint8_t)((uint8_t)((ByteToBcd2(RTC_AlarmStruct->RTC_AlarmDateWeekDay)) | \
   1143                                            (uint8_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel)) | \
   1144                                  (uint8_t)((uint8_t)(RTC_AlarmStruct->RTC_AlarmMask << 3) & (uint8_t)(RTC_ALRMAR4_MSK4)));
   \   0000ED 9093         LDW       Y, X
   \   0000EF 72A9 0006    ADDW      Y, #0x6
   \   0000F3 90F6         LD        A, (Y)
   \   0000F5 8D ......    CALLF     ByteToBcd2
   \   0000F9 9093         LDW       Y, X
   \   0000FB 72A9 0005    ADDW      Y, #0x5
   \   0000FF 90FA         OR        A, (Y)
   \   000101 B7 ..        LD        S:?b0, A
   \   000103 1C 0004      ADDW      X, #0x4
   \   000106 F6           LD        A, (X)
   \   000107 48           SLL       A
   \   000108 48           SLL       A
   \   000109 48           SLL       A
   \   00010A A4 80        AND       A, #0x80
   \   00010C BA ..        OR        A, S:?b0
   \   00010E B7 ..        LD        S:?b0, A
   1145            }
   1146          
   1147            /* Configure the Alarm register */
   1148            RTC->ALRMAR1 = tmpreg1;
   \                     ??RTC_SetAlarm_2:
   \   000110 B6 ..        LD        A, S:?b4
   \   000112 C7 515C      LD        L:0x515c, A
   1149            RTC->ALRMAR2 = tmpreg2;
   \   000115 B6 ..        LD        A, S:?b3
   \   000117 C7 515D      LD        L:0x515d, A
   1150            RTC->ALRMAR3 = tmpreg3;
   \   00011A B6 ..        LD        A, S:?b2
   \   00011C C7 515E      LD        L:0x515e, A
   1151            RTC->ALRMAR4 = tmpreg4;
   \   00011F B6 ..        LD        A, S:?b0
   \   000121 C7 515F      LD        L:0x515f, A
   1152          
   1153            /* Enable the write protection for RTC registers */
   1154            RTC->WPR = 0xFF; 
   \   000124 35 FF 5159   MOV       L:0x5159, #0xff
   1155          }
   \   000128 87           RETF
   1156          
   1157          /**
   1158          * @brief  Fills each RTC_AlarmStruct member with its default value
   1159          *         (Time = 00h:00mn:00sec / Date = 1st day of the month/Mask =
   1160          *         all fields are masked).
   1161          * @param  RTC_AlarmStruct: pointer to a @ref RTC_AlarmTypeDef structure which
   1162          *         will be initialized.
   1163          * @retval None
   1164          */

   \                                 In section .far_func.text, align 1
   1165          void RTC_AlarmStructInit(RTC_AlarmTypeDef* RTC_AlarmStruct)
   1166          {
   1167            /* Alarm Time Settings : Time = 00h:00mn:00sec */
   1168            RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = RTC_H12_AM;
   \                     RTC_AlarmStructInit:
   \   000000 9093         LDW       Y, X
   \   000002 72A9 0003    ADDW      Y, #0x3
   \   000006 4F           CLR       A
   \   000007 90F7         LD        (Y), A
   1169            RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = 0;
   \   000009 4F           CLR       A
   \   00000A F7           LD        (X), A
   1170            RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = 0;
   \   00000B 9093         LDW       Y, X
   \   00000D 905C         INCW      Y
   \   00000F 4F           CLR       A
   \   000010 90F7         LD        (Y), A
   1171            RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = 0;
   \   000012 9093         LDW       Y, X
   \   000014 72A9 0002    ADDW      Y, #0x2
   \   000018 4F           CLR       A
   \   000019 90F7         LD        (Y), A
   1172          
   1173            /* Alarm Date Settings : Date = 1st day of the month*/
   1174            RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = RTC_AlarmDateWeekDaySel_Date;
   \   00001B 9093         LDW       Y, X
   \   00001D 72A9 0005    ADDW      Y, #0x5
   \   000021 4F           CLR       A
   \   000022 90F7         LD        (Y), A
   1175            RTC_AlarmStruct->RTC_AlarmDateWeekDay = 1;
   \   000024 9093         LDW       Y, X
   \   000026 72A9 0006    ADDW      Y, #0x6
   \   00002A A6 01        LD        A, #0x1
   \   00002C 90F7         LD        (Y), A
   1176          
   1177            /* Alarm Masks Settings : Mask =  all fields are masked*/
   1178            RTC_AlarmStruct->RTC_AlarmMask = RTC_AlarmMask_All;
   \   00002E 1C 0004      ADDW      X, #0x4
   \   000031 A6 F0        LD        A, #0xf0
   \   000033 F7           LD        (X), A
   1179          }
   \   000034 87           RETF
   1180          /**
   1181            * @brief  Gets the RTC Alarm configuration.
   1182            * @param  RTC_Format: specifies the format of the entered parameters.
   1183            *         This parameter can be one of the @ref RTC_Format_TypeDef enumeration.
   1184            * @param  RTC_AlarmStruct:  pointer to a  @ref RTC_AlarmTypeDef structure that
   1185            *         will contain the Alarm configuration information of  the RTC.
   1186            * @retval None
   1187            */

   \                                 In section .far_func.text, align 1
   1188          void RTC_GetAlarm(RTC_Format_TypeDef RTC_Format,
   1189                            RTC_AlarmTypeDef* RTC_AlarmStruct)
   1190          {
   \                     RTC_GetAlarm:
   \   000000 B7 ..        LD        S:?b4, A
   \   000002 9093         LDW       Y, X
   1191            uint8_t tmpreg1 = 0;
   \   000004 3F ..        CLR       S:?b3
   1192            uint8_t tmpreg2 = 0;
   \   000006 3F ..        CLR       S:?b2
   1193            uint8_t tmpreg3 = 0;
   \   000008 3F ..        CLR       S:?b1
   1194            uint8_t tmpreg4 = 0;
   \   00000A 3F ..        CLR       S:?b0
   1195            uint8_t alarmmask = 0;
   \   00000C 3F ..        CLR       S:?b5
   1196          
   1197            /* Check the parameters */
   1198            assert_param(IS_RTC_FORMAT(RTC_Format));
   1199          
   1200            /* Get Alarm registers data */
   1201            tmpreg1 = (uint8_t)RTC->ALRMAR1;
   \   00000E C6 515C      LD        A, L:0x515c
   \   000011 B7 ..        LD        S:?b3, A
   1202            tmpreg2 = (uint8_t)RTC->ALRMAR2;
   \   000013 C6 515D      LD        A, L:0x515d
   \   000016 B7 ..        LD        S:?b2, A
   1203            tmpreg3 = (uint8_t)RTC->ALRMAR3;
   \   000018 C6 515E      LD        A, L:0x515e
   \   00001B B7 ..        LD        S:?b1, A
   1204            tmpreg4 = (uint8_t)RTC->ALRMAR4;
   \   00001D C6 515F      LD        A, L:0x515f
   \   000020 B7 ..        LD        S:?b0, A
   1205          
   1206            /* Fill the structure with the read parameters */
   1207            RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = (uint8_t)((uint8_t)tmpreg1 & (uint8_t)((uint8_t)RTC_ALRMAR1_ST | (uint8_t)RTC_ALRMAR1_SU));
   \   000022 B6 ..        LD        A, S:?b3
   \   000024 A4 7F        AND       A, #0x7f
   \   000026 93           LDW       X, Y
   \   000027 1C 0002      ADDW      X, #0x2
   \   00002A F7           LD        (X), A
   1208            alarmmask = (uint8_t)(tmpreg1 & RTC_ALRMAR1_MSK1);
   \   00002B B6 ..        LD        A, S:?b3
   \   00002D A4 80        AND       A, #0x80
   \   00002F B7 ..        LD        S:?b5, A
   1209          
   1210            /* Fill the structure with the read parameters */
   1211            RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = (uint8_t)((uint8_t)tmpreg2 & (uint8_t)((uint8_t)RTC_ALRMAR2_MNT | (uint8_t)RTC_ALRMAR2_MNU));
   \   000031 B6 ..        LD        A, S:?b2
   \   000033 A4 7F        AND       A, #0x7f
   \   000035 93           LDW       X, Y
   \   000036 5C           INCW      X
   \   000037 F7           LD        (X), A
   1212            alarmmask = (uint8_t)((alarmmask) | (uint8_t)((uint8_t)(tmpreg2 & RTC_ALRMAR2_MSK2) >> 1));
   \   000038 B6 ..        LD        A, S:?b2
   \   00003A A4 80        AND       A, #0x80
   \   00003C 44           SRL       A
   \   00003D BA ..        OR        A, S:?b5
   \   00003F B7 ..        LD        S:?b5, A
   1213          
   1214            /* Fill the structure with the read parameters */
   1215            RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = (uint8_t)((uint8_t)tmpreg3 & (uint8_t)((uint8_t)RTC_ALRMAR3_HT | (uint8_t)RTC_ALRMAR3_HU));
   \   000041 B6 ..        LD        A, S:?b1
   \   000043 A4 3F        AND       A, #0x3f
   \   000045 90F7         LD        (Y), A
   1216            RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = (RTC_H12_TypeDef)((uint8_t)tmpreg3 & (uint8_t)RTC_ALRMAR3_PM);
   \   000047 B6 ..        LD        A, S:?b1
   \   000049 A4 40        AND       A, #0x40
   \   00004B 93           LDW       X, Y
   \   00004C 1C 0003      ADDW      X, #0x3
   \   00004F F7           LD        (X), A
   1217            alarmmask = (uint8_t)((alarmmask) | (uint8_t)((uint8_t)((uint8_t)tmpreg3 & (uint8_t)RTC_ALRMAR3_MSK3) >> 2));
   \   000050 B6 ..        LD        A, S:?b1
   \   000052 A4 80        AND       A, #0x80
   \   000054 44           SRL       A
   \   000055 44           SRL       A
   \   000056 BA ..        OR        A, S:?b5
   \   000058 B7 ..        LD        S:?b5, A
   1218          
   1219            /* Fill the structure with the read parameters */
   1220            RTC_AlarmStruct->RTC_AlarmDateWeekDay = (uint8_t)((uint8_t)tmpreg4 & (uint8_t)((uint8_t)RTC_ALRMAR4_DT | (uint8_t)RTC_ALRMAR4_DU));
   \   00005A B6 ..        LD        A, S:?b0
   \   00005C A4 3F        AND       A, #0x3f
   \   00005E 93           LDW       X, Y
   \   00005F 1C 0006      ADDW      X, #0x6
   \   000062 F7           LD        (X), A
   1221            RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = (RTC_AlarmDateWeekDaySel_TypeDef)((uint8_t)tmpreg4 & (uint8_t)RTC_ALRMAR4_WDSEL);
   \   000063 B6 ..        LD        A, S:?b0
   \   000065 A4 40        AND       A, #0x40
   \   000067 93           LDW       X, Y
   \   000068 1C 0005      ADDW      X, #0x5
   \   00006B F7           LD        (X), A
   1222            alarmmask = (uint8_t)((alarmmask) | (uint8_t)((uint8_t)((uint8_t)tmpreg4 & RTC_ALRMAR4_MSK4) >> 3));
   \   00006C B6 ..        LD        A, S:?b0
   \   00006E A4 80        AND       A, #0x80
   \   000070 44           SRL       A
   \   000071 44           SRL       A
   \   000072 44           SRL       A
   \   000073 BA ..        OR        A, S:?b5
   \   000075 B7 ..        LD        S:?b5, A
   1223          
   1224            RTC_AlarmStruct->RTC_AlarmMask = alarmmask;
   \   000077 93           LDW       X, Y
   \   000078 1C 0004      ADDW      X, #0x4
   \   00007B B6 ..        LD        A, S:?b5
   \   00007D F7           LD        (X), A
   1225          
   1226            if (RTC_Format == RTC_Format_BIN)
   \   00007E 3D ..        TNZ       S:?b4
   \   000080 26 2E        JRNE      L:??RTC_GetAlarm_0
   1227            {
   1228              RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours);
   \   000082 90F6         LD        A, (Y)
   \   000084 8D ......    CALLF     Bcd2ToByte
   \   000088 90F7         LD        (Y), A
   1229              RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes);
   \   00008A 93           LDW       X, Y
   \   00008B 5C           INCW      X
   \   00008C F6           LD        A, (X)
   \   00008D 8D ......    CALLF     Bcd2ToByte
   \   000091 93           LDW       X, Y
   \   000092 5C           INCW      X
   \   000093 F7           LD        (X), A
   1230              RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds);
   \   000094 93           LDW       X, Y
   \   000095 1C 0002      ADDW      X, #0x2
   \   000098 F6           LD        A, (X)
   \   000099 8D ......    CALLF     Bcd2ToByte
   \   00009D 93           LDW       X, Y
   \   00009E 1C 0002      ADDW      X, #0x2
   \   0000A1 F7           LD        (X), A
   1231              RTC_AlarmStruct->RTC_AlarmDateWeekDay = Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
   \   0000A2 93           LDW       X, Y
   \   0000A3 1C 0006      ADDW      X, #0x6
   \   0000A6 F6           LD        A, (X)
   \   0000A7 8D ......    CALLF     Bcd2ToByte
   \   0000AB 93           LDW       X, Y
   \   0000AC 1C 0006      ADDW      X, #0x6
   \   0000AF F7           LD        (X), A
   1232            }
   1233          }
   \                     ??RTC_GetAlarm_0:
   \   0000B0 87           RETF
   1234          
   1235          /**
   1236            * @brief  Enables or disables the RTC Alarm.
   1237            * @param  NewState: new state of the alarm. This parameter can be: ENABLE or DISABLE.
   1238            * @retval An ErrorStatus enumeration value:
   1239            *          - SUCCESS: RTC Alarm is enabled/disabled
   1240            *          - ERROR: RTC Alarm is not enabled/disabled
   1241            */

   \                                 In section .far_func.text, align 1
   1242          ErrorStatus RTC_AlarmCmd(FunctionalState NewState)
   1243          {
   \                     RTC_AlarmCmd:
   \   000000 52 02        SUB       SP, #0x2
   1244            __IO uint16_t alrawfcount = 0;
   \   000002 5F           CLRW      X
   \   000003 1F 01        LDW       (0x1,SP), X
   1245            ErrorStatus status = ERROR;
   \   000005 3F ..        CLR       S:?b0
   1246            uint8_t temp1 = 0;
   \   000007 3F ..        CLR       S:?b1
   1247          
   1248            /* Check the parameters */
   1249            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1250          
   1251            /* Disable the write protection for RTC registers */
   1252            RTC->WPR = 0xCA;
   \   000009 35 CA 5159   MOV       L:0x5159, #0xca
   1253            RTC->WPR = 0x53;
   \   00000D 35 53 5159   MOV       L:0x5159, #0x53
   1254          
   1255            /* Configure the Alarm state */
   1256            if (NewState != DISABLE)
   \   000011 4D           TNZ       A
   \   000012 27 0A        JREQ      L:??RTC_AlarmCmd_0
   1257            { /*Enable the Alarm*/
   1258              RTC->CR2 |= (uint8_t)(RTC_CR2_ALRAE);
   \   000014 7210 5149    BSET      L:0x5149, #0x0
   1259              status = SUCCESS;
   \   000018 35 01 ....   MOV       S:?b0, #0x1
   \   00001C 20 2A        JRA       L:??RTC_AlarmCmd_1
   1260            }
   1261            else
   1262            {  /* Disable the Alarm */
   1263              RTC->CR2 &= (uint8_t)~(RTC_CR2_ALRAE) ;
   \                     ??RTC_AlarmCmd_0:
   \   00001E 7211 5149    BRES      L:0x5149, #0x0
   1264          
   1265              /* Wait until ALRxWF flag is set */
   1266              temp1 = (uint8_t)(RTC->ISR1 & RTC_ISR1_ALRAWF);
   \   000022 C6 514C      LD        A, L:0x514c
   \   000025 A4 01        AND       A, #0x1
   \   000027 B7 ..        LD        S:?b1, A
   \   000029 20 05        JRA       L:??RTC_AlarmCmd_2
   1267              while ((alrawfcount != ALRAWF_TIMEOUT) && (temp1 == RESET))
   1268              {
   1269                alrawfcount++;
   \                     ??RTC_AlarmCmd_3:
   \   00002B 1E 01        LDW       X, (0x1,SP)
   \   00002D 5C           INCW      X
   \   00002E 1F 01        LDW       (0x1,SP), X
   1270              }
   \                     ??RTC_AlarmCmd_2:
   \   000030 1E 01        LDW       X, (0x1,SP)
   \   000032 A3 FFFF      CPW       X, #0xffff
   \   000035 27 04        JREQ      L:??RTC_AlarmCmd_4
   \   000037 3D ..        TNZ       S:?b1
   \   000039 27 F0        JREQ      L:??RTC_AlarmCmd_3
   1271          
   1272              if ((RTC->ISR1 &  RTC_ISR1_ALRAWF) == RESET)
   \                     ??RTC_AlarmCmd_4:
   \   00003B 7200 514C 04 BTJT      L:0x514c, #0x0, L:??RTC_AlarmCmd_5
   1273              {
   1274                status = ERROR;
   \   000040 3F ..        CLR       S:?b0
   \   000042 20 04        JRA       L:??RTC_AlarmCmd_1
   1275              }
   1276              else
   1277              {
   1278                status = SUCCESS;
   \                     ??RTC_AlarmCmd_5:
   \   000044 35 01 ....   MOV       S:?b0, #0x1
   1279              }
   1280            }
   1281          
   1282            /* Enable the write protection for RTC registers */
   1283            RTC->WPR = 0xFF; 
   \                     ??RTC_AlarmCmd_1:
   \   000048 35 FF 5159   MOV       L:0x5159, #0xff
   1284          
   1285            /* Return the status*/
   1286            return (ErrorStatus)status;
   \   00004C B6 ..        LD        A, S:?b0
   \   00004E 5B 02        ADD       SP, #0x2
   \   000050 87           RETF
   1287          }
   1288          /**
   1289          * @brief  Configure the RTC Alarm Subseconds value and mask.
   1290          * @param  RTC_AlarmSubSecondValue: specifies the Subseconds value.
   1291          *         This parameter can be a value from 0 to 0x7FFF.
   1292          * @param  RTC_AlarmSubSecondMask:  specifies the Subseconds Mask.
   1293          *         This parameter can be one of the @ref RTC_AlarmSubSecondMask_TypeDef enumeration.
   1294          * @retval An ErrorStatus enumeration value:
   1295          *          - SUCCESS: Alarm Subseconds value and mask are configured
   1296          *          - ERROR: Alarm Subseconds value and mask are  not configured
   1297          */

   \                                 In section .far_func.text, align 1
   1298          ErrorStatus RTC_AlarmSubSecondConfig(uint16_t RTC_AlarmSubSecondValue,
   1299                                               RTC_AlarmSubSecondMask_TypeDef RTC_AlarmSubSecondMask)
   1300          {
   \                     RTC_AlarmSubSecondConfig:
   \   000000 9093         LDW       Y, X
   \   000002 B7 ..        LD        S:?b1, A
   1301            uint8_t alarmstatus = 0;
   \   000004 3F ..        CLR       S:?b0
   1302            ErrorStatus status = ERROR;
   \   000006 4F           CLR       A
   1303          
   1304            /* Check the parameters */
   1305            assert_param(IS_RTC_ALARM_SS_VALUE(RTC_AlarmSubSecondValue));
   1306            assert_param(IS_RTC_ALARM_SS_MASK(RTC_AlarmSubSecondMask));
   1307          
   1308            /* Disable the write protection for RTC registers */
   1309            RTC->WPR = 0xCA;
   \   000007 35 CA 5159   MOV       L:0x5159, #0xca
   1310            RTC->WPR = 0x53;
   \   00000B 35 53 5159   MOV       L:0x5159, #0x53
   1311          
   1312            /* Check if the initialization mode is not set */
   1313            if ((RTC->ISR1 & RTC_ISR1_INITF) == RESET)
   \   00000F 720C 514C 28 BTJT      L:0x514c, #0x6, L:??RTC_AlarmSubSecondConfig_0
   1314            {
   1315              /* save  Alarm status */
   1316              alarmstatus = (uint8_t)(RTC->CR2 | RTC_CR2_ALRAE);
   \   000014 C6 5149      LD        A, L:0x5149
   \   000017 AA 01        OR        A, #0x1
   \   000019 B7 ..        LD        S:?b0, A
   1317          
   1318              /* Disable the Alarm */
   1319              RTC->CR2 &= (uint8_t)~(RTC_CR2_ALRAE);
   \   00001B 7211 5149    BRES      L:0x5149, #0x0
   1320          
   1321              /* Configure the Alarm register */
   1322              RTC->ALRMASSRH = (uint8_t)(RTC_AlarmSubSecondValue >> 8);
   \   00001F 93           LDW       X, Y
   \   000020 4F           CLR       A
   \   000021 01           RRWA      X, A
   \   000022 9F           LD        A, XL
   \   000023 C7 5164      LD        L:0x5164, A
   1323              RTC->ALRMASSRL = (uint8_t)(RTC_AlarmSubSecondValue);
   \   000026 909F         LD        A, YL
   \   000028 C7 5165      LD        L:0x5165, A
   1324              RTC->ALRMASSMSKR = (uint8_t)RTC_AlarmSubSecondMask;
   \   00002B B6 ..        LD        A, S:?b1
   \   00002D C7 5166      LD        L:0x5166, A
   1325          
   1326              /* restore the saved  Alarm status */
   1327              RTC->CR2 |= alarmstatus;
   \   000030 B6 ..        LD        A, S:?b0
   \   000032 CA 5149      OR        A, L:0x5149
   \   000035 C7 5149      LD        L:0x5149, A
   1328          
   1329              status = SUCCESS;
   \   000038 A6 01        LD        A, #0x1
   \   00003A 20 01        JRA       L:??RTC_AlarmSubSecondConfig_1
   1330            }
   1331            else
   1332            {
   1333              status = ERROR;
   \                     ??RTC_AlarmSubSecondConfig_0:
   \   00003C 4F           CLR       A
   1334            }
   1335          
   1336            /* Enable the write protection for RTC registers */
   1337            RTC->WPR = 0xFF; 
   \                     ??RTC_AlarmSubSecondConfig_1:
   \   00003D 35 FF 5159   MOV       L:0x5159, #0xff
   1338          
   1339            return (ErrorStatus)status;
   \   000041 87           RETF
   1340          }
   1341          
   1342          
   1343          
   1344          /**
   1345            * @}
   1346            */
   1347          
   1348          /** @defgroup RTC_Group4 WakeUp Timer configuration functions
   1349           *  @brief   WakeUp Timer configuration functions 
   1350           *
   1351          @verbatim   
   1352           ===============================================================================
   1353                               WakeUp Timer configuration functions
   1354           ===============================================================================  
   1355          
   1356            This section provide functions allowing to program and read the RTC WakeUp.
   1357          
   1358          @endverbatim
   1359            * @{
   1360            */
   1361          /**
   1362            * @brief  Configures the RTC Wakeup clock source.
   1363            * @pre    Before configuring the wakeup unit Clock source, the wake up Unit must
   1364            *         be disabled (if enabled) using RTC_WakeUpCmd(Disable) .
   1365            * @param  RTC_WakeupClockSrc: specifies the Wakeup clock source,
   1366            *         this parameter  can be one of the @ref RTC_WakeupClockSrc_TypeDef enumeration.
   1367            * @retval None
   1368            */

   \                                 In section .far_func.text, align 1
   1369          void RTC_WakeUpClockConfig(RTC_WakeUpClock_TypeDef RTC_WakeUpClock)
   1370          {
   \                     RTC_WakeUpClockConfig:
   \   000000 B7 ..        LD        S:?b0, A
   1371          
   1372            /* Check the parameters */
   1373            assert_param(IS_RTC_WAKEUP_CLOCK(RTC_WakeUpClock));
   1374          
   1375            /* Disable the write protection for RTC registers */
   1376            RTC->WPR = 0xCA;
   \   000002 35 CA 5159   MOV       L:0x5159, #0xca
   1377            RTC->WPR = 0x53;
   \   000006 35 53 5159   MOV       L:0x5159, #0x53
   1378          
   1379            /* Disable the Wakeup timer in RTC_CR2 register */
   1380            RTC->CR2 &= (uint8_t)~RTC_CR2_WUTE;
   \   00000A 7215 5149    BRES      L:0x5149, #0x2
   1381          
   1382            /* Clear the Wakeup Timer clock source bits in CR1 register */
   1383            RTC->CR1 &= (uint8_t)~RTC_CR1_WUCKSEL;
   \   00000E C6 5148      LD        A, L:0x5148
   \   000011 A4 F8        AND       A, #0xf8
   \   000013 C7 5148      LD        L:0x5148, A
   1384          
   1385            /* Configure the clock source */
   1386            RTC->CR1 |= (uint8_t)RTC_WakeUpClock;
   \   000016 B6 ..        LD        A, S:?b0
   \   000018 CA 5148      OR        A, L:0x5148
   \   00001B C7 5148      LD        L:0x5148, A
   1387          
   1388            /* Enable the write protection for RTC registers */
   1389            RTC->WPR = 0xFF; 
   \   00001E 35 FF 5159   MOV       L:0x5159, #0xff
   1390          }
   \   000022 87           RETF
   1391          
   1392          /**
   1393            * @brief  Sets the RTC Wakeup counter.
   1394            * @note   Before configuring the wakeup unit counter, the wake up Unit must be
   1395            *         disabled (if enabled) using RTC_WakeUpCmd(Disable).
   1396            * @param  RTC_WakeupCounter: specifies the Wake up counter,
   1397            *         This parameter can be a value from 0x0000 to 0xFFFF.
   1398            * @retval None.
   1399            */

   \                                 In section .far_func.text, align 1
   1400          void RTC_SetWakeUpCounter(uint16_t RTC_WakeupCounter)
   1401          {
   \                     RTC_SetWakeUpCounter:
   \   000000 9093         LDW       Y, X
   1402            /* Disable the write protection for RTC registers */
   1403            RTC->WPR = 0xCA;
   \   000002 35 CA 5159   MOV       L:0x5159, #0xca
   1404            RTC->WPR = 0x53;
   \   000006 35 53 5159   MOV       L:0x5159, #0x53
   1405          
   1406          
   1407            /* Configure the Wakeup Timer counter */
   1408            RTC->WUTRH = (uint8_t)(RTC_WakeupCounter >> 8);
   \   00000A 93           LDW       X, Y
   \   00000B 4F           CLR       A
   \   00000C 01           RRWA      X, A
   \   00000D 9F           LD        A, XL
   \   00000E C7 5154      LD        L:0x5154, A
   1409            RTC->WUTRL = (uint8_t)(RTC_WakeupCounter);
   \   000011 909F         LD        A, YL
   \   000013 C7 5155      LD        L:0x5155, A
   1410          
   1411            /* Enable the write protection for RTC registers */
   1412            RTC->WPR = 0xFF; 
   \   000016 35 FF 5159   MOV       L:0x5159, #0xff
   1413          }
   \   00001A 87           RETF
   1414          
   1415          /**
   1416            * @brief  Returns the RTC Wakeup timer counter value.
   1417            * @param  None.
   1418            * @retval RTC Wakeup Counter value.
   1419            */

   \                                 In section .far_func.text, align 1
   1420          uint16_t RTC_GetWakeUpCounter(void)
   1421          {
   1422            uint16_t tmpreg = 0;
   \                     RTC_GetWakeUpCounter:
   \   000000 905F         CLRW      Y
   1423          
   1424            /* Get the counter value */
   1425            tmpreg = ((uint16_t)RTC->WUTRH) << 8;
   \   000002 C6 5154      LD        A, L:0x5154
   \   000005 5F           CLRW      X
   \   000006 97           LD        XL, A
   \   000007 4F           CLR       A
   \   000008 02           RLWA      X, A
   \   000009 9093         LDW       Y, X
   1426            tmpreg |= RTC->WUTRL;
   \   00000B C6 5155      LD        A, L:0x5155
   \   00000E 5F           CLRW      X
   \   00000F 97           LD        XL, A
   \   000010 BF ..        LDW       S:?w0, X
   \   000012 51           EXGW      X, Y
   \   000013 01           RRWA      X, A
   \   000014 BA ..        OR        A, S:?b1
   \   000016 01           RRWA      X, A
   \   000017 BA ..        OR        A, S:?b0
   \   000019 01           RRWA      X, A
   \   00001A 51           EXGW      X, Y
   1427          
   1428            /* return RTC Wakeup Counter value*/
   1429            return (uint16_t)tmpreg;
   \   00001B 93           LDW       X, Y
   \   00001C 87           RETF
   1430          }
   1431          
   1432          /**
   1433            * @brief  Enables or Disables the RTC Wakeup Unit.
   1434            * @param  NewState: new state of the Wakeup Unit. This parameter can 
   1435            *                   be: ENABLE or DISABLE.
   1436            * @retval An ErrorStatus enumeration value:
   1437            *          - SUCCESS : RTC Wakeup Unit is enabled/disabled
   1438            *          - ERROR    : RTC Wakeup Unit is not enabled/disabled
   1439            */

   \                                 In section .far_func.text, align 1
   1440          ErrorStatus RTC_WakeUpCmd(FunctionalState NewState)
   1441          {
   1442            ErrorStatus status = ERROR;
   \                     RTC_WakeUpCmd:
   \   000000 3F ..        CLR       S:?b0
   1443            uint16_t wutwfcount = 0;
   \   000002 5F           CLRW      X
   1444          
   1445            /* Check the parameters */
   1446            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1447          
   1448            /* Disable the write protection for RTC registers */
   1449            RTC->WPR = 0xCA;
   \   000003 35 CA 5159   MOV       L:0x5159, #0xca
   1450            RTC->WPR = 0x53;
   \   000007 35 53 5159   MOV       L:0x5159, #0x53
   1451          
   1452            if (NewState != DISABLE)
   \   00000B 4D           TNZ       A
   \   00000C 27 0A        JREQ      L:??RTC_WakeUpCmd_0
   1453            {
   1454              /* Enable the Wakeup Timer */
   1455              RTC->CR2 |= (uint8_t)RTC_CR2_WUTE;
   \   00000E 7214 5149    BSET      L:0x5149, #0x2
   1456          
   1457              status = SUCCESS;
   \   000012 35 01 ....   MOV       S:?b0, #0x1
   \   000016 20 1E        JRA       L:??RTC_WakeUpCmd_1
   1458            }
   1459            else
   1460            {
   1461              /* Disable the Wakeup Timer */
   1462              RTC->CR2 &= (uint8_t)~RTC_CR2_WUTE;
   \                     ??RTC_WakeUpCmd_0:
   \   000018 7215 5149    BRES      L:0x5149, #0x2
   \   00001C 20 01        JRA       L:??RTC_WakeUpCmd_2
   1463          
   1464              /* Wait until WUTWF flag is set */
   1465              while (((RTC->ISR1 & RTC_ISR1_WUTWF) == RESET) && ( wutwfcount != WUTWF_TIMEOUT))
   1466              {
   1467                wutwfcount++;
   \                     ??RTC_WakeUpCmd_3:
   \   00001E 5C           INCW      X
   1468              }
   \                     ??RTC_WakeUpCmd_2:
   \   00001F 7204 514C 05 BTJT      L:0x514c, #0x2, L:??RTC_WakeUpCmd_4
   \   000024 A3 FFFF      CPW       X, #0xffff
   \   000027 26 F5        JRNE      L:??RTC_WakeUpCmd_3
   1469          
   1470              /* Check WUTWF flag is set or not */
   1471              if ((RTC->ISR1 & RTC_ISR1_WUTWF) == RESET)
   \                     ??RTC_WakeUpCmd_4:
   \   000029 7204 514C 04 BTJT      L:0x514c, #0x2, L:??RTC_WakeUpCmd_5
   1472              {
   1473                status = ERROR;
   \   00002E 3F ..        CLR       S:?b0
   \   000030 20 04        JRA       L:??RTC_WakeUpCmd_1
   1474              }
   1475              else
   1476              {
   1477                status = SUCCESS;
   \                     ??RTC_WakeUpCmd_5:
   \   000032 35 01 ....   MOV       S:?b0, #0x1
   1478              }
   1479            }
   1480          
   1481            /* Enable the write protection for RTC registers */
   1482            RTC->WPR = 0xFF; 
   \                     ??RTC_WakeUpCmd_1:
   \   000036 35 FF 5159   MOV       L:0x5159, #0xff
   1483          
   1484            /* Return the status*/
   1485            return (ErrorStatus)status;
   \   00003A B6 ..        LD        A, S:?b0
   \   00003C 87           RETF
   1486          }
   1487          
   1488          
   1489          
   1490          
   1491          
   1492          
   1493          /**
   1494            * @}
   1495            */
   1496          
   1497          /** @defgroup RTC_Group5 Daylight Saving configuration functions
   1498           *  @brief   Daylight Saving configuration functions 
   1499           *
   1500          @verbatim   
   1501           ===============================================================================
   1502                              Daylight Saving configuration functions
   1503           ===============================================================================  
   1504          
   1505            This section provide functions allowing to configure the RTC DayLight Saving.
   1506          
   1507          @endverbatim
   1508            * @{
   1509            */
   1510          
   1511          /**
   1512            * @brief  Adds or subtracts one hour from the current time depending on
   1513            *         the daylight saving parameter.
   1514            * @param  RTC_DayLightSaving: the day light saving Mode
   1515            *         This parameter can be one of the @ref RTC_DayLightSaving_TypeDef 
   1516            *         enumeration.
   1517            * @param  RTC_StoreOperation: the day light saving store operation
   1518            *         This parameter can be one of the @ref RTC_StoreOperation_TypeDef 
   1519            *         enumeration.
   1520            * @retval None
   1521            */

   \                                 In section .far_func.text, align 1
   1522          void RTC_DayLightSavingConfig(RTC_DayLightSaving_TypeDef RTC_DayLightSaving,
   1523                                        RTC_StoreOperation_TypeDef RTC_StoreOperation)
   1524          {
   \                     RTC_DayLightSavingConfig:
   \   000000 B7 ..        LD        S:?b1, A
   \   000002 B6 ..        LD        A, S:?b0
   1525            /* Check the parameters */
   1526            assert_param(IS_RTC_DAYLIGHT_SAVING(RTC_DayLightSaving));
   1527            assert_param(IS_RTC_STORE_OPERATION(RTC_StoreOperation));
   1528          
   1529            /* Disable the write protection for RTC registers */
   1530            RTC->WPR = 0xCA;
   \   000004 35 CA 5159   MOV       L:0x5159, #0xca
   1531            RTC->WPR = 0x53;
   \   000008 35 53 5159   MOV       L:0x5159, #0x53
   1532          
   1533            /* Clear the bits to be configured */
   1534            RTC->CR3 &= (uint8_t)~(RTC_CR3_BCK);
   \   00000C 7215 514A    BRES      L:0x514a, #0x2
   1535          
   1536            /* Configure the RTC_CR3 register */
   1537            RTC->CR3 |= (uint8_t)((uint8_t)RTC_DayLightSaving | (uint8_t)RTC_StoreOperation);
   \   000010 BA ..        OR        A, S:?b1
   \   000012 CA 514A      OR        A, L:0x514a
   \   000015 C7 514A      LD        L:0x514a, A
   1538          
   1539            /* Enable the write protection for RTC registers */
   1540            RTC->WPR = 0xFF; 
   \   000018 35 FF 5159   MOV       L:0x5159, #0xff
   1541          }
   \   00001C 87           RETF
   1542          
   1543          /**
   1544            * @brief  Returns the stored operation.
   1545            * @param  None
   1546            * @retval the store operation, this parameter can be one of
   1547            *         the @ref RTC_StoreOperation_TypeDef enumeration.
   1548            */

   \                                 In section .far_func.text, align 1
   1549          RTC_StoreOperation_TypeDef  RTC_GetStoreOperation(void)
   1550          {
   1551            /* Return the stored operation*/
   1552            return (RTC_StoreOperation_TypeDef)(RTC->CR3 & RTC_CR3_BCK);
   \                     RTC_GetStoreOperation:
   \   000000 C6 514A      LD        A, L:0x514a
   \   000003 A4 04        AND       A, #0x4
   \   000005 87           RETF
   1553          }
   1554          
   1555          
   1556          
   1557          
   1558          
   1559          
   1560          /**
   1561            * @}
   1562            */
   1563          
   1564          /** @defgroup RTC_Group6 Output pin Configuration function
   1565           *  @brief   Output pin Configuration function 
   1566           *
   1567          @verbatim   
   1568           ===============================================================================
   1569                                   Output pin Configuration function
   1570           ===============================================================================  
   1571          
   1572            This section provide functions allowing to configure the RTC Output source.
   1573          
   1574          @endverbatim
   1575            * @{
   1576            */
   1577          /**
   1578            * @brief  Configures the RTC output for the output pin (RTC_ALARM output).
   1579            * @param  RTC_OutputSel: Specifies which signal will be mapped to the output.
   1580            *         This parameter can be one parameter from the 
   1581            *         @ref RTC_OutputSel_TypeDef enumeration.
   1582            * @param  RTC_OutputPolarity: Specifies the polarity of the output signal.
   1583            *         This parameter can be one parameter from the 
   1584            *         @ref RTC_OutputPolarity_TypeDef enumeration.
   1585            * @retval None
   1586            */

   \                                 In section .far_func.text, align 1
   1587          void RTC_OutputConfig(RTC_Output_TypeDef RTC_Output,
   1588                                RTC_OutputPolarity_TypeDef RTC_OutputPolarity)
   1589          {
   \                     RTC_OutputConfig:
   \   000000 B7 ..        LD        S:?b1, A
   1590            /* Check the parameters */
   1591            assert_param(IS_RTC_OUTPUT_SEL(RTC_Output));
   1592            assert_param(IS_RTC_OUTPUT_POL(RTC_OutputPolarity));
   1593          
   1594            /* Disable the write protection for RTC registers */
   1595            RTC->WPR = 0xCA;
   \   000002 35 CA 5159   MOV       L:0x5159, #0xca
   1596            RTC->WPR = 0x53;
   \   000006 35 53 5159   MOV       L:0x5159, #0x53
   1597          
   1598            /* Clear the bits to be configured */
   1599            RTC->CR3 &= (uint8_t)~(RTC_CR3_OSEL | RTC_CR3_POL);
   \   00000A C6 514A      LD        A, L:0x514a
   \   00000D A4 8F        AND       A, #0x8f
   \   00000F C7 514A      LD        L:0x514a, A
   1600          
   1601            /* Configure the output selection and polarity */
   1602            RTC->CR3 |= (uint8_t)((uint8_t)RTC_Output | (uint8_t)RTC_OutputPolarity);
   \   000012 B6 ..        LD        A, S:?b0
   \   000014 BA ..        OR        A, S:?b1
   \   000016 CA 514A      OR        A, L:0x514a
   \   000019 C7 514A      LD        L:0x514a, A
   1603          
   1604            /* Enable the write protection for RTC registers */
   1605            RTC->WPR = 0xFF; 
   \   00001C 35 FF 5159   MOV       L:0x5159, #0xff
   1606          }
   \   000020 87           RETF
   1607          
   1608          
   1609          
   1610          
   1611          /**
   1612            * @}
   1613            */
   1614          
   1615          /** @defgroup RTC_Group7 Output pin Configuration function
   1616           *  @brief   Output pin Configuration function 
   1617           *
   1618          @verbatim   
   1619           ===============================================================================
   1620                                   Output pin Configuration function
   1621           ===============================================================================  
   1622          
   1623            This section provide functions allowing to configure the RTC Output source.
   1624          
   1625          @endverbatim
   1626            * @{
   1627            */
   1628          /**
   1629          * @brief  Configures the Synchronization Shift Control Settings.
   1630          * @param  RTC_ShiftAdd1S : Select to add or not 1 second to the time Calendar.
   1631          *         This parameter can be one parameter from the @ref RTC_ShiftAdd1S_TypeDef
   1632          *         enumeration.
   1633          * @param  RTC_ShiftSubFS: Select the number of Second Fractions to Substitute.
   1634          *         This parameter can be one any value from 0 to 0x7FFF.
   1635           * @retval An ErrorStatus enumeration value:
   1636          *          - SUCCESS: RTC Shift registers are configured
   1637          *          - ERROR: RTC Shift registers are not configured
   1638          */

   \                                 In section .far_func.text, align 1
   1639          ErrorStatus RTC_SynchroShiftConfig(RTC_ShiftAdd1S_TypeDef RTC_ShiftAdd1S,
   1640                                             uint16_t RTC_ShiftSubFS)
   1641          {
   \                     RTC_SynchroShiftConfig:
   \   000000 B7 ..        LD        S:?b1, A
   \   000002 9093         LDW       Y, X
   1642            uint8_t shiftrhreg = 0;
   \   000004 4F           CLR       A
   1643            ErrorStatus status = ERROR;
   \   000005 3F ..        CLR       S:?b0
   1644            uint16_t shpfcount = 0;
   \   000007 5F           CLRW      X
   1645          
   1646            /* Check the parameters */
   1647            assert_param(IS_RTC_SHIFT_ADD1S(RTC_ShiftAdd1S));
   1648            assert_param(IS_RTC_SHIFT_SUBFS(RTC_ShiftSubFS));
   1649          
   1650            /* Disable the write protection for RTC registers */
   1651            RTC->WPR = 0xCA;
   \   000008 35 CA 5159   MOV       L:0x5159, #0xca
   1652            RTC->WPR = 0x53;
   \   00000C 35 53 5159   MOV       L:0x5159, #0x53
   1653          
   1654            /* Check if a Shift is pending*/
   1655            if ((RTC->ISR1 & RTC_ISR1_SHPF) != RESET)
   \   000010 7206 514C 03 BTJT      L:0x514c, #0x3, L:??RTC_SynchroShiftConfig_0
   \   000015 20 0B        JRA       L:??RTC_SynchroShiftConfig_1
   1656            {
   1657              /* wait until the shift is completed*/
   1658              while (((RTC->ISR1 & RTC_ISR1_SHPF) != RESET) && (shpfcount != SHPF_TIMEOUT))
   1659              {
   1660                shpfcount++;
   \                     ??RTC_SynchroShiftConfig_2:
   \   000017 5C           INCW      X
   1661              }
   \                     ??RTC_SynchroShiftConfig_0:
   \   000018 7207 514C 05 BTJF      L:0x514c, #0x3, L:??RTC_SynchroShiftConfig_1
   \   00001D A3 FFFF      CPW       X, #0xffff
   \   000020 26 F5        JRNE      L:??RTC_SynchroShiftConfig_2
   1662            }
   1663          
   1664            /* check if the Shift pending is completed or if there is no Shift operation at all*/
   1665            if ((RTC->ISR1 & RTC_ISR1_SHPF) == RESET)
   \                     ??RTC_SynchroShiftConfig_1:
   \   000022 7206 514C 14 BTJT      L:0x514c, #0x3, L:??RTC_SynchroShiftConfig_3
   1666            {
   1667              /* Configure the Shift settings */
   1668              shiftrhreg = (uint8_t)((uint8_t)(RTC_ShiftSubFS >> 8) | (uint8_t)(RTC_ShiftAdd1S));
   \   000027 93           LDW       X, Y
   \   000028 4F           CLR       A
   \   000029 01           RRWA      X, A
   \   00002A 9F           LD        A, XL
   \   00002B BA ..        OR        A, S:?b1
   1669              RTC->SHIFTRH = (uint8_t)(shiftrhreg);
   \   00002D C7 515A      LD        L:0x515a, A
   1670              RTC->SHIFTRL = (uint8_t)(RTC_ShiftSubFS);
   \   000030 909F         LD        A, YL
   \   000032 C7 515B      LD        L:0x515b, A
   1671          
   1672              status = SUCCESS;
   \   000035 35 01 ....   MOV       S:?b0, #0x1
   \   000039 20 02        JRA       L:??RTC_SynchroShiftConfig_4
   1673            }
   1674            else
   1675            {
   1676              status = ERROR;
   \                     ??RTC_SynchroShiftConfig_3:
   \   00003B 3F ..        CLR       S:?b0
   1677            }
   1678          
   1679            /* Enable the write protection for RTC registers */
   1680            RTC->WPR = 0xFF; 
   \                     ??RTC_SynchroShiftConfig_4:
   \   00003D 35 FF 5159   MOV       L:0x5159, #0xff
   1681          
   1682            return (ErrorStatus)(status);
   \   000041 B6 ..        LD        A, S:?b0
   \   000043 87           RETF
   1683          }
   1684          
   1685          
   1686          
   1687          /**
   1688            * @}
   1689            */
   1690          
   1691          /** @defgroup RTC_Group8 Output pin Configuration function
   1692           *  @brief   Output pin Configuration function 
   1693           *
   1694          @verbatim   
   1695           ===============================================================================
   1696                                   Output pin Configuration function
   1697           ===============================================================================  
   1698          
   1699            This section provide functions allowing to configure the RTC Output source.
   1700          
   1701          @endverbatim
   1702            * @{
   1703            */
   1704          /**
   1705          * @brief  Configures the Smooth Calibration Settings.
   1706          * @param  RTC_SmoothCalibPeriod : Select the Smooth Calibration Period.
   1707          *         This parameter can be one parameter from
   1708          *         the @ref RTC_SmoothCalibPeriod_TypeDef enumeration.
   1709          * @param  RTC_SmoothCalibPlusPulses : Select to Set or reset the CALP bit.
   1710          *         This parameter can be one parameter from the
   1711          *         @ref RTC_SmoothCalibPlusPulses_TypeDef enumeration.
   1712          * @param  RTC_SmouthCalibMinusPulsesValue: Select the value of CALM[8:0] bits.
   1713          *         This parameter can be one any value from 0 to 0x01FF.
   1714          * @retval An ErrorStatus enumeration value:
   1715          *          - SUCCESS: RTC Calib registers are configured
   1716          *          - ERROR: RTC Calib registers are not configured
   1717          */

   \                                 In section .far_func.text, align 1
   1718          ErrorStatus RTC_SmoothCalibConfig(RTC_SmoothCalibPeriod_TypeDef RTC_SmoothCalibPeriod,
   1719                                            RTC_SmoothCalibPlusPulses_TypeDef RTC_SmoothCalibPlusPulses,
   1720                                            uint16_t RTC_SmouthCalibMinusPulsesValue)
   1721          {
   \                     RTC_SmoothCalibConfig:
   \   000000 B7 ..        LD        S:?b2, A
   \   000002 9093         LDW       Y, X
   1722            ErrorStatus status = ERROR;
   \   000004 4F           CLR       A
   1723            uint16_t recalpfcount = 0;
   \   000005 5F           CLRW      X
   1724          
   1725            /* Check the parameters */
   1726            assert_param(IS_RTC_SMOOTH_CALIB_PERIOD(RTC_SmoothCalibPeriod));
   1727            assert_param(IS_RTC_SMOOTH_CALIB_PLUS(RTC_SmoothCalibPlusPulses));
   1728            assert_param(IS_RTC_SMOOTH_CALIB_MINUS(RTC_SmouthCalibMinusPulsesValue));
   1729          
   1730            /* Disable the write protection for RTC registers */
   1731            RTC->WPR = 0xCA;
   \   000006 35 CA 5159   MOV       L:0x5159, #0xca
   1732            RTC->WPR = 0x53;
   \   00000A 35 53 5159   MOV       L:0x5159, #0x53
   1733          
   1734            /* check if a calibration is pending*/
   1735            if ((RTC->ISR1 & RTC_ISR1_RECALPF) != RESET)
   \   00000E 7202 514C 03 BTJT      L:0x514c, #0x1, L:??RTC_SmoothCalibConfig_0
   \   000013 20 0B        JRA       L:??RTC_SmoothCalibConfig_1
   1736            {
   1737              /* wait until the Calibration is completed*/
   1738              while (((RTC->ISR1 & RTC_ISR1_RECALPF) != RESET) && (recalpfcount != RECALPF_TIMEOUT))
   1739              {
   1740                recalpfcount++;
   \                     ??RTC_SmoothCalibConfig_2:
   \   000015 5C           INCW      X
   1741              }
   \                     ??RTC_SmoothCalibConfig_0:
   \   000016 7203 514C 05 BTJF      L:0x514c, #0x1, L:??RTC_SmoothCalibConfig_1
   \   00001B A3 FFFF      CPW       X, #0xffff
   \   00001E 26 F5        JRNE      L:??RTC_SmoothCalibConfig_2
   1742            }
   1743          
   1744            /* check if the calibration pending is completed or if there is 
   1745               no calibration operation at all*/
   1746            if ((RTC->ISR1 & RTC_ISR1_RECALPF) == RESET)
   \                     ??RTC_SmoothCalibConfig_1:
   \   000020 7202 514C 19 BTJT      L:0x514c, #0x1, L:??RTC_SmoothCalibConfig_3
   1747            {
   1748              /* Configure the Smooth calibration settings */
   1749              RTC->CALRH = (uint8_t)((uint8_t)((uint8_t)RTC_SmoothCalibPeriod | \
   1750                                     (uint8_t)RTC_SmoothCalibPlusPulses) | \
   1751                                     (uint8_t)((uint16_t)RTC_SmouthCalibMinusPulsesValue >> 8));
   \   000025 93           LDW       X, Y
   \   000026 4F           CLR       A
   \   000027 01           RRWA      X, A
   \   000028 41           EXG       A, XL
   \   000029 B7 ..        LD        S:?b1, A
   \   00002B 41           EXG       A, XL
   \   00002C B6 ..        LD        A, S:?b0
   \   00002E BA ..        OR        A, S:?b2
   \   000030 BA ..        OR        A, S:?b1
   \   000032 C7 516A      LD        L:0x516a, A
   1752              RTC->CALRL = (uint8_t)(RTC_SmouthCalibMinusPulsesValue);
   \   000035 909F         LD        A, YL
   \   000037 C7 516B      LD        L:0x516b, A
   1753          
   1754              status = SUCCESS;
   \   00003A A6 01        LD        A, #0x1
   \   00003C 20 01        JRA       L:??RTC_SmoothCalibConfig_4
   1755            }
   1756            else
   1757            {
   1758              status = ERROR;
   \                     ??RTC_SmoothCalibConfig_3:
   \   00003E 4F           CLR       A
   1759            }
   1760          
   1761            /* Enable the write protection for RTC registers */
   1762            RTC->WPR = 0xFF; 
   \                     ??RTC_SmoothCalibConfig_4:
   \   00003F 35 FF 5159   MOV       L:0x5159, #0xff
   1763          
   1764            return (ErrorStatus)(status);
   \   000043 87           RETF
   1765          }
   1766          
   1767          
   1768          /**
   1769            * @}
   1770            */
   1771          
   1772          /** @defgroup RTC_Group9 Digital Calibration configuration functions
   1773           *  @brief   Digital Calibration configuration functions 
   1774           *
   1775          @verbatim   
   1776           ===============================================================================
   1777                            Calibration configuration functions
   1778           ===============================================================================  
   1779          
   1780          @endverbatim
   1781            * @{
   1782            */
   1783          /**
   1784          * @brief  Configure the Calibration Pin-out (RTC_CALIB) Selection (1Hz or 512Hz).
   1785          * @param  RTC_CalibOutput : Select the Calibration output Selection .
   1786          *         This parameter can be one parameter from the
   1787          *         @ref RTC_CalibOutput_TypeDef enumeration.
   1788          * @retval None
   1789          */

   \                                 In section .far_func.text, align 1
   1790          void RTC_CalibOutputConfig(RTC_CalibOutput_TypeDef RTC_CalibOutput)
   1791          {
   1792            /* Check the parameters */
   1793            assert_param(IS_RTC_CALOUTPUT_SELECT(RTC_CalibOutput));
   1794          
   1795            /* Disable the write protection for RTC registers */
   1796            RTC->WPR = 0xCA;
   \                     RTC_CalibOutputConfig:
   \   000000 35 CA 5159   MOV       L:0x5159, #0xca
   1797            RTC->WPR = 0x53;
   \   000004 35 53 5159   MOV       L:0x5159, #0x53
   1798          
   1799            if (RTC_CalibOutput != RTC_CalibOutput_512Hz)
   \   000008 4D           TNZ       A
   \   000009 27 06        JREQ      L:??RTC_CalibOutputConfig_0
   1800            {
   1801              /* Enable the RTC clock output */
   1802              RTC->CR3 |= (uint8_t)RTC_CR3_COSEL;
   \   00000B 7216 514A    BSET      L:0x514a, #0x3
   \   00000F 20 04        JRA       L:??RTC_CalibOutputConfig_1
   1803            }
   1804            else
   1805            {
   1806              /* Disable the RTC clock output */
   1807              RTC->CR3 &= (uint8_t)~RTC_CR3_COSEL;
   \                     ??RTC_CalibOutputConfig_0:
   \   000011 7217 514A    BRES      L:0x514a, #0x3
   1808            }
   1809          
   1810            /* Enable the write protection for RTC registers */
   1811            RTC->WPR = 0xFF; 
   \                     ??RTC_CalibOutputConfig_1:
   \   000015 35 FF 5159   MOV       L:0x5159, #0xff
   1812          }
   \   000019 87           RETF
   1813          
   1814          /**
   1815          * @brief  Enables or disables the RTC clock to be output through the relative pin.
   1816          * @param  NewState: new state of the RTC Calibration output
   1817            *         This parameter can be: ENABLE or DISABLE.
   1818          * @retval None
   1819          */

   \                                 In section .far_func.text, align 1
   1820          void RTC_CalibOutputCmd(FunctionalState NewState)
   1821          {
   1822            /* Check the parameters */
   1823            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1824          
   1825            /* Disable the write protection for RTC registers */
   1826            RTC->WPR = 0xCA;
   \                     RTC_CalibOutputCmd:
   \   000000 35 CA 5159   MOV       L:0x5159, #0xca
   1827            RTC->WPR = 0x53;
   \   000004 35 53 5159   MOV       L:0x5159, #0x53
   1828          
   1829            if (NewState != DISABLE)
   \   000008 4D           TNZ       A
   \   000009 27 06        JREQ      L:??RTC_CalibOutputCmd_0
   1830            {
   1831              /* Enable the RTC clock output */
   1832              RTC->CR3 |= (uint8_t)RTC_CR3_COE;
   \   00000B 721E 514A    BSET      L:0x514a, #0x7
   \   00000F 20 04        JRA       L:??RTC_CalibOutputCmd_1
   1833            }
   1834            else
   1835            {
   1836              /* Disable the RTC clock output */
   1837              RTC->CR3 &= (uint8_t)~RTC_CR3_COE;
   \                     ??RTC_CalibOutputCmd_0:
   \   000011 721F 514A    BRES      L:0x514a, #0x7
   1838            }
   1839          
   1840            /* Enable the write protection for RTC registers */
   1841            RTC->WPR = 0xFF; 
   \                     ??RTC_CalibOutputCmd_1:
   \   000015 35 FF 5159   MOV       L:0x5159, #0xff
   1842          }
   \   000019 87           RETF
   1843          
   1844          
   1845          /**
   1846            * @}
   1847            */
   1848          
   1849          /** @defgroup RTC_Group10 Tampers configuration functions
   1850           *  @brief   Tampers configuration functions 
   1851           *
   1852          @verbatim   
   1853           ===============================================================================
   1854                                 Tampers configuration functions
   1855           ===============================================================================  
   1856          
   1857          @endverbatim
   1858            * @{
   1859            */
   1860          
   1861          /**
   1862          * @brief  Configures the Tamper Sensitive Level.
   1863          * @param  RTC_Tamper: Select the tamper to configure.
   1864          *         This parameter can be one parameter from the @ref RTC_Tamper_TypeDef
   1865          *         enumeration.
   1866          * @param  RTC_TamperLevel: Select the tamper Sensitive Level.
   1867          *         This parameter can be one parameter from the 
   1868          *         @ref RTC_TamperLevel_TypeDef enumeration.
   1869          * @retval None
   1870          */

   \                                 In section .far_func.text, align 1
   1871          void RTC_TamperLevelConfig(RTC_Tamper_TypeDef RTC_Tamper,
   1872                                     RTC_TamperLevel_TypeDef RTC_TamperLevel)
   1873          {
   1874            /* Check the parameters */
   1875            assert_param(IS_RTC_TAMPER((uint8_t)RTC_Tamper));
   1876            assert_param(IS_RTC_TAMPER_LEVEL(RTC_TamperLevel));
   1877          
   1878            /* Disable the write protection for RTC registers */
   1879            RTC->WPR = 0xCA;
   \                     RTC_TamperLevelConfig:
   \   000000 35 CA 5159   MOV       L:0x5159, #0xca
   1880            RTC->WPR = 0x53;
   \   000004 35 53 5159   MOV       L:0x5159, #0x53
   1881          
   1882            if (RTC_TamperLevel != RTC_TamperLevel_Low)
   \   000008 3D ..        TNZ       S:?b0
   \   00000A 27 09        JREQ      L:??RTC_TamperLevelConfig_0
   1883            {
   1884              /* Enable the selected Tampers */
   1885              RTC->TCR1 |= (uint8_t)(RTC_Tamper << 1);
   \   00000C 48           SLL       A
   \   00000D CA 516C      OR        A, L:0x516c
   \   000010 C7 516C      LD        L:0x516c, A
   \   000013 20 08        JRA       L:??RTC_TamperLevelConfig_1
   1886            }
   1887            else
   1888            {
   1889              /* Disable the selected Tampers */
   1890              RTC->TCR1 &= (uint8_t)~(uint8_t)(RTC_Tamper << 1);
   \                     ??RTC_TamperLevelConfig_0:
   \   000015 48           SLL       A
   \   000016 43           CPL       A
   \   000017 C4 516C      AND       A, L:0x516c
   \   00001A C7 516C      LD        L:0x516c, A
   1891            }
   1892          
   1893            /* Enable the write protection for RTC registers */
   1894            RTC->WPR = 0xFF; 
   \                     ??RTC_TamperLevelConfig_1:
   \   00001D 35 FF 5159   MOV       L:0x5159, #0xff
   1895          }
   \   000021 87           RETF
   1896          /**
   1897            * @brief  Configures the Tampers Filter.
   1898            * @param  RTC_TamperFilter: Specifies the tampers filter.
   1899            *         This parameter can be one parameter from the
   1900            *         @ref RTC_TamperFilter_TypeDef enumeration.
   1901            * @retval None
   1902            */

   \                                 In section .far_func.text, align 1
   1903          void RTC_TamperFilterConfig(RTC_TamperFilter_TypeDef RTC_TamperFilter)
   1904          {
   \                     RTC_TamperFilterConfig:
   \   000000 B7 ..        LD        S:?b0, A
   1905          
   1906            /* Check the parameters */
   1907            assert_param(IS_RTC_TAMPER_FILTER(RTC_TamperFilter));
   1908          
   1909            /* Disable the write protection for RTC registers */
   1910            RTC->WPR = 0xCA;
   \   000002 35 CA 5159   MOV       L:0x5159, #0xca
   1911            RTC->WPR = 0x53;
   \   000006 35 53 5159   MOV       L:0x5159, #0x53
   1912          
   1913            /*clear flags before configuration */
   1914            RTC->TCR2 &= (uint8_t)~(RTC_TCR2_TAMPFLT);
   \   00000A C6 516D      LD        A, L:0x516d
   \   00000D A4 E7        AND       A, #0xe7
   \   00000F C7 516D      LD        L:0x516d, A
   1915          
   1916            /* Configure the RTC_TCR register */
   1917            RTC->TCR2 |= (uint8_t)RTC_TamperFilter;
   \   000012 B6 ..        LD        A, S:?b0
   \   000014 CA 516D      OR        A, L:0x516d
   \   000017 C7 516D      LD        L:0x516d, A
   1918          
   1919            /* Enable the write protection for RTC registers */
   1920            RTC->WPR = 0xFF; 
   \   00001A 35 FF 5159   MOV       L:0x5159, #0xff
   1921          
   1922          }
   \   00001E 87           RETF
   1923          
   1924          /**
   1925            * @brief  Configures the Tampers Sampling Frequency.
   1926            * @param  RTC_TamperSamplingFreq: Specifies the tampers Sampling Frequency.
   1927            *         This parameter can be one parameter from the
   1928            *         @ref RTC_TamperSamplingFreq_TypeDef enumeration.
   1929            * @retval None
   1930            */

   \                                 In section .far_func.text, align 1
   1931          void RTC_TamperSamplingFreqConfig(RTC_TamperSamplingFreq_TypeDef RTC_TamperSamplingFreq)
   1932          {
   \                     RTC_TamperSamplingFreqConfig:
   \   000000 B7 ..        LD        S:?b0, A
   1933            /* Check the parameters */
   1934            assert_param(IS_RTC_TAMPER_SAMPLING_FREQ(RTC_TamperSamplingFreq));
   1935          
   1936            /* Disable the write protection for RTC registers */
   1937            RTC->WPR = 0xCA;
   \   000002 35 CA 5159   MOV       L:0x5159, #0xca
   1938            RTC->WPR = 0x53;
   \   000006 35 53 5159   MOV       L:0x5159, #0x53
   1939          
   1940            /* Clear flags before configuration */
   1941            RTC->TCR2 &= (uint8_t)~(RTC_TCR2_TAMPFREQ);
   \   00000A C6 516D      LD        A, L:0x516d
   \   00000D A4 F8        AND       A, #0xf8
   \   00000F C7 516D      LD        L:0x516d, A
   1942          
   1943            /* Configure the RTC_TCR register */
   1944            RTC->TCR2 |= (uint8_t)RTC_TamperSamplingFreq;
   \   000012 B6 ..        LD        A, S:?b0
   \   000014 CA 516D      OR        A, L:0x516d
   \   000017 C7 516D      LD        L:0x516d, A
   1945          
   1946            /* Enable the write protection for RTC registers */
   1947            RTC->WPR = 0xFF; 
   \   00001A 35 FF 5159   MOV       L:0x5159, #0xff
   1948          }
   \   00001E 87           RETF
   1949          
   1950          /**
   1951          * @brief  Configures the Tampers Pins input Precharge Duration.
   1952          * @param  RTC_TamperPrechargeDuration: Specifies the Tampers Pins input
   1953          *         Precharge Duration.
   1954          *         This parameter can be one parameter from the
   1955          *         @ref RTC_TamperPrechargeDuration_TypeDef enumeration.
   1956          * @retval None
   1957          */

   \                                 In section .far_func.text, align 1
   1958          void RTC_TamperPinsPrechargeDuration(RTC_TamperPrechargeDuration_TypeDef RTC_TamperPrechargeDuration)
   1959          {
   \                     RTC_TamperPinsPrechargeDuration:
   \   000000 B7 ..        LD        S:?b0, A
   1960            /* Check the parameters */
   1961            assert_param(IS_RTC_TAMPER_PINS_PRECHAR_DURATION(RTC_TamperPrechargeDuration));
   1962          
   1963            /* Disable the write protection for RTC registers */
   1964            RTC->WPR = 0xCA;
   \   000002 35 CA 5159   MOV       L:0x5159, #0xca
   1965            RTC->WPR = 0x53;
   \   000006 35 53 5159   MOV       L:0x5159, #0x53
   1966          
   1967            /* Clear the tampers  pull-up  and precharge/discharge duration Old settings*/
   1968            RTC->TCR2 &= (uint8_t)~(RTC_TCR2_TAMPPUDIS | RTC_TCR2_TAMPPRCH);
   \   00000A C6 516D      LD        A, L:0x516d
   \   00000D A4 1F        AND       A, #0x1f
   \   00000F C7 516D      LD        L:0x516d, A
   1969          
   1970            /* Configure the Tampers Precharge Duration  and pull-up New settings*/
   1971            RTC->TCR2 |= (uint8_t)RTC_TamperPrechargeDuration;
   \   000012 B6 ..        LD        A, S:?b0
   \   000014 CA 516D      OR        A, L:0x516d
   \   000017 C7 516D      LD        L:0x516d, A
   1972          
   1973            /* Enable the write protection for RTC registers */
   1974            RTC->WPR = 0xFF; 
   \   00001A 35 FF 5159   MOV       L:0x5159, #0xff
   1975          }
   \   00001E 87           RETF
   1976          
   1977          
   1978          /**
   1979          * @brief  Enables or Disables the Tamper detection.
   1980          * @param  RTC_Tamper: Select the tamper to configure.
   1981          *         This parameter can be one parameter from the @ref RTC_Tamper_TypeDef
   1982          *         enumeration.
   1983          * @param  NewState: new state of the tamper pin.
   1984            *         This parameter can be: ENABLE or DISABLE.
   1985          * @retval None
   1986          */

   \                                 In section .far_func.text, align 1
   1987          void RTC_TamperCmd(RTC_Tamper_TypeDef RTC_Tamper,
   1988                             FunctionalState NewState)
   1989          {
   1990          
   1991            /* Check the parameters */
   1992            assert_param(IS_RTC_TAMPER((uint8_t)RTC_Tamper));
   1993            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1994          
   1995            /* Disable the write protection for RTC registers */
   1996            RTC->WPR = 0xCA;
   \                     RTC_TamperCmd:
   \   000000 35 CA 5159   MOV       L:0x5159, #0xca
   1997            RTC->WPR = 0x53;
   \   000004 35 53 5159   MOV       L:0x5159, #0x53
   1998          
   1999          
   2000            if (NewState != DISABLE)
   \   000008 3D ..        TNZ       S:?b0
   \   00000A 27 08        JREQ      L:??RTC_TamperCmd_0
   2001            {
   2002              /* Enable the selected Tampers */
   2003              RTC->TCR1 |= (uint8_t)RTC_Tamper;
   \   00000C CA 516C      OR        A, L:0x516c
   \   00000F C7 516C      LD        L:0x516c, A
   \   000012 20 07        JRA       L:??RTC_TamperCmd_1
   2004            }
   2005            else
   2006            {
   2007              /* Disable the selected Tampers */
   2008              RTC->TCR1 &= (uint8_t)~RTC_Tamper;
   \                     ??RTC_TamperCmd_0:
   \   000014 43           CPL       A
   \   000015 C4 516C      AND       A, L:0x516c
   \   000018 C7 516C      LD        L:0x516c, A
   2009            }
   2010          
   2011          
   2012            /* Enable the write protection for RTC registers */
   2013            RTC->WPR = 0xFF; 
   \                     ??RTC_TamperCmd_1:
   \   00001B 35 FF 5159   MOV       L:0x5159, #0xff
   2014          }
   \   00001F 87           RETF
   2015          
   2016          
   2017          
   2018          /**
   2019            * @}
   2020            */
   2021          
   2022          /** @defgroup RTC_Group11 Interrupts and flags management functions
   2023           *  @brief   Interrupts and flags management functions  
   2024           *
   2025          @verbatim   
   2026           ===============================================================================
   2027                                 Interrupts and flags management functions
   2028           ===============================================================================  
   2029           
   2030           To enable the RTC Alarm interrupt, the following sequence is required:
   2031             - Configure the RTC to generate RTC alarm (Alarm A) using the RTC_SetAlarm() 
   2032               and RTC_AlarmCmd() functions.
   2033          
   2034           To enable the RTC Wakeup interrupt, the following sequence is required:
   2035             - Configure the RTC to generate the RTC wakeup timer event using the 
   2036               RTC_WakeUpClockConfig(), RTC_SetWakeUpCounter() and RTC_WakeUpCmd() functions.
   2037          
   2038           To enable the RTC Tamper interrupt, the following sequence is required:
   2039             - Configure the RTC to detect the RTC tamper event using the 
   2040               RTC_TamperTriggerConfig() and RTC_TamperCmd() functions.
   2041          
   2042          
   2043          
   2044          @endverbatim
   2045            * @{
   2046            */
   2047          /**
   2048          * @brief  Enables or Disables the specified RTC interrupts.
   2049          * @param  RTC_IT: specifies the RTC interrupt sources to be enabled or disabled.
   2050          *         This parameter can be any combination of the following values:
   2051          *         @arg RTC_IT_ALRA:  Alarm A interrupt
   2052          *         @arg RTC_IT_TAMP:  Tampers interrupt
   2053          *         @arg RTC_IT_WUT:  WakeUp Timer interrupt
   2054          * @param  NewState: new state of the specified RTC interrupts.
   2055            *         This parameter can be: ENABLE or DISABLE.
   2056          * @retval None
   2057          */

   \                                 In section .far_func.text, align 1
   2058          void RTC_ITConfig(RTC_IT_TypeDef RTC_IT, FunctionalState NewState)
   2059          {
   2060            /* Check the parameters */
   2061            assert_param(IS_RTC_CONFIG_IT(RTC_IT));
   2062            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2063          
   2064            /* Disable the write protection for RTC registers */
   2065            RTC->WPR = 0xCA;
   \                     RTC_ITConfig:
   \   000000 35 CA 5159   MOV       L:0x5159, #0xca
   2066            RTC->WPR = 0x53;
   \   000004 35 53 5159   MOV       L:0x5159, #0x53
   2067          
   2068            if (NewState != DISABLE)
   \   000008 4D           TNZ       A
   \   000009 27 14        JREQ      L:??RTC_ITConfig_0
   2069            {
   2070              /* Enable the Interrupts */
   2071              RTC->CR2 |= (uint8_t)((uint16_t)RTC_IT & (uint16_t)0x00F0);
   \   00000B 9F           LD        A, XL
   \   00000C A4 F0        AND       A, #0xf0
   \   00000E CA 5149      OR        A, L:0x5149
   \   000011 C7 5149      LD        L:0x5149, A
   2072              RTC->TCR1 |= (uint8_t)((uint16_t)RTC_IT & RTC_TCR1_TAMPIE);
   \   000014 9F           LD        A, XL
   \   000015 A4 01        AND       A, #0x1
   \   000017 CA 516C      OR        A, L:0x516c
   \   00001A C7 516C      LD        L:0x516c, A
   \   00001D 20 14        JRA       L:??RTC_ITConfig_1
   2073            }
   2074            else
   2075            {
   2076              /* Disable the Interrupts */
   2077              RTC->CR2  &= (uint8_t)~(uint8_t)((uint16_t)RTC_IT & (uint16_t)0x00F0);
   \                     ??RTC_ITConfig_0:
   \   00001F 9F           LD        A, XL
   \   000020 A4 F0        AND       A, #0xf0
   \   000022 43           CPL       A
   \   000023 C4 5149      AND       A, L:0x5149
   \   000026 C7 5149      LD        L:0x5149, A
   2078              RTC->TCR1 &= (uint8_t)~(uint8_t)((uint16_t)RTC_IT & (uint16_t)RTC_TCR1_TAMPIE);
   \   000029 9F           LD        A, XL
   \   00002A A4 01        AND       A, #0x1
   \   00002C 43           CPL       A
   \   00002D C4 516C      AND       A, L:0x516c
   \   000030 C7 516C      LD        L:0x516c, A
   2079            }
   2080          
   2081            /* Enable the write protection for RTC registers */
   2082            RTC->WPR = 0xFF; 
   \                     ??RTC_ITConfig_1:
   \   000033 35 FF 5159   MOV       L:0x5159, #0xff
   2083          }
   \   000037 87           RETF
   2084          /**
   2085          * @brief  Checks whether the specified RTC flag is set or not.
   2086          * @param  RTC_FLAG: specifies the flag to check.
   2087          *         This parameter can be one of the @ref RTC_Flag_TypeDef enumeration.
   2088          * @retval Status of RTC_FLAG (SET or RESET)
   2089          */

   \                                 In section .far_func.text, align 1
   2090          FlagStatus RTC_GetFlagStatus(RTC_Flag_TypeDef RTC_FLAG)
   2091          {
   \                     RTC_GetFlagStatus:
   \   000000 BF ..        LDW       S:?w2, X
   2092            FlagStatus flagstatus = RESET;
   \   000002 3F ..        CLR       S:?b0
   2093            uint16_t tmpreg1 = 0;
   \   000004 905F         CLRW      Y
   2094            uint16_t tmpreg2 = 0;
   \   000006 3F ..        CLR       S:?b3
   \   000008 3F ..        CLR       S:?b2
   2095          
   2096            /* Check the parameters */
   2097            assert_param(IS_RTC_GET_FLAG(RTC_FLAG));
   2098          
   2099            /* Get all the flags */
   2100            tmpreg2 = (uint16_t)((uint16_t)RTC->ISR1 << 8);
   \   00000A C6 514C      LD        A, L:0x514c
   \   00000D 5F           CLRW      X
   \   00000E 97           LD        XL, A
   \   00000F 4F           CLR       A
   \   000010 02           RLWA      X, A
   \   000011 BF ..        LDW       S:?w1, X
   2101            tmpreg1 = (uint16_t)((uint16_t)((uint16_t)(RTC->ISR2)) | tmpreg2);
   \   000013 C6 514D      LD        A, L:0x514d
   \   000016 5F           CLRW      X
   \   000017 97           LD        XL, A
   \   000018 01           RRWA      X, A
   \   000019 BA ..        OR        A, S:?b3
   \   00001B 01           RRWA      X, A
   \   00001C BA ..        OR        A, S:?b2
   \   00001E 01           RRWA      X, A
   \   00001F 9093         LDW       Y, X
   2102          
   2103            /* Return the status of the flag */
   2104            if ((tmpreg1 & (uint16_t)RTC_FLAG) != RESET)
   \   000021 51           EXGW      X, Y
   \   000022 01           RRWA      X, A
   \   000023 B4 ..        AND       A, S:?b5
   \   000025 01           RRWA      X, A
   \   000026 B4 ..        AND       A, S:?b4
   \   000028 01           RRWA      X, A
   \   000029 51           EXGW      X, Y
   \   00002A 905D         TNZW      Y
   \   00002C 27 06        JREQ      L:??RTC_GetFlagStatus_0
   2105            {
   2106              flagstatus = SET;
   \   00002E 35 01 ....   MOV       S:?b0, #0x1
   \   000032 20 02        JRA       L:??RTC_GetFlagStatus_1
   2107            }
   2108            else
   2109            {
   2110              flagstatus = RESET;
   \                     ??RTC_GetFlagStatus_0:
   \   000034 3F ..        CLR       S:?b0
   2111            }
   2112            return (FlagStatus)flagstatus;
   \                     ??RTC_GetFlagStatus_1:
   \   000036 B6 ..        LD        A, S:?b0
   \   000038 87           RETF
   2113          }
   2114          
   2115          /**
   2116          * @brief  Clears the RTC's pending flags.
   2117          * @param  RTC_FLAG: specifies the RTC flag to clear.
   2118          *         This parameter can be any combination of the @ref RTC_Flag_TypeDef
   2119          *         enumeration.
   2120          * @retval None
   2121          */

   \                                 In section .far_func.text, align 1
   2122          void RTC_ClearFlag(RTC_Flag_TypeDef RTC_FLAG)
   2123          {
   2124            /* Check the parameters */
   2125            assert_param(IS_RTC_CLEAR_FLAG((uint16_t)RTC_FLAG));
   2126          
   2127            /* Clear the Flags in the RTC_ISR registers */
   2128            RTC->ISR2 = (uint8_t)~((uint8_t)RTC_FLAG) ;
   \                     RTC_ClearFlag:
   \   000000 9F           LD        A, XL
   \   000001 43           CPL       A
   \   000002 C7 514D      LD        L:0x514d, A
   2129            RTC->ISR1 = (uint8_t)(((uint8_t)~(uint8_t)((uint16_t)RTC_FLAG >> (uint8_t)8)) & ((uint8_t)~(uint8_t)(RTC_ISR1_INIT)));
   \   000005 4F           CLR       A
   \   000006 01           RRWA      X, A
   \   000007 9F           LD        A, XL
   \   000008 43           CPL       A
   \   000009 A4 7F        AND       A, #0x7f
   \   00000B C7 514C      LD        L:0x514c, A
   2130          }
   \   00000E 87           RETF
   2131          
   2132          /**
   2133          * @brief  Checks whether the specified RTC interrupt has occurred or not.
   2134          * @param  RTC_IT: specifies the RTC interrupt source to check.
   2135          *         This parameter can be one of the @ref RTC_IT_TypeDef enumeration.
   2136          * @retval Status of RTC_IT (SET or RESET).
   2137          */

   \                                 In section .far_func.text, align 1
   2138          ITStatus RTC_GetITStatus(RTC_IT_TypeDef RTC_IT)
   2139          {
   2140            ITStatus itstatus = RESET;
   \                     RTC_GetITStatus:
   \   000000 3F ..        CLR       S:?b0
   2141            uint8_t enablestatus = 0, tmpreg = 0;
   \   000002 3F ..        CLR       S:?b2
   \   000004 3F ..        CLR       S:?b1
   2142          
   2143            /* Check the parameters */
   2144            assert_param(IS_RTC_GET_IT(RTC_IT));
   2145          
   2146            /* Get the Interrupt enable Status */
   2147            enablestatus = (uint8_t)(RTC->CR2 & (uint16_t)RTC_IT);
   \   000006 9F           LD        A, XL
   \   000007 C4 5149      AND       A, L:0x5149
   \   00000A B7 ..        LD        S:?b2, A
   2148          
   2149            /* Get the Interrupt pending bit */
   2150            tmpreg = (uint8_t)(RTC->ISR2 & (uint8_t)((uint16_t)RTC_IT >> 4));
   \   00000C 54           SRLW      X
   \   00000D 54           SRLW      X
   \   00000E 54           SRLW      X
   \   00000F 54           SRLW      X
   \   000010 9F           LD        A, XL
   \   000011 C4 514D      AND       A, L:0x514d
   \   000014 B7 ..        LD        S:?b1, A
   2151          
   2152            /* Get the status of the Interrupt */
   2153            if ((enablestatus != (uint8_t)RESET) && (tmpreg != (uint8_t)RESET))
   \   000016 3D ..        TNZ       S:?b2
   \   000018 27 0A        JREQ      L:??RTC_GetITStatus_0
   \   00001A 3D ..        TNZ       S:?b1
   \   00001C 27 06        JREQ      L:??RTC_GetITStatus_0
   2154            {
   2155              itstatus = SET;
   \   00001E 35 01 ....   MOV       S:?b0, #0x1
   \   000022 20 02        JRA       L:??RTC_GetITStatus_1
   2156            }
   2157            else
   2158            {
   2159              itstatus = RESET;
   \                     ??RTC_GetITStatus_0:
   \   000024 3F ..        CLR       S:?b0
   2160            }
   2161          
   2162            return (ITStatus)itstatus;
   \                     ??RTC_GetITStatus_1:
   \   000026 B6 ..        LD        A, S:?b0
   \   000028 87           RETF
   2163          }
   2164          
   2165          /**
   2166          * @brief  Clears the RTC's interrupt pending bits.
   2167          * @param  RTC_IT: specifies the RTC interrupt pending bit to clear.
   2168          *         This parameter can be any combination of the @ref RTC_IT_TypeDef
   2169          *         enumeration.
   2170          * @retval None
   2171          */

   \                                 In section .far_func.text, align 1
   2172          void RTC_ClearITPendingBit(RTC_IT_TypeDef RTC_IT)
   2173          {
   2174            /* Check the parameters */
   2175            assert_param(IS_RTC_CLEAR_IT((uint16_t)RTC_IT));
   2176          
   2177            /* Clear the interrupt pending bits in the RTC_ISR registers */
   2178            RTC->ISR2 = (uint8_t)~(uint8_t)((uint16_t)RTC_IT >> 4);
   \                     RTC_ClearITPendingBit:
   \   000000 54           SRLW      X
   \   000001 54           SRLW      X
   \   000002 54           SRLW      X
   \   000003 54           SRLW      X
   \   000004 9F           LD        A, XL
   \   000005 43           CPL       A
   \   000006 C7 514D      LD        L:0x514d, A
   2179          }
   \   000009 87           RETF
   2180          
   2181          /**
   2182            * @}
   2183            */
   2184          
   2185          
   2186          
   2187          
   2188          
   2189          
   2190          
   2191          
   2192          
   2193          /**
   2194           * @addtogroup RTC_Private_Functions
   2195           * @{
   2196           */
   2197          /**
   2198          * @brief  Converts a 2 digit decimal to BCD format
   2199          * @param  Value: Byte to be converted.
   2200          * @retval Converted byte
   2201          */

   \                                 In section .far_func.text, align 1
   2202          static uint8_t ByteToBcd2(uint8_t Value)
   2203          {
   \                     ByteToBcd2:
   \   000000 B7 ..        LD        S:?b1, A
   2204            uint8_t bcdhigh = 0;
   \   000002 3F ..        CLR       S:?b0
   \   000004 20 0C        JRA       L:??ByteToBcd2_0
   2205          
   2206            while (Value >= 10)
   2207            {
   2208              bcdhigh++;
   \                     ??ByteToBcd2_1:
   \   000006 B6 ..        LD        A, S:?b0
   \   000008 AB 01        ADD       A, #0x1
   \   00000A B7 ..        LD        S:?b0, A
   2209              Value -= 10;
   \   00000C B6 ..        LD        A, S:?b1
   \   00000E AB F6        ADD       A, #0xf6
   \   000010 B7 ..        LD        S:?b1, A
   2210            }
   \                     ??ByteToBcd2_0:
   \   000012 B6 ..        LD        A, S:?b1
   \   000014 A1 0A        CP        A, #0xa
   \   000016 24 EE        JRNC      L:??ByteToBcd2_1
   2211          
   2212            return  (uint8_t)((uint8_t)(bcdhigh << 4) | Value);
   \   000018 B6 ..        LD        A, S:?b0
   \   00001A 4E           SWAP      A
   \   00001B A4 F0        AND       A, #0xf0
   \   00001D BA ..        OR        A, S:?b1
   \   00001F 87           RETF
   2213          }
   2214          
   2215          /**
   2216          * @brief  Converts from 2 digit BCD to Binary format
   2217          * @param  Value: BCD value to be converted.
   2218          * @retval Converted word
   2219          */

   \                                 In section .far_func.text, align 1
   2220          static uint8_t Bcd2ToByte(uint8_t Value)
   2221          {
   \                     Bcd2ToByte:
   \   000000 B7 ..        LD        S:?b1, A
   2222            uint8_t tmp = 0;
   \   000002 3F ..        CLR       S:?b2
   2223          
   2224            tmp = (uint8_t)((uint8_t)((uint8_t)(Value & (uint8_t)0xF0) >> 4) * (uint8_t)10);
   \   000004 B6 ..        LD        A, S:?b1
   \   000006 4E           SWAP      A
   \   000007 A4 0F        AND       A, #0xf
   \   000009 35 0A ....   MOV       S:?b0, #0xa
   \   00000D 97           LD        XL, A
   \   00000E B6 ..        LD        A, S:?b0
   \   000010 42           MUL       X, A
   \   000011 9F           LD        A, XL
   \   000012 B7 ..        LD        S:?b2, A
   2225          
   2226            return (uint8_t)(tmp + (Value & (uint8_t)0x0F));
   \   000014 B6 ..        LD        A, S:?b1
   \   000016 A4 0F        AND       A, #0xf
   \   000018 BB ..        ADD       A, S:?b2
   \   00001A 87           RETF
   2227          }
   2228          
   2229          /**
   2230            * @}
   2231            */ 
   2232          
   2233          /**
   2234            * @}
   2235            */ 
   2236            
   2237          /**
   2238            * @}
   2239            */
   2240          
   2241          /**
   2242            * @}
   2243            */
   2244          
   2245          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Section sizes:

   Bytes  Function/Label
   -----  --------------
      27  Bcd2ToByte
      32  ByteToBcd2
      81  RTC_AlarmCmd
      53  RTC_AlarmStructInit
      66  RTC_AlarmSubSecondConfig
      26  RTC_BypassShadowCmd
      26  RTC_CalibOutputCmd
      26  RTC_CalibOutputConfig
      15  RTC_ClearFlag
      10  RTC_ClearITPendingBit
      27  RTC_DateStructInit
      29  RTC_DayLightSavingConfig
     235  RTC_DeInit
      34  RTC_EnterInitMode
       5  RTC_ExitInitMode
     177  RTC_GetAlarm
      90  RTC_GetDate
      57  RTC_GetFlagStatus
      41  RTC_GetITStatus
       6  RTC_GetStoreOperation
      51  RTC_GetSubSecond
      82  RTC_GetTime
      29  RTC_GetWakeUpCounter
      56  RTC_ITConfig
      77  RTC_Init
      33  RTC_OutputConfig
      26  RTC_RatioCmd
     297  RTC_SetAlarm
     189  RTC_SetDate
     162  RTC_SetTime
      27  RTC_SetWakeUpCounter
      68  RTC_SmoothCalibConfig
      19  RTC_StructInit
      68  RTC_SynchroShiftConfig
      32  RTC_TamperCmd
      31  RTC_TamperFilterConfig
      34  RTC_TamperLevelConfig
      31  RTC_TamperPinsPrechargeDuration
      31  RTC_TamperSamplingFreqConfig
      24  RTC_TimeStructInit
      52  RTC_WaitForSynchro
      35  RTC_WakeUpClockConfig
      61  RTC_WakeUpCmd
      17  RTC_WriteProtectionCmd

 
 2 595 bytes in section .far_func.text
 
 2 595 bytes of CODE memory

Errors: none
Warnings: none
