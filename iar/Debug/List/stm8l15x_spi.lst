###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.42.1.142 for STM8               01/Jul/2016  17:30:49 #
# Copyright 2010-2013 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  E:\hwpro-2016\20160627_L\stm8l15x_lib\src\stm8l15x_spi.c #
#    Command line =  E:\hwpro-2016\20160627_L\stm8l15x_lib\src\stm8l15x_spi.c #
#                     -e -Ol --no_cse --no_unroll --no_inline                 #
#                    --no_code_motion --no_tbaa --no_cross_call --debug       #
#                    --code_model medium --data_model medium -o               #
#                    E:\hwpro-2016\20160627_L\iar\Debug\Obj\ --dlib_config    #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.5\stm8\LIB\dlstm8mmn.h" -D STM8L15X_MD -lC             #
#                    E:\hwpro-2016\20160627_L\iar\Debug\List\ -I              #
#                    E:\hwpro-2016\20160627_L\iar\..\stm8l15x_lib\inc\ -I     #
#                    E:\hwpro-2016\20160627_L\iar\..\user\inc\ -I             #
#                    E:\hwpro-2016\20160627_L\iar\..\utils\xprintf\ -I        #
#                    E:\hwpro-2016\20160627_L\iar\..\drivers\ -I              #
#                    E:\hwpro-2016\20160627_L\iar\..\utils\ -I                #
#                    E:\hwpro-2016\20160627_L\iar\..\app\ --vregs 16          #
#    List file    =  E:\hwpro-2016\20160627_L\iar\Debug\List\stm8l15x_spi.lst #
#    Object file  =  E:\hwpro-2016\20160627_L\iar\Debug\Obj\stm8l15x_spi.o    #
#                                                                             #
#                                                                             #
###############################################################################

E:\hwpro-2016\20160627_L\stm8l15x_lib\src\stm8l15x_spi.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm8l15x_spi.c
      4            * @author  MCD Application Team
      5            * @version V1.6.1
      6            * @date    30-September-2014
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Serial peripheral interface (SPI):           
      9            *           - Initialization and Configuration
     10            *           - Data transfers functions
     11            *           - Hardware CRC Calculation
     12            *           - DMA transfers management
     13            *           - Interrupts and flags management 
     14            *           
     15            *  @verbatim
     16            *          
     17            *          ===================================================================
     18            *                                 How to use this driver
     19            *          ===================================================================
     20            *          1. Enable peripheral clock using CLK_PeripheralClockConfig(CLK_Peripheral_SPIx,
     21            *             ENABLE) function (Refer to the product datasheet for the available SPI
     22            *           	peripherals)
     23            *
     24            *          2.  Enable the external Pull-up on the used SPI Pins using the
     25            *              GPIO_ExternalPullUpConfig() function or an eternal pull-up equivalent resistor
     26          	*              (RPU = 45 KOhm typical value). 
     27            *
     28            *        
     29            *          3. Program the Polarity, Phase, First Data, Baud Rate Prescaler, Slave 
     30            *             Management, Peripheral Mode and CRC Polynomial values using the SPI_Init()
     31            *             function.
     32            *
     33            *          4. Enable the corresponding interrupt using the function SPI_ITConfig() if you
     34            *           	need to use interrupt mode. 
     35            *
     36            *          5. When using the DMA mode 
     37            *                   - Configure the DMA using DMA_Init() function
     38            *                   - Active the needed channel Request using SPI_DMACmd() function
     39            * 
     40            *          6. Enable the SPI using the SPI_Cmd() function.
     41            * 
     42            *          7. Enable the DMA using the DMA_Cmd() function when using DMA mode. 
     43            *
     44            *          8. Optionally you can enable/configure the following parameters without
     45            *             re-initialization (i.e there is no need to call again SPI_Init() function):
     46            *              - When bidirectional mode (SPI_Direction_1Line_Rx or SPI_Direction_1Line_Tx)
     47            *                is programmed as Data direction parameter using the SPI_Init() function
     48            *                it can be possible to switch between SPI_Direction_Tx or SPI_Direction_Rx
     49            *                using the SPI_BiDirectionalLineConfig() function.
     50            *              - When SPI_NSS_Soft is selected as Slave Select Management parameter 
     51            *                using the SPI_Init() function it can be possible to manage the 
     52            *                NSS internal signal using the SPI_NSSInternalSoftwareConfig() function.
     53            *          
     54            *          9. To use the CRC Hardware calculation feature refer to the Peripheral 
     55            *              CRC hardware Calculation subsection.
     56            *
     57            *  @endverbatim  
     58            *                                  
     59            ******************************************************************************
     60            * @attention
     61            *
     62            * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
     63            *
     64            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     65            * You may not use this file except in compliance with the License.
     66            * You may obtain a copy of the License at:
     67            *
     68            *        http://www.st.com/software_license_agreement_liberty_v2
     69            *
     70            * Unless required by applicable law or agreed to in writing, software 
     71            * distributed under the License is distributed on an "AS IS" BASIS, 
     72            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     73            * See the License for the specific language governing permissions and
     74            * limitations under the License.
     75            *
     76            ******************************************************************************
     77            */ 
     78          	
     79          /* Includes ------------------------------------------------------------------*/
     80          #include "stm8l15x_spi.h"
     81          
     82          /** @addtogroup STM8L15x_StdPeriph_Driver
     83            * @{
     84            */
     85          	
     86          /** @defgroup SPI 
     87            * @brief SPI driver modules
     88            * @{
     89            */ 
     90          	
     91          /* Private typedef -----------------------------------------------------------*/
     92          /* Private define ------------------------------------------------------------*/
     93          /* Private macro -------------------------------------------------------------*/
     94          /* Private variables ---------------------------------------------------------*/
     95          /* Private function prototypes -----------------------------------------------*/
     96          /* Private functions ---------------------------------------------------------*/
     97          
     98          /** @defgroup SPI_Private_Functions
     99            * @{
    100            */
    101          
    102          /** @defgroup SPI_Group1 Initialization and Configuration functions
    103           *  @brief   Initialization and Configuration functions 
    104           *
    105          @verbatim   
    106           ===============================================================================
    107                            Initialization and Configuration functions
    108           ===============================================================================  
    109          
    110            This section provides a set of functions allowing to initialize the SPI Direction,
    111            SPI Mode, SPI Data Size, SPI Polarity, SPI Phase, SPI NSS Management, SPI Baud
    112            Rate Prescaler, SPI First Bit and SPI CRC Polynomial.
    113            
    114            The SPI_Init() function follows the SPI configuration procedures for Master mode
    115            and Slave mode (details for these procedures are available in reference manual
    116            (RM0031)).
    117            
    118          @endverbatim
    119            * @{
    120            */
    121          
    122          /**
    123            * @brief  Deinitializes the SPI peripheral registers to their default reset values.
    124            * @param  SPIx: where x can be 1 to select the specified SPI peripheral.
    125            * @param  None
    126            * @retval None
    127            */

   \                                 In section .far_func.text, align 1
    128          void SPI_DeInit(SPI_TypeDef* SPIx)
    129          {
    130            SPIx->CR1    = SPI_CR1_RESET_VALUE;
   \                     SPI_DeInit:
   \   000000 4F           CLR       A
   \   000001 F7           LD        (X), A
    131            SPIx->CR2    = SPI_CR2_RESET_VALUE;
   \   000002 9093         LDW       Y, X
   \   000004 905C         INCW      Y
   \   000006 4F           CLR       A
   \   000007 90F7         LD        (Y), A
    132            SPIx->CR3    = SPI_CR3_RESET_VALUE;
   \   000009 9093         LDW       Y, X
   \   00000B 72A9 0002    ADDW      Y, #0x2
   \   00000F 4F           CLR       A
   \   000010 90F7         LD        (Y), A
    133            SPIx->SR     = SPI_SR_RESET_VALUE;
   \   000012 9093         LDW       Y, X
   \   000014 72A9 0003    ADDW      Y, #0x3
   \   000018 A6 02        LD        A, #0x2
   \   00001A 90F7         LD        (Y), A
    134            SPIx->CRCPR  = SPI_CRCPR_RESET_VALUE;
   \   00001C 1C 0005      ADDW      X, #0x5
   \   00001F A6 07        LD        A, #0x7
   \   000021 F7           LD        (X), A
    135          }
   \   000022 87           RETF
    136          
    137          /**
    138            * @brief  Initializes the SPI according to the specified parameters.
    139            * @param  SPIx: where x can be 1 to select the specified SPI peripheral.
    140            * @param  SPI_FirstBit: This parameter can be any of the
    141            *          This parameter can be one of the following values:
    142            *            @arg SPI_FirstBit_MSB: MSB bit will be transmitted first
    143            *            @arg SPI_FirstBit_LSB: LSB bit will be transmitted first  
    144            * @param  SPI_BaudRatePrescaler: This parameter can be any of the
    145            *          This parameter can be one of the following values:
    146            *            @arg SPI_BaudRatePrescaler_2: SPI frequency = frequency(CPU)/2
    147            *            @arg SPI_BaudRatePrescaler_4: SPI frequency = frequency(CPU)/4
    148            *            @arg SPI_BaudRatePrescaler_8: SPI frequency = frequency(CPU)/8
    149            *            @arg SPI_BaudRatePrescaler_16: SPI frequency = frequency(CPU)/16
    150            *            @arg SPI_BaudRatePrescaler_32: SPI frequency = frequency(CPU)/32
    151            *            @arg SPI_BaudRatePrescaler_64: SPI frequency = frequency(CPU)/64
    152            *            @arg SPI_BaudRatePrescaler_128: SPI frequency = frequency(CPU)/128
    153            *            @arg SPI_BaudRatePrescaler_256: SPI frequency = frequency(CPU)/256            
    154            * @param  SPI_Mode: Mode
    155            *          This parameter can be one of the following values:
    156            *            @arg SPI_Mode_Master: SPI Master configuration
    157            *            @arg SPI_Mode_Slave: SPI Slave configuration
    158            * @param  SPI_CPOL: Clock Polarity
    159            *          This parameter can be one of the following values:
    160            *            @arg SPI_CPOL_Low: Clock to 0 when idle
    161            *            @arg SPI_CPOL_High: Clock to 1 when idle
    162            * @param  SPI_CPHA: Clock Phase
    163            *          This parameter can be one of the following values:
    164            *            @arg SPI_CPHA_1Edge: The first clock transition is the first data capture edge
    165            *            @arg SPI_CPHA_2Edge: The second clock transition is the first data capture edge
    166            * @param  SPI_Data_Direction: Data direction
    167            *          This parameter can be one of the following values:
    168            *            @arg SPI_Direction_Rx: Select Rx receive direction in bi-directional mode
    169            *            @arg SPI_Direction_Tx: Select Tx transmission direction in bi-directional mode
    170            * @param  SPI_Slave_Management: Slave management
    171            *          This parameter can be one of the following values:
    172            *            @arg SPI_NSS_Soft: Software slave management disabled
    173            *            @arg SPI_NSS_Hard: Software slave management enabled
    174            * @param  CRCPolynomial: Configures the CRC polynomial.
    175            * @retval None
    176            */

   \                                 In section .far_func.text, align 1
    177          void SPI_Init(SPI_TypeDef* SPIx, SPI_FirstBit_TypeDef SPI_FirstBit,
    178                        SPI_BaudRatePrescaler_TypeDef SPI_BaudRatePrescaler,
    179                        SPI_Mode_TypeDef SPI_Mode, SPI_CPOL_TypeDef SPI_CPOL,
    180                        SPI_CPHA_TypeDef SPI_CPHA, SPI_DirectionMode_TypeDef SPI_Data_Direction,
    181                        SPI_NSS_TypeDef SPI_Slave_Management, uint8_t CRCPolynomial)
    182          {
   \                     SPI_Init:
   \   000000 B7 ..        LD        S:?b7, A
   \   000002 B6 ..        LD        A, S:?b3
    183            /* Check structure elements */
    184            assert_param(IS_SPI_FIRSTBIT(SPI_FirstBit));
    185            assert_param(IS_SPI_BAUDRATE_PRESCALER(SPI_BaudRatePrescaler));
    186            assert_param(IS_SPI_MODE(SPI_Mode));
    187            assert_param(IS_SPI_POLARITY(SPI_CPOL));
    188            assert_param(IS_SPI_PHASE(SPI_CPHA));
    189            assert_param(IS_SPI_DATA_DIRECTION(SPI_Data_Direction));
    190            assert_param(IS_SPI_SLAVEMANAGEMENT(SPI_Slave_Management));
    191            assert_param(IS_SPI_CRC_POLYNOMIAL(CRCPolynomial));
    192          
    193            /* Frame Format, BaudRate, Clock Polarity and Phase configuration */
    194            SPIx->CR1 = (uint8_t)((uint8_t)((uint8_t)SPI_FirstBit |
    195                                            (uint8_t)SPI_BaudRatePrescaler) |
    196                                  (uint8_t)((uint8_t)SPI_CPOL |
    197                                            SPI_CPHA));
   \   000004 BA ..        OR        A, S:?b2
   \   000006 88           PUSH      A
   \   000007 B6 ..        LD        A, S:?b0
   \   000009 BA ..        OR        A, S:?b7
   \   00000B B7 ..        LD        S:?b0, A
   \   00000D 84           POP       A
   \   00000E BA ..        OR        A, S:?b0
   \   000010 F7           LD        (X), A
    198          
    199            /* Data direction configuration: BDM, BDOE and RXONLY bits */
    200            SPIx->CR2 = (uint8_t)((uint8_t)(SPI_Data_Direction) | (uint8_t)(SPI_Slave_Management));
   \   000011 B6 ..        LD        A, S:?b5
   \   000013 BA ..        OR        A, S:?b4
   \   000015 9093         LDW       Y, X
   \   000017 905C         INCW      Y
   \   000019 90F7         LD        (Y), A
    201          
    202            if (SPI_Mode == SPI_Mode_Master)
   \   00001B B6 ..        LD        A, S:?b1
   \   00001D A1 04        CP        A, #0x4
   \   00001F 26 10        JRNE      L:??SPI_Init_0
    203            {
    204              SPIx->CR2 |= (uint8_t)SPI_CR2_SSI;
   \   000021 9093         LDW       Y, X
   \   000023 905C         INCW      Y
   \   000025 90F6         LD        A, (Y)
   \   000027 AA 01        OR        A, #0x1
   \   000029 9093         LDW       Y, X
   \   00002B 905C         INCW      Y
   \   00002D 90F7         LD        (Y), A
   \   00002F 20 0E        JRA       L:??SPI_Init_1
    205            }
    206            else
    207            {
    208              SPIx->CR2 &= (uint8_t)~(SPI_CR2_SSI);
   \                     ??SPI_Init_0:
   \   000031 9093         LDW       Y, X
   \   000033 905C         INCW      Y
   \   000035 90F6         LD        A, (Y)
   \   000037 A4 FE        AND       A, #0xfe
   \   000039 9093         LDW       Y, X
   \   00003B 905C         INCW      Y
   \   00003D 90F7         LD        (Y), A
    209            }
    210          
    211            /* Master/Slave mode configuration */
    212            SPIx->CR1 |= (uint8_t)(SPI_Mode);
   \                     ??SPI_Init_1:
   \   00003F B6 ..        LD        A, S:?b1
   \   000041 FA           OR        A, (X)
   \   000042 F7           LD        (X), A
    213          
    214            /* CRC configuration */
    215            SPIx->CRCPR = (uint8_t)CRCPolynomial;
   \   000043 1C 0005      ADDW      X, #0x5
   \   000046 B6 ..        LD        A, S:?b6
   \   000048 F7           LD        (X), A
    216          }
   \   000049 87           RETF
    217          
    218          /**
    219            * @brief  Enables or disables the SPI peripheral.
    220            * @param  SPIx: where x can be 1 to select the specified SPI peripheral.
    221            * @param  NewState New state of the SPI peripheral.
    222            *         This parameter can be: ENABLE or DISABLE
    223            * @retval None
    224            */

   \                                 In section .far_func.text, align 1
    225          void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    226          {
    227            /* Check function parameters */
    228            assert_param(IS_FUNCTIONAL_STATE(NewState));
    229          
    230            if (NewState != DISABLE)
   \                     SPI_Cmd:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??SPI_Cmd_0
    231            {
    232              SPIx->CR1 |= SPI_CR1_SPE; /* Enable the SPI peripheral*/
   \   000003 F6           LD        A, (X)
   \   000004 AA 40        OR        A, #0x40
   \   000006 F7           LD        (X), A
   \   000007 87           RETF
    233            }
    234            else
    235            {
    236              SPIx->CR1 &= (uint8_t)(~SPI_CR1_SPE); /* Disable the SPI peripheral*/
   \                     ??SPI_Cmd_0:
   \   000008 F6           LD        A, (X)
   \   000009 A4 BF        AND       A, #0xbf
   \   00000B F7           LD        (X), A
    237            }
    238          }
   \   00000C 87           RETF
    239          
    240          /**
    241            * @brief  Configures internally by software the NSS pin.
    242            * @param  SPIx: where x can be 1 to select the specified SPI peripheral.
    243            * @param  NewState Indicates the new state of the SPI Software slave management.
    244              *         This parameter can be: ENABLE or DISABLE.
    245            * @retval None
    246            */

   \                                 In section .far_func.text, align 1
    247          void SPI_NSSInternalSoftwareCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    248          {
    249            /* Check function parameters */
    250            assert_param(IS_FUNCTIONAL_STATE(NewState));
    251          
    252            if (NewState != DISABLE)
   \                     SPI_NSSInternalSoftwareCmd:
   \   000000 4D           TNZ       A
   \   000001 27 0B        JREQ      L:??SPI_NSSInternalSoftwareCmd_0
    253            {
    254              SPIx->CR2 |= SPI_CR2_SSI; /* Set NSS pin internally by software*/
   \   000003 9093         LDW       Y, X
   \   000005 905C         INCW      Y
   \   000007 90F6         LD        A, (Y)
   \   000009 AA 01        OR        A, #0x1
   \   00000B 5C           INCW      X
   \   00000C F7           LD        (X), A
   \   00000D 87           RETF
    255            }
    256            else
    257            {
    258              SPIx->CR2 &= (uint8_t)(~SPI_CR2_SSI); /* Reset NSS pin internally by software*/
   \                     ??SPI_NSSInternalSoftwareCmd_0:
   \   00000E 9093         LDW       Y, X
   \   000010 905C         INCW      Y
   \   000012 90F6         LD        A, (Y)
   \   000014 A4 FE        AND       A, #0xfe
   \   000016 5C           INCW      X
   \   000017 F7           LD        (X), A
    259            }
    260          }
   \   000018 87           RETF
    261          
    262          /**
    263            * @brief  Selects the data transfer direction in Bi-directional mode.
    264            * @param  SPIx: where x can be 1 to select the specified SPI peripheral.
    265            * @param  SPI_Direction Specifies the data transfer direction in Bi-directional mode.
    266            *          This parameter can be one of the following values:
    267            *            @arg SPI_Direction_Rx: Select Rx receive direction in bi-directional mode
    268            *            @arg SPI_Direction_Tx: Select Tx transmission direction in bi-directional mode
    269            * @retval None
    270            */

   \                                 In section .far_func.text, align 1
    271          void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, SPI_Direction_TypeDef SPI_Direction)
    272          {
    273            /* Check function parameters */
    274            assert_param(IS_SPI_DIRECTION(SPI_Direction));
    275          
    276            if (SPI_Direction != SPI_Direction_Rx)
   \                     SPI_BiDirectionalLineConfig:
   \   000000 4D           TNZ       A
   \   000001 27 0B        JREQ      L:??SPI_BiDirectionalLineConfig_0
    277            {
    278              SPIx->CR2 |= SPI_CR2_BDOE; /* Set the Tx only mode*/
   \   000003 9093         LDW       Y, X
   \   000005 905C         INCW      Y
   \   000007 90F6         LD        A, (Y)
   \   000009 AA 40        OR        A, #0x40
   \   00000B 5C           INCW      X
   \   00000C F7           LD        (X), A
   \   00000D 87           RETF
    279            }
    280            else
    281            {
    282              SPIx->CR2 &= (uint8_t)(~SPI_CR2_BDOE); /* Set the Rx only mode*/
   \                     ??SPI_BiDirectionalLineConfig_0:
   \   00000E 9093         LDW       Y, X
   \   000010 905C         INCW      Y
   \   000012 90F6         LD        A, (Y)
   \   000014 A4 BF        AND       A, #0xbf
   \   000016 5C           INCW      X
   \   000017 F7           LD        (X), A
    283            }
    284          }
   \   000018 87           RETF
    285          
    286          /**
    287            * @}
    288            */
    289          
    290          /** @defgroup SPI_Group2 Data transfers functions
    291           *  @brief   Data transfers functions
    292           *
    293          @verbatim   
    294           ===============================================================================
    295                                   Data transfers functions
    296           ===============================================================================  
    297          
    298            This section provides a set of functions allowing to manage the SPI data transfers
    299            
    300            In reception, data are received and then stored into an internal Rx buffer while 
    301            In transmission, data are first stored into an internal Tx buffer before being 
    302            transmitted.
    303          
    304            The read access of the SPI_DR register can be done using the SPI_ReceiveData()
    305            function and returns the Rx buffered value. Whereas a write access to the SPI_DR 
    306            can be done using SPI_SendData() function and stores the written data into 
    307            Tx buffer.
    308          
    309          @endverbatim
    310            * @{
    311            */
    312          	
    313          /**
    314            * @brief  Transmits a Data through the SPI peripheral.
    315            * @param  SPIx: where x can be 1 to select the specified SPI peripheral.
    316            * @param  Data: Byte to be transmitted.
    317            * @retval None
    318            */

   \                                 In section .far_func.text, align 1
    319          void SPI_SendData(SPI_TypeDef* SPIx, uint8_t Data)
    320          {
    321            SPIx->DR = Data; /* Write in the DR register the data to be sent*/
   \                     SPI_SendData:
   \   000000 1C 0004      ADDW      X, #0x4
   \   000003 F7           LD        (X), A
    322          }
   \   000004 87           RETF
    323          
    324          /**
    325            * @brief  Returns the most recent received data by the SPI peripheral.
    326            * @param  SPIx: where x can be 1 to select the specified SPI peripheral.
    327            * @retval The value of the received data.
    328            */

   \                                 In section .far_func.text, align 1
    329          uint8_t SPI_ReceiveData(SPI_TypeDef* SPIx)
    330          {
    331            return ((uint8_t)SPIx->DR); /* Return the data in the DR register*/
   \                     SPI_ReceiveData:
   \   000000 1C 0004      ADDW      X, #0x4
   \   000003 F6           LD        A, (X)
   \   000004 87           RETF
    332          }
    333          
    334          /**
    335            * @}
    336            */
    337          
    338          /** @defgroup SPI_Group3 Hardware CRC Calculation functions
    339           *  @brief   Hardware CRC Calculation functions
    340           *
    341          @verbatim   
    342           ===============================================================================
    343                                   Hardware CRC Calculation functions
    344           ===============================================================================  
    345          
    346            This section provides a set of functions allowing to manage the SPI CRC hardware 
    347            calculation
    348          
    349            SPI communication using CRC is possible through the following procedure:
    350               1. Program the Data direction, Polarity, Phase, First Data, Baud Rate Prescaler, 
    351                  Slave Management, Peripheral Mode and CRC Polynomial values using the SPI_Init()
    352                  function.
    353               2. Enable the CRC calculation using the SPI_CalculateCRC() function.
    354               3. Enable the SPI using the SPI_Cmd() function
    355               4. Before writing the last data to the TX buffer, set the CRCNext bit using the 
    356                SPI_TransmitCRC() function to indicate that after transmission of the last 
    357                data, the CRC should be transmitted.
    358               5. After transmitting the last data, the SPI transmits the CRC. The SPI_CR2_CRCNEXT
    359                  bit is reset. The CRC is also received and compared against the SPI_RXCRCR 
    360                  value. 
    361                  If the value does not match, the SPI_FLAG_CRCERR flag is set and an interrupt
    362                  can be generated when the SPI_IT_ERR interrupt is enabled.
    363          
    364          Note: 
    365          -----
    366              - It is advised to don't read the calculate CRC values during the communication.
    367          
    368              - When the SPI is in slave mode, be careful to enable CRC calculation only 
    369                when the clock is stable, that is, when the clock is in the steady state. 
    370                If not, a wrong CRC calculation may be done. In fact, the CRC is sensitive 
    371                to the SCK slave input clock as soon as CRCEN is set, and this, whatever 
    372                the value of the SPE bit.
    373          
    374              - With high bitrate frequencies, be careful when transmitting the CRC.
    375                As the number of used CPU cycles has to be as low as possible in the CRC 
    376                transfer phase, it is forbidden to call software functions in the CRC 
    377                transmission sequence to avoid errors in the last data and CRC reception. 
    378                In fact, CRCNEXT bit has to be written before the end of the transmission/reception 
    379                of the last data.
    380          
    381              - For high bit rate frequencies, it is advised to use the DMA mode to avoid the
    382                degradation of the SPI speed performance due to CPU accesses impacting the 
    383                SPI bandwidth.
    384          
    385              - When the STM8L15x are configured as slaves and the NSS hardware mode is 
    386                used, the NSS pin needs to be kept low between the data phase and the CRC 
    387                phase.
    388          
    389              - When the SPI is configured in slave mode with the CRC feature enabled, CRC
    390                calculation takes place even if a high level is applied on the NSS pin. 
    391                This may happen for example in case of a multislave environment where the 
    392                communication master addresses slaves alternately.
    393          
    394              - Between a slave de-selection (high level on NSS) and a new slave selection 
    395                (low level on NSS), the CRC value should be cleared on both master and slave
    396                sides in order to resynchronize the master and slave for their respective 
    397                CRC calculation.
    398          
    399              To clear the CRC, follow the procedure below:
    400                1. Disable SPI using the SPI_Cmd() function
    401                2. Disable the CRC calculation using the SPI_CalculateCRC() function.
    402                3. Enable the CRC calculation using the SPI_CalculateCRC() function.
    403                4. Enable SPI using the SPI_Cmd() function.
    404          
    405          @endverbatim
    406            * @{
    407            */
    408          	
    409          /**
    410            * @brief  Enables the transmit of the CRC value.
    411            * @param  SPIx: where x can be 1 to select the specified SPI peripheral.
    412            * @retval None
    413            */

   \                                 In section .far_func.text, align 1
    414          void SPI_TransmitCRC(SPI_TypeDef* SPIx)
    415          {
    416            SPIx->CR2 |= SPI_CR2_CRCNEXT; /* Enable the CRC transmission*/
   \                     SPI_TransmitCRC:
   \   000000 9093         LDW       Y, X
   \   000002 905C         INCW      Y
   \   000004 90F6         LD        A, (Y)
   \   000006 AA 10        OR        A, #0x10
   \   000008 5C           INCW      X
   \   000009 F7           LD        (X), A
    417          }
   \   00000A 87           RETF
    418          
    419          /**
    420            * @brief  Enables or disables the CRC value calculation of the transferred bytes.
    421            * @param  SPIx: where x can be 1 to select the specified SPI peripheral.
    422            * @param  NewState Indicates the new state of the SPI CRC value calculation.
    423              *         This parameter can be: ENABLE or DISABLE.
    424            * @retval None
    425            */

   \                                 In section .far_func.text, align 1
    426          void SPI_CalculateCRCCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    427          {
   \                     SPI_CalculateCRCCmd:
   \   000000 8D ......    CALLF     L:?push_w4
   \   000004 3B ....      PUSH      S:?b10
   \   000007 BF ..        LDW       S:?w4, X
   \   000009 B7 ..        LD        S:?b10, A
    428            /* Check function parameters */
    429            assert_param(IS_FUNCTIONAL_STATE(NewState));
    430          
    431            /* SPI must be disabled for correct operation od Hardware CRC calculation */
    432            SPI_Cmd(SPI1, DISABLE);
   \   00000B 4F           CLR       A
   \   00000C AE 5200      LDW       X, #0x5200
   \   00000F 8D ......    CALLF     SPI_Cmd
    433          
    434            if (NewState != DISABLE)
   \   000013 3D ..        TNZ       S:?b10
   \   000015 27 0C        JREQ      L:??SPI_CalculateCRCCmd_0
    435            {
    436              SPIx->CR2 |= SPI_CR2_CRCEN; /* Enable the CRC calculation*/
   \   000017 BE ..        LDW       X, S:?w4
   \   000019 5C           INCW      X
   \   00001A F6           LD        A, (X)
   \   00001B AA 20        OR        A, #0x20
   \   00001D BE ..        LDW       X, S:?w4
   \   00001F 5C           INCW      X
   \   000020 F7           LD        (X), A
   \   000021 20 0A        JRA       L:??SPI_CalculateCRCCmd_1
    437            }
    438            else
    439            {
    440              SPIx->CR2 &= (uint8_t)(~SPI_CR2_CRCEN); /* Disable the CRC calculation*/
   \                     ??SPI_CalculateCRCCmd_0:
   \   000023 BE ..        LDW       X, S:?w4
   \   000025 5C           INCW      X
   \   000026 F6           LD        A, (X)
   \   000027 A4 DF        AND       A, #0xdf
   \   000029 BE ..        LDW       X, S:?w4
   \   00002B 5C           INCW      X
   \   00002C F7           LD        (X), A
    441            }
    442          }
   \                     ??SPI_CalculateCRCCmd_1:
   \   00002D 32 ....      POP       S:?b10
   \   000030 AC ......    JPF       L:?epilogue_w4
    443          
    444          /**
    445            * @brief  Returns the transmit or the receive CRC register value.
    446            * @param  SPIx: where x can be 1 to select the specified SPI peripheral.
    447            * @param  SPI_CRC: Specifies the CRC register to be read.
    448            *          This parameter can be one of the following values:
    449            *            @arg SPI_CRC_RX: Select Tx CRC register
    450            *            @arg SPI_CRC_TX: Select Rx CRC register
    451            * @retval The selected CRC register value.
    452            */

   \                                 In section .far_func.text, align 1
    453          uint8_t SPI_GetCRC(SPI_TypeDef* SPIx, SPI_CRC_TypeDef SPI_CRC)
    454          {
    455            uint8_t crcreg = 0;
   \                     SPI_GetCRC:
   \   000000 3F ..        CLR       S:?b0
    456          
    457            /* Check function parameters */
    458            assert_param(IS_SPI_CRC(SPI_CRC));
    459          
    460            if (SPI_CRC != SPI_CRC_RX)
   \   000002 4D           TNZ       A
   \   000003 27 08        JREQ      L:??SPI_GetCRC_0
    461            {
    462              crcreg = SPIx->TXCRCR;  /* Get the Tx CRC register*/
   \   000005 1C 0007      ADDW      X, #0x7
   \   000008 F6           LD        A, (X)
   \   000009 B7 ..        LD        S:?b0, A
   \   00000B 20 06        JRA       L:??SPI_GetCRC_1
    463            }
    464            else
    465            {
    466              crcreg = SPIx->RXCRCR; /* Get the Rx CRC register*/
   \                     ??SPI_GetCRC_0:
   \   00000D 1C 0006      ADDW      X, #0x6
   \   000010 F6           LD        A, (X)
   \   000011 B7 ..        LD        S:?b0, A
    467            }
    468          
    469            /* Return the selected CRC register status*/
    470            return crcreg;
   \                     ??SPI_GetCRC_1:
   \   000013 B6 ..        LD        A, S:?b0
   \   000015 87           RETF
    471          }
    472          
    473          /**
    474            * @brief  Reset the Rx CRCR and Tx CRCR registers.
    475            * @param  SPIx: where x can be 1 to select the specified SPI peripheral.
    476            * @retval None
    477            */

   \                                 In section .far_func.text, align 1
    478          void SPI_ResetCRC(SPI_TypeDef* SPIx)
    479          {
   \                     SPI_ResetCRC:
   \   000000 8D ......    CALLF     L:?push_w4
   \   000004 BF ..        LDW       S:?w4, X
    480            /* Rx CRCR & Tx CRCR registers are reset when CRCEN (hardware calculation)
    481               bit in SPI_CR2 is written to 1 (enable) */
    482            SPI_CalculateCRCCmd(SPIx, ENABLE);
   \   000006 A6 01        LD        A, #0x1
   \   000008 BE ..        LDW       X, S:?w4
   \   00000A 8D ......    CALLF     SPI_CalculateCRCCmd
    483          
    484            /* Previous function disable the SPI */
    485            SPI_Cmd(SPIx, ENABLE);
   \   00000E A6 01        LD        A, #0x1
   \   000010 BE ..        LDW       X, S:?w4
   \   000012 8D ......    CALLF     SPI_Cmd
    486          }
   \   000016 AC ......    JPF       L:?epilogue_w4
    487          
    488          /**
    489            * @brief  Returns the CRC Polynomial register value.
    490            * @param  SPIx: where x can be 1 to select the specified SPI peripheral.
    491            * @retval uint8_t The CRC Polynomial register value.
    492            */

   \                                 In section .far_func.text, align 1
    493          uint8_t SPI_GetCRCPolynomial(SPI_TypeDef* SPIx)
    494          {
    495            return SPIx->CRCPR; /* Return the CRC polynomial register */
   \                     SPI_GetCRCPolynomial:
   \   000000 1C 0005      ADDW      X, #0x5
   \   000003 F6           LD        A, (X)
   \   000004 87           RETF
    496          }
    497          
    498          /**
    499            * @}
    500            */
    501          
    502          /** @defgroup SPI_Group4 DMA transfers management functions
    503           *  @brief   DMA transfers management functions
    504            *
    505          @verbatim   
    506           ===============================================================================
    507                                   DMA transfers management functions
    508           ===============================================================================  
    509          
    510          @endverbatim
    511            * @{
    512            */
    513          	
    514          /**
    515            * @brief  Enables or disables the SPI DMA interface.
    516            * @param  SPIx: where x can be 1 to select the specified SPI peripheral.
    517            * @param  SPI_DMAReq Specifies the SPI DMA transfer request to be enabled or disabled.
    518            *          This parameter can be one of the following values:
    519            *            @arg SPI_DMAReq_RX: SPI DMA Rx transfer requests
    520            *            @arg SPI_DMAReq_TX: SPI DMA Tx transfer requests
    521            * @param  NewState Indicates the new state of the SPI DMA request.
    522            *         This parameter can be: ENABLE or DISABLE.
    523            * @retval None
    524            */

   \                                 In section .far_func.text, align 1
    525          void SPI_DMACmd(SPI_TypeDef* SPIx, SPI_DMAReq_TypeDef SPI_DMAReq, FunctionalState NewState)
    526          {
    527            /* Check the parameters */
    528            assert_param(IS_FUNCTIONAL_STATE(NewState));
    529            assert_param(IS_SPI_DMAREQ(SPI_DMAReq));
    530          
    531            if (NewState != DISABLE)
   \                     SPI_DMACmd:
   \   000000 3D ..        TNZ       S:?b0
   \   000002 27 0D        JREQ      L:??SPI_DMACmd_0
    532            {
    533              /* Enable the selected SPI DMA requests */
    534              SPIx->CR3 |= (uint8_t) SPI_DMAReq;
   \   000004 9093         LDW       Y, X
   \   000006 72A9 0002    ADDW      Y, #0x2
   \   00000A 90FA         OR        A, (Y)
   \   00000C 1C 0002      ADDW      X, #0x2
   \   00000F F7           LD        (X), A
   \   000010 87           RETF
    535            }
    536            else
    537            {
    538              /* Disable the selected SPI DMA requests */
    539              SPIx->CR3 &= (uint8_t)~SPI_DMAReq;
   \                     ??SPI_DMACmd_0:
   \   000011 9093         LDW       Y, X
   \   000013 72A9 0002    ADDW      Y, #0x2
   \   000017 43           CPL       A
   \   000018 90F4         AND       A, (Y)
   \   00001A 1C 0002      ADDW      X, #0x2
   \   00001D F7           LD        (X), A
    540            }
    541          }
   \   00001E 87           RETF
    542          
    543          /**
    544            * @}
    545            */
    546          
    547          /** @defgroup SPI_Group5 Interrupts and flags management functions
    548           *  @brief   Interrupts and flags management functions
    549            *
    550          @verbatim   
    551           ===============================================================================
    552                                   Interrupts and flags management functions
    553           ===============================================================================  
    554          
    555            This section provides a set of functions allowing to configure the SPI Interrupts 
    556            sources and check or clear the flags or pending bits status.
    557            The user should identify which mode will be used in his application to manage 
    558            the communication: Polling mode, Interrupt mode or DMA mode. 
    559              
    560            Polling Mode
    561            =============
    562            In Polling Mode, the SPI communication can be managed by 6 flags:
    563               1. SPI_FLAG_TXE: to indicate the status of the transmit buffer register
    564               2. SPI_FLAG_RXNE: to indicate the status of the receive buffer register
    565               3. SPI_FLAG_WKUP: to indicate the state of the Wakeup event.
    566               4. SPI_FLAG_CRCERR: to indicate if a CRC Calculation error occurs              
    567               5. SPI_FLAG_MODF: to indicate if a Mode Fault error occurs
    568               6. SPI_FLAG_OVR: to indicate if an Overrun error occurs
    569          
    570            In this Mode it is advised to use the following functions:
    571               - FlagStatus SPI_GetFlagStatus(SPI_TypeDef* SPIx, SPI_FLAG_TypeDef SPI_FLAG);
    572               - void SPI_ClearFlag(SPI_TypeDef* SPIx, SPI_FLAG_TypeDef SPI_FLAG);
    573          
    574            Interrupt Mode
    575            ===============
    576            In Interrupt Mode, the SPI communication can be managed by 4 interrupt sources
    577            and 6 pending bits: 
    578            Pending Bits:
    579            ------------- 
    580               1. SPI_IT_TXE: to indicate the status of the transmit buffer register
    581               2. SPI_IT_RXNE: to indicate the status of the receive buffer register
    582               3. SPI_IT_CRCERR: to indicate if a CRC Calculation error occurs              
    583               4. SPI_IT_MODF: to indicate if a Mode Fault error occurs
    584               5. SPI_IT_OVR: to indicate if an Overrun error occurs
    585               6. SPI_IT_WKUP: to indicate if an Wake_up event occurs
    586            Interrupt Source:
    587            -----------------
    588               1. SPI_IT_TXE: specifies the interrupt source for the Tx buffer empty 
    589                                  interrupt.  
    590               2. SPI_IT_RXNE: specifies the interrupt source for the Rx buffer not 
    591                                    empty interrupt.
    592               3. SPI_IT_ERR: specifies the interrupt source for the errors interrupt.
    593          		 4. SPI_IT_WKUP: specifies the interrupt source for the Wake-up interrupt.
    594          
    595            In this Mode it is advised to use the following functions:
    596               - void SPI_ITConfig(SPI_TypeDef* SPIx, SPI_IT_TypeDef SPI_IT, FunctionalState NewState);
    597               - ITStatus SPI_GetITStatus(SPI_TypeDef* SPIx, SPI_IT_TypeDef SPI_IT);
    598               - void SPI_ClearITPendingBit(SPI_TypeDef* SPIx, SPI_IT_TypeDef SPI_IT);
    599          
    600            DMA Mode
    601            ========
    602            In DMA Mode, the SPI communication can be managed by 2 DMA Channel requests:
    603               1. SPI_DMAReq_Tx: specifies the Tx buffer DMA transfer request
    604               2. SPI_DMAReq_Rx: specifies the Rx buffer DMA transfer request
    605          
    606            In this Mode it is advised to use the following function:
    607              - void SPI_DMACmd(SPI_TypeDef* SPIx, SPI_DMAReq_TypeDef SPI_DMAReq, FunctionalState NewState);
    608          
    609          @endverbatim
    610            * @{
    611            */
    612          	
    613          /**
    614            * @brief  Enables or disables the specified interrupts.
    615            * @param  SPIx: where x can be 1 to select the specified SPI peripheral.
    616            * @param  SPI_IT Specifies the SPI interrupts sources to be enabled or disabled.
    617            *          This parameter can be one of the following values:
    618            *            @arg SPI_IT_TXE: Transmit buffer empty
    619            *            @arg SPI_IT_RXNE: Receive buffer not empty
    620            *            @arg SPI_IT_ERR: Error
    621            *            @arg SPI_IT_WKUP: Wake-up
    622            * @param  NewState: The new state of the specified SPI interrupts.
    623            *         This parameter can be: ENABLE or DISABLE.
    624            * @retval None
    625            */

   \                                 In section .far_func.text, align 1
    626          void SPI_ITConfig(SPI_TypeDef* SPIx, SPI_IT_TypeDef SPI_IT, FunctionalState NewState)
    627          {
   \                     SPI_ITConfig:
   \   000000 9093         LDW       Y, X
    628            uint8_t itpos = 0;
   \   000002 3F ..        CLR       S:?b1
    629            /* Check function parameters */
    630            assert_param(IS_SPI_CONFIG_IT(SPI_IT));
    631            assert_param(IS_FUNCTIONAL_STATE(NewState));
    632          
    633            /* Get the SPI IT index */
    634            itpos = (uint8_t)((uint8_t)1 << (uint8_t)((uint8_t)SPI_IT & (uint8_t)0x0F));
   \   000004 A4 0F        AND       A, #0xf
   \   000006 5F           CLRW      X
   \   000007 5C           INCW      X
   \   000008 8D ......    CALLF     L:?sll16_x_x_a
   \   00000C 9F           LD        A, XL
   \   00000D B7 ..        LD        S:?b1, A
    635          
    636            if (NewState != DISABLE)
   \   00000F 3D ..        TNZ       S:?b0
   \   000011 27 0E        JREQ      L:??SPI_ITConfig_0
    637            {
    638              SPIx->CR3 |= itpos; /* Enable interrupt*/
   \   000013 93           LDW       X, Y
   \   000014 1C 0002      ADDW      X, #0x2
   \   000017 B6 ..        LD        A, S:?b1
   \   000019 FA           OR        A, (X)
   \   00001A 72A9 0002    ADDW      Y, #0x2
   \   00001E 90F7         LD        (Y), A
   \   000020 87           RETF
    639            }
    640            else
    641            {
    642              SPIx->CR3 &= (uint8_t)(~itpos); /* Disable interrupt*/
   \                     ??SPI_ITConfig_0:
   \   000021 93           LDW       X, Y
   \   000022 1C 0002      ADDW      X, #0x2
   \   000025 33 ..        CPL       S:?b1
   \   000027 B6 ..        LD        A, S:?b1
   \   000029 F4           AND       A, (X)
   \   00002A 72A9 0002    ADDW      Y, #0x2
   \   00002E 90F7         LD        (Y), A
    643            }
    644          }
   \   000030 87           RETF
    645          
    646          /**
    647            * @brief  Checks whether the specified SPI flag is set or not.
    648            * @param  SPIx: where x can be 1 to select the specified SPI peripheral.
    649            * @param  SPI_FLAG: Specifies the flag to check.
    650            *          This parameter can be one of the following values:
    651            *            @arg SPI_FLAG_BSY: Busy
    652            *            @arg SPI_FLAG_OVR: Overrun
    653            *            @arg SPI_FLAG_MODF: Mode fault
    654            *            @arg SPI_FLAG_CRCERR: CRC error
    655            *            @arg SPI_FLAG_WKUP: Wake-up 
    656            *            @arg SPI_FLAG_TXE: Transmit buffer empty
    657            *            @arg SPI_FLAG_RXNE: Receive buffer empty
    658            * @retval Indicates the state of SPI_FLAG.
    659            *         This parameter can be SET or RESET.
    660            */

   \                                 In section .far_func.text, align 1
    661          FlagStatus SPI_GetFlagStatus(SPI_TypeDef* SPIx, SPI_FLAG_TypeDef SPI_FLAG)
    662          {
    663            FlagStatus status = RESET;
   \                     SPI_GetFlagStatus:
   \   000000 3F ..        CLR       S:?b0
    664            /* Check parameters */
    665            assert_param(IS_SPI_FLAG(SPI_FLAG));
    666          
    667            /* Check the status of the specified SPI flag */
    668            if ((SPIx->SR & (uint8_t)SPI_FLAG) != (uint8_t)RESET)
   \   000002 1C 0003      ADDW      X, #0x3
   \   000005 F4           AND       A, (X)
   \   000006 A1 00        CP        A, #0x0
   \   000008 27 06        JREQ      L:??SPI_GetFlagStatus_0
    669            {
    670              status = SET; /* SPI_FLAG is set */
   \   00000A 35 01 ....   MOV       S:?b0, #0x1
   \   00000E 20 02        JRA       L:??SPI_GetFlagStatus_1
    671            }
    672            else
    673            {
    674              status = RESET; /* SPI_FLAG is reset*/
   \                     ??SPI_GetFlagStatus_0:
   \   000010 3F ..        CLR       S:?b0
    675            }
    676          
    677            /* Return the SPI_FLAG status */
    678            return status;
   \                     ??SPI_GetFlagStatus_1:
   \   000012 B6 ..        LD        A, S:?b0
   \   000014 87           RETF
    679          }
    680          
    681          /**
    682            * @brief  Clears the SPI flags.
    683            * @param  SPIx: where x can be 1 to select the specified SPI peripheral.
    684            * @param  SPI_FLAG: Specifies the flag to clear.
    685            *         This parameter can be one of the following values:
    686            *            @arg SPI_FLAG_CRCERR
    687            *            @arg SPI_FLAG_WKUP
    688            * @note   OVR (OverRun Error) interrupt pending bit is cleared by software
    689            *         sequence: a read operation to SPI_DR register (SPI_ReceiveData()) followed by
    690            *         a read operation to SPI_SR register (SPI_GetFlagStatus()).
    691            * @note   MODF (Mode Fault) interrupt pending bit is cleared by software sequence:
    692            *         a read/write operation to SPI_SR register (SPI_GetFlagStatus()) followed by
    693            *         a write operation to SPI_CR1 register (SPI_Cmd() to enable the SPI).
    694            * @retval None
    695            */

   \                                 In section .far_func.text, align 1
    696          void SPI_ClearFlag(SPI_TypeDef* SPIx, SPI_FLAG_TypeDef SPI_FLAG)
    697          {
    698            assert_param(IS_SPI_CLEAR_FLAG(SPI_FLAG));
    699            /* Clear the flag bit */
    700            SPIx->SR = (uint8_t)(~SPI_FLAG);
   \                     SPI_ClearFlag:
   \   000000 1C 0003      ADDW      X, #0x3
   \   000003 43           CPL       A
   \   000004 F7           LD        (X), A
    701          }
   \   000005 87           RETF
    702          
    703          /**
    704            * @brief  Checks whether the specified interrupt has occurred or not.
    705            * @param  SPIx: where x can be 1 to select the specified SPI peripheral.
    706            * @param  SPI_IT: Specifies the SPI interrupt pending bit to check.
    707            *         This parameter can be one of the following values:
    708            *            @arg SPI_IT_CRCERR
    709            *            @arg SPI_IT_WKUP
    710            *            @arg SPI_IT_OVR
    711            *            @arg SPI_IT_MODF
    712            *            @arg SPI_IT_RXNE
    713            *            @arg SPI_IT_TXE
    714            * @retval Indicates the state of the SPI_IT.
    715          
    716            */

   \                                 In section .far_func.text, align 1
    717          ITStatus SPI_GetITStatus(SPI_TypeDef* SPIx, SPI_IT_TypeDef SPI_IT)
    718          {
   \                     SPI_GetITStatus:
   \   000000 52 01        SUB       SP, #0x1
   \   000002 9093         LDW       Y, X
   \   000004 B7 ..        LD        S:?b4, A
    719            ITStatus pendingbitstatus = RESET;
   \   000006 3F ..        CLR       S:?b0
    720            uint8_t itpos = 0;
   \   000008 3F ..        CLR       S:?b3
    721            uint8_t itmask1 = 0;
   \   00000A 3F ..        CLR       S:?b1
    722            uint8_t itmask2 = 0;
   \   00000C 3F ..        CLR       S:?b2
    723            __IO uint8_t enablestatus = 0;
   \   00000E 4F           CLR       A
   \   00000F 6B 01        LD        (0x1,SP), A
    724            assert_param(IS_SPI_GET_IT(SPI_IT));
    725            /* Get the SPI IT index */
    726            itpos = (uint8_t)((uint8_t)1 << ((uint8_t)SPI_IT & (uint8_t)0x0F));
   \   000011 B6 ..        LD        A, S:?b4
   \   000013 A4 0F        AND       A, #0xf
   \   000015 5F           CLRW      X
   \   000016 5C           INCW      X
   \   000017 8D ......    CALLF     L:?sll16_x_x_a
   \   00001B 9F           LD        A, XL
   \   00001C B7 ..        LD        S:?b3, A
    727          
    728            /* Get the SPI IT mask */
    729            itmask1 = (uint8_t)((uint8_t)SPI_IT >> (uint8_t)4);
   \   00001E B6 ..        LD        A, S:?b4
   \   000020 4E           SWAP      A
   \   000021 A4 0F        AND       A, #0xf
   \   000023 B7 ..        LD        S:?b1, A
    730            /* Set the IT mask */
    731            itmask2 = (uint8_t)((uint8_t)1 << itmask1);
   \   000025 5F           CLRW      X
   \   000026 5C           INCW      X
   \   000027 B6 ..        LD        A, S:?b1
   \   000029 8D ......    CALLF     L:?sll16_x_x_a
   \   00002D 9F           LD        A, XL
   \   00002E B7 ..        LD        S:?b2, A
    732            /* Get the SPI_IT enable bit status */
    733            enablestatus = (uint8_t)((uint8_t)SPIx->SR & itmask2);
   \   000030 93           LDW       X, Y
   \   000031 1C 0003      ADDW      X, #0x3
   \   000034 B6 ..        LD        A, S:?b2
   \   000036 F4           AND       A, (X)
   \   000037 6B 01        LD        (0x1,SP), A
    734            /* Check the status of the specified SPI interrupt */
    735            if (((SPIx->CR3 & itpos) != RESET) && enablestatus)
   \   000039 72A9 0002    ADDW      Y, #0x2
   \   00003D B6 ..        LD        A, S:?b3
   \   00003F 90F4         AND       A, (Y)
   \   000041 A1 00        CP        A, #0x0
   \   000043 27 0A        JREQ      L:??SPI_GetITStatus_0
   \   000045 0D 01        TNZ       (0x1,SP)
   \   000047 27 06        JREQ      L:??SPI_GetITStatus_0
    736            {
    737              /* SPI_IT is set */
    738              pendingbitstatus = SET;
   \   000049 35 01 ....   MOV       S:?b0, #0x1
   \   00004D 20 02        JRA       L:??SPI_GetITStatus_1
    739            }
    740            else
    741            {
    742              /* SPI_IT is reset */
    743              pendingbitstatus = RESET;
   \                     ??SPI_GetITStatus_0:
   \   00004F 3F ..        CLR       S:?b0
    744            }
    745            /* Return the SPI_IT status */
    746            return  pendingbitstatus;
   \                     ??SPI_GetITStatus_1:
   \   000051 B6 ..        LD        A, S:?b0
   \   000053 5B 01        ADD       SP, #0x1
   \   000055 87           RETF
    747          }
    748          
    749          /**
    750            * @brief  Clears the interrupt pending bits.
    751            * @param  SPIx: where x can be 1 to select the specified SPI peripheral.
    752            * @param  SPI_IT: Specifies the interrupt pending bit to clear.
    753            *         This parameter can be one of the following values:
    754            *            @arg SPI_IT_CRCERR
    755            *            @arg SPI_IT_WKUP
    756            * @note   OVR (OverRun Error) interrupt pending bit is cleared by software sequence:
    757            *         a read operation to SPI_DR register (SPI_ReceiveData()) followed by
    758            *         a read operation to SPI_SR register (SPI_GetITStatus()).
    759            * @note   MODF (Mode Fault) interrupt pending bit is cleared by software sequence:
    760            *         a read/write operation to SPI_SR register (SPI_GetITStatus()) followed by
    761            *         a write operation to SPI_CR1 register (SPI_Cmd() to enable the SPI).
    762            * @retval None
    763            */

   \                                 In section .far_func.text, align 1
    764          void SPI_ClearITPendingBit(SPI_TypeDef* SPIx, SPI_IT_TypeDef SPI_IT)
    765          {
   \                     SPI_ClearITPendingBit:
   \   000000 9093         LDW       Y, X
    766            uint8_t itpos = 0;
   \   000002 3F ..        CLR       S:?b0
    767            assert_param(IS_SPI_CLEAR_IT(SPI_IT));
    768          
    769            /* Clear  SPI_IT_CRCERR or SPI_IT_WKUP interrupt pending bits */
    770          
    771            /* Get the SPI pending bit index */
    772            itpos = (uint8_t)((uint8_t)1 << (uint8_t)((uint8_t)(SPI_IT & (uint8_t)0xF0) >> 4));
   \   000004 4E           SWAP      A
   \   000005 A4 0F        AND       A, #0xf
   \   000007 5F           CLRW      X
   \   000008 5C           INCW      X
   \   000009 8D ......    CALLF     L:?sll16_x_x_a
   \   00000D 9F           LD        A, XL
   \   00000E B7 ..        LD        S:?b0, A
    773            /* Clear the pending bit */
    774            SPIx->SR = (uint8_t)(~itpos);
   \   000010 72A9 0003    ADDW      Y, #0x3
   \   000014 33 ..        CPL       S:?b0
   \   000016 B6 ..        LD        A, S:?b0
   \   000018 90F7         LD        (Y), A
    775          
    776          }
   \   00001A 87           RETF
    777          
    778          /**
    779            * @}
    780            */
    781          
    782          /**
    783            * @}
    784            */ 
    785          
    786          /**
    787            * @}
    788            */ 
    789          
    790          /**
    791            * @}
    792            */ 
    793          
    794          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Section sizes:

   Bytes  Function/Label
   -----  --------------
      25  SPI_BiDirectionalLineConfig
      52  SPI_CalculateCRCCmd
       6  SPI_ClearFlag
      27  SPI_ClearITPendingBit
      13  SPI_Cmd
      31  SPI_DMACmd
      35  SPI_DeInit
      22  SPI_GetCRC
       5  SPI_GetCRCPolynomial
      21  SPI_GetFlagStatus
      86  SPI_GetITStatus
      49  SPI_ITConfig
      74  SPI_Init
      25  SPI_NSSInternalSoftwareCmd
       5  SPI_ReceiveData
      26  SPI_ResetCRC
       5  SPI_SendData
      11  SPI_TransmitCRC

 
 518 bytes in section .far_func.text
 
 518 bytes of CODE memory

Errors: none
Warnings: none
