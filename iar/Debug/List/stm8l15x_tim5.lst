###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.42.1.142 for STM8               01/Jul/2016  17:30:50 #
# Copyright 2010-2013 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  E:\hwpro-2016\20160627_L\stm8l15x_lib\src\stm8l15x_tim5. #
#                    c                                                        #
#    Command line =  E:\hwpro-2016\20160627_L\stm8l15x_lib\src\stm8l15x_tim5. #
#                    c -e -Ol --no_cse --no_unroll --no_inline                #
#                    --no_code_motion --no_tbaa --no_cross_call --debug       #
#                    --code_model medium --data_model medium -o               #
#                    E:\hwpro-2016\20160627_L\iar\Debug\Obj\ --dlib_config    #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.5\stm8\LIB\dlstm8mmn.h" -D STM8L15X_MD -lC             #
#                    E:\hwpro-2016\20160627_L\iar\Debug\List\ -I              #
#                    E:\hwpro-2016\20160627_L\iar\..\stm8l15x_lib\inc\ -I     #
#                    E:\hwpro-2016\20160627_L\iar\..\user\inc\ -I             #
#                    E:\hwpro-2016\20160627_L\iar\..\utils\xprintf\ -I        #
#                    E:\hwpro-2016\20160627_L\iar\..\drivers\ -I              #
#                    E:\hwpro-2016\20160627_L\iar\..\utils\ -I                #
#                    E:\hwpro-2016\20160627_L\iar\..\app\ --vregs 16          #
#    List file    =  E:\hwpro-2016\20160627_L\iar\Debug\List\stm8l15x_tim5.ls #
#                    t                                                        #
#    Object file  =  E:\hwpro-2016\20160627_L\iar\Debug\Obj\stm8l15x_tim5.o   #
#                                                                             #
#                                                                             #
###############################################################################

E:\hwpro-2016\20160627_L\stm8l15x_lib\src\stm8l15x_tim5.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm8l15x_tim5.c
      4            * @author  MCD Application Team
      5            * @version V1.6.1
      6            * @date    30-September-2014
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the TIM5 peripheral:
      9            *            - TimeBase management
     10            *            - Output Compare management
     11            *            - Input Capture management
     12            *            - Interrupts, DMA and flags management
     13            *            - Clocks management
     14            *            - Synchronization management
     15            *            - Specific interface management
     16            *              
     17            *  @verbatim
     18            *  
     19            *          ===================================================================
     20            *                                 How to use this driver
     21            *          ===================================================================
     22            *          This driver provides functions to configure and initialize the TIM5
     23            *          peripheral
     24            *          These functions are split in 7 groups: 
     25            *   
     26            *          1. TIM5 TimeBase management: this group includes all needed functions 
     27            *             to configure the TIM Timebase unit:
     28            *                   - Set/Get Prescaler
     29            *                   - Set/Get Autoreload  
     30            *                   - Counter modes configuration
     31            *                   - Select the One Pulse mode
     32            *                   - Update Request Configuration
     33            *                   - Update Disable Configuration
     34            *                   - Auto-Preload Configuration 
     35            *                   - Enable/Disable the counter
     36            *                 
     37            *          2. TIM5 Output Compare management: this group includes all needed 
     38            *             functions to configure the Capture/Compare unit used in Output 
     39            *             compare mode: 
     40            *                   - Configure each channel, independently, in Output Compare mode
     41            *                   - Select the output compare modes
     42            *                   - Select the Polarities of each channel
     43            *                   - Set/Get the Capture/Compare register values
     44            *                   - Select the Output Compare Fast mode 
     45            *                   - Select the Output Compare Forced mode  
     46            *                   - Output Compare-Preload Configuration 
     47            *                   - Enable/Disable the Capture/Compare Channels    
     48            *                   
     49            *          3. TIM5 Input Capture management: this group includes all needed 
     50            *             functions to configure the Capture/Compare unit used in 
     51            *             Input Capture mode:
     52            *                   - Configure each channel in input capture mode
     53            *                   - Configure Channel1/2 in PWM Input mode
     54            *                   - Set the Input Capture Prescaler
     55            *                   - Get the Capture/Compare values      
     56            *        
     57            *          4. TIM5 interrupts, DMA and flags management
     58            *                   - Enable/Disable interrupt sources
     59            *                   - Get flags status
     60            *                   - Clear flags/ Pending bits
     61            *                   - Enable/Disable DMA requests 
     62            *                   - Select CaptureCompare DMA request  
     63            *              
     64            *          5. TIM5 clocks management: this group includes all needed functions 
     65            *             to configure the clock controller unit:
     66            *                   - Select internal/External clock
     67            *                   - Select the external clock mode: ETR(Mode1/Mode2) or TIx
     68            *         
     69            *          6. TIM5 synchronization management: this group includes all needed 
     70            *             functions to configure the Synchronization unit:
     71            *                   - Select Input Trigger  
     72            *                   - Select Output Trigger  
     73            *                   - Select Master Slave Mode 
     74            *                   - ETR Configuration when used as external trigger   
     75            *     
     76            *          7. TIM5 specific interface management, this group includes all 
     77            *             needed functions to use the specific TIM5 interface:
     78            *                   - Encoder Interface Configuration
     79            *                   - Select Hall Sensor        
     80            *   
     81            *  @endverbatim
     82            *    
     83            ******************************************************************************
     84            * @attention
     85            *
     86            * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
     87            *
     88            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     89            * You may not use this file except in compliance with the License.
     90            * You may obtain a copy of the License at:
     91            *
     92            *        http://www.st.com/software_license_agreement_liberty_v2
     93            *
     94            * Unless required by applicable law or agreed to in writing, software 
     95            * distributed under the License is distributed on an "AS IS" BASIS, 
     96            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     97            * See the License for the specific language governing permissions and
     98            * limitations under the License.
     99            *
    100            ******************************************************************************
    101            */
    102          
    103          /* Includes ------------------------------------------------------------------*/
    104          #include "stm8l15x_TIM5.h"
    105          
    106          /** @addtogroup STM8L15x_StdPeriph_Driver
    107            * @{
    108            */
    109          
    110          /** @defgroup TIM5 
    111            * @brief TIM5 driver modules
    112            * @{
    113            */
    114            
    115          /* Private typedef -----------------------------------------------------------*/
    116          /* Private define ------------------------------------------------------------*/
    117          /* Private macro -------------------------------------------------------------*/
    118          /* Private variables ---------------------------------------------------------*/
    119          /* Private function prototypes -----------------------------------------------*/
    120          static void TI1_Config(TIM5_ICPolarity_TypeDef TIM5_ICPolarity,
    121                                 TIM5_ICSelection_TypeDef TIM5_ICSelection,
    122                                 uint8_t TIM5_ICFilter);
    123          static void TI2_Config(TIM5_ICPolarity_TypeDef TIM5_ICPolarity,
    124                                 TIM5_ICSelection_TypeDef TIM5_ICSelection,
    125                                 uint8_t TIM5_ICFilter);
    126          
    127          
    128          /** @defgroup TIM5_Private_Functions
    129            * @{
    130            */
    131          
    132          /** @defgroup TIM5_Group1 TimeBase management functions
    133           *  @brief   TimeBase management functions 
    134           *
    135          @verbatim   
    136           ===============================================================================
    137                                 TimeBase management functions
    138           ===============================================================================  
    139            
    140                 ===================================================================      
    141                        TIM5 Driver: how to use it in Timing(Time base) Mode
    142                 =================================================================== 
    143                 To use the Timer in Timing(Time base) mode, the following steps are mandatory:
    144                 
    145                 1. Enable TIM5 clock using CLK_PeripheralClockConfig(CLK_Peripheral_TIM5, ENABLE) function.
    146                  
    147                 2. Call TIM5_TimeBaseInit() to configure the Time Base unit with the
    148                    corresponding configuration.
    149                    
    150                 3. Enable global interrupts if you need to generate the update interrupt.
    151                    
    152                 4. Enable the corresponding interrupt using the function TIM5_ITConfig(TIM5_IT_Update) 
    153                    
    154                 5. Call the TIM5_Cmd(ENABLE) function to enable the TIM5 counter.
    155                 
    156                 Note1: All other functions can be used separately to modify, if needed,
    157                    a specific feature of the Timer. 
    158          
    159          @endverbatim
    160            * @{
    161            */
    162          
    163          /**
    164            * @brief  Deinitialize the TIM5 peripheral registers to their default reset values.
    165            * @param  None
    166            * @retval None
    167            */

   \                                 In section .far_func.text, align 1
    168          void TIM5_DeInit(void)
    169          {
    170            TIM5->CR1 = TIM_CR1_RESET_VALUE;
   \                     TIM5_DeInit:
   \   000000 35 00 5300   MOV       L:0x5300, #0x0
    171            TIM5->CR2 = TIM_CR2_RESET_VALUE;
   \   000004 35 00 5301   MOV       L:0x5301, #0x0
    172            TIM5->SMCR = TIM_SMCR_RESET_VALUE;
   \   000008 35 00 5302   MOV       L:0x5302, #0x0
    173            TIM5->ETR = TIM_ETR_RESET_VALUE;
   \   00000C 35 00 5303   MOV       L:0x5303, #0x0
    174            TIM5->IER = TIM_IER_RESET_VALUE;
   \   000010 35 00 5305   MOV       L:0x5305, #0x0
    175            TIM5->SR2 = TIM_SR2_RESET_VALUE;
   \   000014 35 00 5307   MOV       L:0x5307, #0x0
    176          
    177            /* Disable channels */
    178            TIM5->CCER1 = TIM_CCER1_RESET_VALUE;
   \   000018 35 00 530B   MOV       L:0x530b, #0x0
    179            /* Configure channels as inputs: it is necessary if lock level is equal to 2 or 3 */
    180            TIM5->CCMR1 = 0x01;/*TIM5_ICxSource_TIxFPx */
   \   00001C 35 01 5309   MOV       L:0x5309, #0x1
    181            TIM5->CCMR2 = 0x01;/*TIM5_ICxSource_TIxFPx */
   \   000020 35 01 530A   MOV       L:0x530a, #0x1
    182          
    183            /* Then reset channel registers: it also works if lock level is equal to 2 or 3 */
    184            TIM5->CCER1 = TIM_CCER1_RESET_VALUE;
   \   000024 35 00 530B   MOV       L:0x530b, #0x0
    185            TIM5->CCMR1 = TIM_CCMR1_RESET_VALUE;
   \   000028 35 00 5309   MOV       L:0x5309, #0x0
    186            TIM5->CCMR2 = TIM_CCMR2_RESET_VALUE;
   \   00002C 35 00 530A   MOV       L:0x530a, #0x0
    187          
    188            TIM5->CNTRH = TIM_CNTRH_RESET_VALUE;
   \   000030 35 00 530C   MOV       L:0x530c, #0x0
    189            TIM5->CNTRL = TIM_CNTRL_RESET_VALUE;
   \   000034 35 00 530D   MOV       L:0x530d, #0x0
    190          
    191            TIM5->PSCR = TIM_PSCR_RESET_VALUE;
   \   000038 35 00 530E   MOV       L:0x530e, #0x0
    192          
    193            TIM5->ARRH = TIM_ARRH_RESET_VALUE;
   \   00003C 35 FF 530F   MOV       L:0x530f, #0xff
    194            TIM5->ARRL = TIM_ARRL_RESET_VALUE;
   \   000040 35 FF 5310   MOV       L:0x5310, #0xff
    195          
    196            TIM5->CCR1H = TIM_CCR1H_RESET_VALUE;
   \   000044 35 00 5311   MOV       L:0x5311, #0x0
    197            TIM5->CCR1L = TIM_CCR1L_RESET_VALUE;
   \   000048 35 00 5312   MOV       L:0x5312, #0x0
    198            TIM5->CCR2H = TIM_CCR2H_RESET_VALUE;
   \   00004C 35 00 5313   MOV       L:0x5313, #0x0
    199            TIM5->CCR2L = TIM_CCR2L_RESET_VALUE;
   \   000050 35 00 5314   MOV       L:0x5314, #0x0
    200          
    201          
    202            TIM5->OISR = TIM_OISR_RESET_VALUE;
   \   000054 35 00 5316   MOV       L:0x5316, #0x0
    203            TIM5->EGR = 0x01;/* TIM_EGR_UG */
   \   000058 35 01 5308   MOV       L:0x5308, #0x1
    204            TIM5->BKR = TIM_BKR_RESET_VALUE;
   \   00005C 35 00 5315   MOV       L:0x5315, #0x0
    205            TIM5->SR1 = TIM_SR1_RESET_VALUE;
   \   000060 35 00 5306   MOV       L:0x5306, #0x0
    206          }
   \   000064 87           RETF
    207          
    208          /**
    209            * @brief  Initializes the TIM5 Time Base Unit according to the specified  parameters.
    210            * @param  TIM5_Prescaler: Prescaler 
    211            *          This parameter can be one of the following values:
    212            *            @arg TIM5_Prescaler_1: Time base Prescaler = 1 (No effect)
    213            *            @arg TIM5_Prescaler_2: Time base Prescaler = 2
    214            *            @arg TIM5_Prescaler_4: Time base Prescaler = 4
    215            *            @arg TIM5_Prescaler_8: Time base Prescaler = 8
    216            *            @arg TIM5_Prescaler_16: Time base Prescaler = 16
    217            *            @arg TIM5_Prescaler_32: Time base Prescaler = 32
    218            *            @arg TIM5_Prescaler_64: Time base Prescaler = 64
    219            *            @arg TIM5_Prescaler_128: Time base Prescaler = 128                            
    220            * @param  TIM5_CounterMode: Counter mode
    221            *          This parameter can be one of the following values:
    222            *            @arg TIM5_CounterMode_Up: Counter Up Mode
    223            *            @arg TIM5_CounterMode_Down: Counter Down Mode
    224            *            @arg TIM5_CounterMode_CenterAligned1: Counter Central aligned Mode 1
    225            *            @arg TIM5_CounterMode_CenterAligned2: Counter Central aligned Mode 2
    226            *            @arg TIM5_CounterMode_CenterAligned3: Counter Central aligned Mode 3        
    227            * @param  TIM5_Period: This parameter must be a value between 0x0000 and 0xFFFF.
    228            * @retval None
    229            */
    230          

   \                                 In section .far_func.text, align 1
    231          void TIM5_TimeBaseInit(TIM5_Prescaler_TypeDef TIM5_Prescaler,
    232                                 TIM5_CounterMode_TypeDef TIM5_CounterMode,
    233                                 uint16_t TIM5_Period)
    234          {
   \                     TIM5_TimeBaseInit:
   \   000000 B7 ..        LD        S:?b1, A
   \   000002 9093         LDW       Y, X
    235          
    236            assert_param(IS_TIM5_PRESCALER(TIM5_Prescaler));
    237            assert_param(IS_TIM5_COUNTER_MODE(TIM5_CounterMode));
    238          
    239          
    240          
    241            /* Set the Autoreload value */
    242            TIM5->ARRH = (uint8_t)(TIM5_Period >> 8) ;
   \   000004 93           LDW       X, Y
   \   000005 4F           CLR       A
   \   000006 01           RRWA      X, A
   \   000007 9F           LD        A, XL
   \   000008 C7 530F      LD        L:0x530f, A
    243            TIM5->ARRL = (uint8_t)(TIM5_Period);
   \   00000B 909F         LD        A, YL
   \   00000D C7 5310      LD        L:0x5310, A
    244          
    245            /* Set the Prescaler value */
    246            TIM5->PSCR = (uint8_t)(TIM5_Prescaler);
   \   000010 B6 ..        LD        A, S:?b1
   \   000012 C7 530E      LD        L:0x530e, A
    247          
    248            /* Select the Counter Mode */
    249            TIM5->CR1 &= (uint8_t)((uint8_t)(~TIM_CR1_CMS)) & ((uint8_t)(~TIM_CR1_DIR));
   \   000015 C6 5300      LD        A, L:0x5300
   \   000018 A4 8F        AND       A, #0x8f
   \   00001A C7 5300      LD        L:0x5300, A
    250            TIM5->CR1 |= (uint8_t)(TIM5_CounterMode);
   \   00001D B6 ..        LD        A, S:?b0
   \   00001F CA 5300      OR        A, L:0x5300
   \   000022 C7 5300      LD        L:0x5300, A
    251          
    252            /* Generate an update event to reload the Prescaler value immediately */
    253            TIM5->EGR = TIM5_EventSource_Update;
   \   000025 35 01 5308   MOV       L:0x5308, #0x1
    254          }
   \   000029 87           RETF
    255          
    256          /**
    257            * @brief  Configures the TIM5 Prescaler.
    258            * @param  Prescaler: Specifies the Prescaler Register value
    259            *          This parameter can be one of the following values:
    260            *            @arg TIM5_Prescaler_1: Time base Prescaler = 1 (No effect)
    261            *            @arg TIM5_Prescaler_2: Time base Prescaler = 2
    262            *            @arg TIM5_Prescaler_4: Time base Prescaler = 4
    263            *            @arg TIM5_Prescaler_8: Time base Prescaler = 8
    264            *            @arg TIM5_Prescaler_16: Time base Prescaler = 16
    265            *            @arg TIM5_Prescaler_32: Time base Prescaler = 32
    266            *            @arg TIM5_Prescaler_64: Time base Prescaler = 64
    267            *            @arg TIM5_Prescaler_128: Time base Prescaler = 128  
    268            * @param  TIM5_PSCReloadMode: Specifies the TIM5 Prescaler Reload mode.
    269            *          This parameter can be one of the following values:
    270            *            @arg TIM5_PSCReloadMode_Update: Prescaler value is reloaded at every update
    271            *            @arg TIM5_PSCReloadMode_Immediate: Prescaler value is reloaded at every update  
    272            * @retval None
    273            */

   \                                 In section .far_func.text, align 1
    274          void TIM5_PrescalerConfig(TIM5_Prescaler_TypeDef Prescaler,
    275                                    TIM5_PSCReloadMode_TypeDef TIM5_PSCReloadMode)
    276          {
    277            /* Check the parameters */
    278            assert_param(IS_TIM5_PRESCALER(Prescaler));
    279            assert_param(IS_TIM5_PRESCALER_RELOAD(TIM5_PSCReloadMode));
    280          
    281            /* Set the Prescaler value */
    282            TIM5->PSCR = (uint8_t)(Prescaler);
   \                     TIM5_PrescalerConfig:
   \   000000 C7 530E      LD        L:0x530e, A
    283          
    284            /* Set or reset the UG Bit */
    285            if (TIM5_PSCReloadMode == TIM5_PSCReloadMode_Immediate)
   \   000003 B6 ..        LD        A, S:?b0
   \   000005 A1 01        CP        A, #0x1
   \   000007 26 05        JRNE      L:??TIM5_PrescalerConfig_0
    286            {
    287              TIM5->EGR |= TIM_EGR_UG ;
   \   000009 7210 5308    BSET      L:0x5308, #0x0
   \   00000D 87           RETF
    288            }
    289            else
    290            {
    291              TIM5->EGR &= (uint8_t)(~TIM_EGR_UG) ;
   \                     ??TIM5_PrescalerConfig_0:
   \   00000E 7211 5308    BRES      L:0x5308, #0x0
    292            }
    293          }
   \   000012 87           RETF
    294          
    295          /**
    296            * @brief  Specifies the TIM5 Counter Mode to be used.
    297            * @param  TIM5_CounterMode: Specifies the Counter Mode to be used
    298            *          This parameter can be one of the following values:
    299            *            @arg TIM5_CounterMode_Up: Counter Up Mode
    300            *            @arg TIM5_CounterMode_Down: Counter Down Mode
    301            *            @arg TIM5_CounterMode_CenterAligned1: Counter Central aligned Mode 1
    302            *            @arg TIM5_CounterMode_CenterAligned2: Counter Central aligned Mode 2
    303            *            @arg TIM5_CounterMode_CenterAligned3: Counter Central aligned Mode 3      
    304            * @retval None
    305            */

   \                                 In section .far_func.text, align 1
    306          void TIM5_CounterModeConfig(TIM5_CounterMode_TypeDef TIM5_CounterMode)
    307          {
   \                     TIM5_CounterModeConfig:
   \   000000 B7 ..        LD        S:?b0, A
    308            uint8_t tmpcr1 = 0;
   \   000002 3F ..        CLR       S:?b1
    309          
    310            /* Check the parameters */
    311            assert_param(IS_TIM5_COUNTER_MODE(TIM5_CounterMode));
    312          
    313            tmpcr1 = TIM5->CR1;
   \   000004 C6 5300      LD        A, L:0x5300
   \   000007 B7 ..        LD        S:?b1, A
    314          
    315            /* Reset the CMS and DIR Bits */
    316            tmpcr1 &= (uint8_t)((uint8_t)(~TIM_CR1_CMS) & (uint8_t)(~TIM_CR1_DIR));
   \   000009 B6 ..        LD        A, S:?b1
   \   00000B A4 8F        AND       A, #0x8f
   \   00000D B7 ..        LD        S:?b1, A
    317          
    318            /* Set the Counter Mode */
    319            tmpcr1 |= (uint8_t)TIM5_CounterMode;
   \   00000F B6 ..        LD        A, S:?b0
   \   000011 BA ..        OR        A, S:?b1
   \   000013 B7 ..        LD        S:?b1, A
    320          
    321            TIM5->CR1 = tmpcr1;
   \   000015 B6 ..        LD        A, S:?b1
   \   000017 C7 5300      LD        L:0x5300, A
    322          }
   \   00001A 87           RETF
    323          
    324          /**
    325            * @brief  Sets the TIM5 Counter Register value.
    326            * @param  Counter: Specifies the Counter register new value.
    327            *          This parameter is between 0x0000 and 0xFFFF.
    328            * @retval None
    329            */

   \                                 In section .far_func.text, align 1
    330          void TIM5_SetCounter(uint16_t Counter)
    331          {
   \                     TIM5_SetCounter:
   \   000000 9093         LDW       Y, X
    332          
    333            /* Set the Counter Register value */
    334            TIM5->CNTRH = (uint8_t)(Counter >> 8);
   \   000002 93           LDW       X, Y
   \   000003 4F           CLR       A
   \   000004 01           RRWA      X, A
   \   000005 9F           LD        A, XL
   \   000006 C7 530C      LD        L:0x530c, A
    335            TIM5->CNTRL = (uint8_t)(Counter);
   \   000009 909F         LD        A, YL
   \   00000B C7 530D      LD        L:0x530d, A
    336          }
   \   00000E 87           RETF
    337          
    338          /**
    339            * @brief  Sets the TIM5 Autoreload Register value.
    340            * @param  Autoreload: Specifies the Autoreload register new value.
    341            *          This parameter is between 0x0000 and 0xFFFF.
    342            * @retval None
    343            */

   \                                 In section .far_func.text, align 1
    344          void TIM5_SetAutoreload(uint16_t Autoreload)
    345          {
   \                     TIM5_SetAutoreload:
   \   000000 9093         LDW       Y, X
    346            /* Set the Autoreload Register value */
    347            TIM5->ARRH = (uint8_t)(Autoreload >> 8);
   \   000002 93           LDW       X, Y
   \   000003 4F           CLR       A
   \   000004 01           RRWA      X, A
   \   000005 9F           LD        A, XL
   \   000006 C7 530F      LD        L:0x530f, A
    348            TIM5->ARRL = (uint8_t)(Autoreload);
   \   000009 909F         LD        A, YL
   \   00000B C7 5310      LD        L:0x5310, A
    349          }
   \   00000E 87           RETF
    350          
    351          /**
    352            * @brief  Gets the TIM5 Counter value.
    353            * @param  None
    354            * @retval Counter Register value.
    355            */

   \                                 In section .far_func.text, align 1
    356          uint16_t TIM5_GetCounter(void)
    357          {
    358            uint16_t tmpcnt = 0;
   \                     TIM5_GetCounter:
   \   000000 905F         CLRW      Y
    359            uint8_t tmpcntrl, tmpcntrh;
    360          
    361            tmpcntrh = TIM5->CNTRH;
   \   000002 C6 530C      LD        A, L:0x530c
   \   000005 B7 ..        LD        S:?b0, A
    362            tmpcntrl = TIM5->CNTRL;
   \   000007 C6 530D      LD        A, L:0x530d
    363          
    364            tmpcnt = (uint16_t)(tmpcntrl);
   \   00000A 5F           CLRW      X
   \   00000B 97           LD        XL, A
   \   00000C 9093         LDW       Y, X
    365            tmpcnt |= (uint16_t)((uint16_t)tmpcntrh << 8);
   \   00000E 5F           CLRW      X
   \   00000F 41           EXG       A, XL
   \   000010 B6 ..        LD        A, S:?b0
   \   000012 41           EXG       A, XL
   \   000013 4F           CLR       A
   \   000014 02           RLWA      X, A
   \   000015 BF ..        LDW       S:?w0, X
   \   000017 51           EXGW      X, Y
   \   000018 01           RRWA      X, A
   \   000019 BA ..        OR        A, S:?b1
   \   00001B 01           RRWA      X, A
   \   00001C BA ..        OR        A, S:?b0
   \   00001E 01           RRWA      X, A
   \   00001F 51           EXGW      X, Y
    366            /* Get the Counter Register value */
    367            return ((uint16_t)tmpcnt);
   \   000020 93           LDW       X, Y
   \   000021 87           RETF
    368          }
    369          
    370          /**
    371            * @brief  Gets the TIM5 Prescaler value.
    372            * @param  None
    373            * @retval TIM5 Prescaler, it can be one of the following values:
    374            *            - TIM5_Prescaler_1: Time base Prescaler = 1 (No effect)
    375            *            - TIM5_Prescaler_2: Time base Prescaler = 2
    376            *            - TIM5_Prescaler_4: Time base Prescaler = 4
    377            *            - TIM5_Prescaler_8: Time base Prescaler = 8
    378            *            - TIM5_Prescaler_16: Time base Prescaler = 16
    379            *            - TIM5_Prescaler_32: Time base Prescaler = 32
    380            *            - TIM5_Prescaler_64: Time base Prescaler = 64
    381            *            - TIM5_Prescaler_128: Time base Prescaler = 128    
    382            */

   \                                 In section .far_func.text, align 1
    383          TIM5_Prescaler_TypeDef TIM5_GetPrescaler(void)
    384          {
    385            /* Get the Prescaler Register value */
    386            return ((TIM5_Prescaler_TypeDef)TIM5->PSCR);
   \                     TIM5_GetPrescaler:
   \   000000 C6 530E      LD        A, L:0x530e
   \   000003 87           RETF
    387          }
    388          
    389          /**
    390            * @brief  Enables or Disables the TIM5 Update event.
    391            * @param  NewState: The new state of the TIM5 peripheral Preload register.
    392            *          This parameter can be ENABLE or DISABLE
    393            * @retval None
    394            */
    395          

   \                                 In section .far_func.text, align 1
    396          void TIM5_UpdateDisableConfig(FunctionalState NewState)
    397          {
    398            /* Check the parameters */
    399            assert_param(IS_FUNCTIONAL_STATE(NewState));
    400          
    401            /* Set or Reset the UDIS Bit */
    402            if (NewState != DISABLE)
   \                     TIM5_UpdateDisableConfig:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM5_UpdateDisableConfig_0
    403            {
    404              TIM5->CR1 |= TIM_CR1_UDIS;
   \   000003 7212 5300    BSET      L:0x5300, #0x1
   \   000007 87           RETF
    405            }
    406            else
    407            {
    408              TIM5->CR1 &= (uint8_t)(~TIM_CR1_UDIS);
   \                     ??TIM5_UpdateDisableConfig_0:
   \   000008 7213 5300    BRES      L:0x5300, #0x1
    409            }
    410          }
   \   00000C 87           RETF
    411          
    412          /**
    413            * @brief  Selects the TIM5 Update Request Interrupt source.
    414            * @param  TIM5_UpdateSource: Specifies the Update source.
    415            *          This parameter can be one of the following values:
    416            *            @arg TIM5_UpdateSource_Global: Global Update request source
    417            *            @arg TIM5_UpdateSource_Regular: Regular Update request source 
    418            * @retval None
    419            */

   \                                 In section .far_func.text, align 1
    420          void TIM5_UpdateRequestConfig(TIM5_UpdateSource_TypeDef TIM5_UpdateSource)
    421          {
    422            /* Check the parameters */
    423            assert_param(IS_TIM5_UPDATE_SOURCE(TIM5_UpdateSource));
    424          
    425            /* Set or Reset the URS Bit */
    426            if (TIM5_UpdateSource == TIM5_UpdateSource_Regular)
   \                     TIM5_UpdateRequestConfig:
   \   000000 A1 01        CP        A, #0x1
   \   000002 26 05        JRNE      L:??TIM5_UpdateRequestConfig_0
    427            {
    428              TIM5->CR1 |= TIM_CR1_URS ;
   \   000004 7214 5300    BSET      L:0x5300, #0x2
   \   000008 87           RETF
    429            }
    430            else
    431            {
    432              TIM5->CR1 &= (uint8_t)(~TIM_CR1_URS);
   \                     ??TIM5_UpdateRequestConfig_0:
   \   000009 7215 5300    BRES      L:0x5300, #0x2
    433            }
    434          }
   \   00000D 87           RETF
    435          
    436          /**
    437            * @brief  Enables or disables TIM5 peripheral Preload register on ARR.
    438            * @param  NewState: The new state of the TIM5 peripheral Preload register.
    439            *          This parameter can be ENABLE or DISABLE
    440            * @retval None
    441            */

   \                                 In section .far_func.text, align 1
    442          void TIM5_ARRPreloadConfig(FunctionalState NewState)
    443          {
    444            /* Check the parameters */
    445            assert_param(IS_FUNCTIONAL_STATE(NewState));
    446          
    447            /* Set or Reset the ARPE Bit */
    448            if (NewState != DISABLE)
   \                     TIM5_ARRPreloadConfig:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM5_ARRPreloadConfig_0
    449            {
    450              TIM5->CR1 |= TIM_CR1_ARPE;
   \   000003 721E 5300    BSET      L:0x5300, #0x7
   \   000007 87           RETF
    451            }
    452            else
    453            {
    454              TIM5->CR1 &= (uint8_t)(~TIM_CR1_ARPE);
   \                     ??TIM5_ARRPreloadConfig_0:
   \   000008 721F 5300    BRES      L:0x5300, #0x7
    455            }
    456          }
   \   00000C 87           RETF
    457          
    458          /**
    459            * @brief  Selects the TIM’s One Pulse Mode.
    460            * @param  TIM5_OPMode: Specifies the OPM Mode to be used.
    461            *          This parameter can be one of the following values:
    462            *            @arg TIM5_OPMode_Single: Single one Pulse mode (OPM Active)
    463            *            @arg TIM5_OPMode_Repetitive: Single one Pulse mode (OPM Active)  
    464            * @retval None
    465            */

   \                                 In section .far_func.text, align 1
    466          void TIM5_SelectOnePulseMode(TIM5_OPMode_TypeDef TIM5_OPMode)
    467          {
    468            /* Check the parameters */
    469            assert_param(IS_TIM5_OPM_MODE(TIM5_OPMode));
    470          
    471            /* Set or Reset the OPM Bit */
    472            if (TIM5_OPMode == TIM5_OPMode_Single)
   \                     TIM5_SelectOnePulseMode:
   \   000000 A1 01        CP        A, #0x1
   \   000002 26 05        JRNE      L:??TIM5_SelectOnePulseMode_0
    473            {
    474              TIM5->CR1 |= TIM_CR1_OPM ;
   \   000004 7216 5300    BSET      L:0x5300, #0x3
   \   000008 87           RETF
    475            }
    476            else
    477            {
    478              TIM5->CR1 &= (uint8_t)(~TIM_CR1_OPM);
   \                     ??TIM5_SelectOnePulseMode_0:
   \   000009 7217 5300    BRES      L:0x5300, #0x3
    479            }
    480          }
   \   00000D 87           RETF
    481          
    482          /**
    483            * @brief  Enables or disables the TIM5 peripheral.
    484            * @param  NewState: The new state of the TIM5 peripheral.
    485            *          This parameter can be ENABLE or DISABLE
    486            * @retval None
    487            */

   \                                 In section .far_func.text, align 1
    488          void TIM5_Cmd(FunctionalState NewState)
    489          {
    490            /* Check the parameters */
    491            assert_param(IS_FUNCTIONAL_STATE(NewState));
    492          
    493            /* set or Reset the CEN Bit */
    494            if (NewState != DISABLE)
   \                     TIM5_Cmd:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM5_Cmd_0
    495            {
    496              TIM5->CR1 |= TIM_CR1_CEN;
   \   000003 7210 5300    BSET      L:0x5300, #0x0
   \   000007 87           RETF
    497            }
    498            else
    499            {
    500              TIM5->CR1 &= (uint8_t)(~TIM_CR1_CEN);
   \                     ??TIM5_Cmd_0:
   \   000008 7211 5300    BRES      L:0x5300, #0x0
    501            }
    502          }
   \   00000C 87           RETF
    503          
    504          /**
    505            * @}
    506            */
    507          
    508          /** @defgroup TIM5_Group2 Output Compare management functions
    509           *  @brief    Output Compare management functions 
    510           *
    511          @verbatim   
    512           ===============================================================================
    513                                  Output Compare management functions
    514           ===============================================================================  
    515             
    516                 ===================================================================      
    517                        TIM5 Driver: how to use it in Output Compare Mode
    518                 =================================================================== 
    519                 To use the Timer in Output Compare mode, the following steps are mandatory:
    520                 
    521                 1. Enable TIM5 clock using CLK_PeripheralClockConfig(CLK_Peripheral_TIM5, ENABLE) function.
    522                 
    523                 2. Configure the TIM5 pins in output mode by configuring the corresponding GPIO pins
    524                    
    525                 3. Configure the Time base unit as described in the first part of this driver, if needed,
    526                    otherwise the Timer will run with the default configuration:
    527                    - Autoreload value = 0xFFFF
    528                    - Prescaler value = 0x0000
    529                    - Counter mode = Up counting
    530                
    531                 4. Call TIM5_OCxInit() to configure the channel x with the desired parameters
    532                    including:
    533                    - TIM5 Output Compare mode: TIM5_OCMode
    534                    - TIM5 Output State: TIM5_OutputState
    535                    - TIM5 Pulse value: TIM5_Pulse
    536                    - TIM5 Output Compare Polarity: TIM5_OCPolarity
    537                    - TIM5 Output Idle State: TIM5_OCIdleState
    538                 
    539                 5. Call the TIM5_Cmd(ENABLE) function to enable the TIM5 counter.
    540                 
    541                 Note1: All other functions can be used separately to modify, if needed,
    542                    a specific feature of the Timer. 
    543                 
    544                 Note2: If the corresponding interrupt or DMA request are needed, the user should:
    545                        1. Enable global interrupts (or the DMA) to use the TIM5 interrupts (or DMA requests). 
    546                        2. Enable the corresponding interrupt (or DMA request) using the function 
    547                        TIM5_ITConfig(TIM5_IT_CCx) (or TIM5_DMACmd(TIM5_DMASource_CCx))   
    548          
    549          @endverbatim
    550            * @{
    551            */
    552          
    553          /**
    554            * @brief  Initializes the TIM5 Channel1 according to the specified parameters.
    555            * @param  TIM5_OCMode: Output Compare Mode 
    556            *          This parameter can be one of the following values:
    557            *            @arg TIM5_OCMode_Timing: Timing (Frozen) Mode
    558            *            @arg TIM5_OCMode_Active: Active Mode
    559            *            @arg TIM5_OCMode_Inactive: Inactive Mode
    560            *            @arg TIM5_OCMode_Toggle: Toggle Mode
    561            *            @arg TIM5_OCMode_PWM1: PWM Mode 1
    562            *            @arg TIM5_OCMode_PWM2: PWM Mode 2          
    563            * @param  TIM5_OutputState: Output state
    564            *          This parameter can be one of the following values:
    565            *            @arg TIM5_OutputState_Disable: Output compare State disabled (channel output disabled)
    566            *            @arg TIM5_OutputState_Enable: Output compare State enabled (channel output enabled)
    567            * @param  TIM5_Pulse: This parameter must be a value between 0x0000 and 0xFFFF.
    568            * @param  TIM5_OCPolarity: Polarity
    569            *          This parameter can be one of the following values:
    570            *            @arg TIM5_OCPolarity_High: Output compare polarity  = High
    571            *            @arg TIM5_OCPolarity_Low: Output compare polarity  = Low 
    572            * @param  TIM5_OCIdleState: Output Compare Idle State
    573            *          This parameter can be one of the following values:
    574            *            @arg TIM5_OCIdleState_Reset: Output Compare Idle state  = Reset
    575            *            @arg TIM5_OCIdleState_Set: Output Compare Idle state  = Set
    576            * @retval None
    577            */

   \                                 In section .far_func.text, align 1
    578          void TIM5_OC1Init(TIM5_OCMode_TypeDef TIM5_OCMode,
    579                            TIM5_OutputState_TypeDef TIM5_OutputState,
    580                            uint16_t TIM5_Pulse,
    581                            TIM5_OCPolarity_TypeDef TIM5_OCPolarity,
    582                            TIM5_OCIdleState_TypeDef TIM5_OCIdleState)
    583          {
   \                     TIM5_OC1Init:
   \   000000 B7 ..        LD        S:?b3, A
   \   000002 9093         LDW       Y, X
    584            uint8_t tmpccmr1 = 0;
   \   000004 3F ..        CLR       S:?b4
    585          
    586            /* Check the parameters */
    587            assert_param(IS_TIM5_OC_MODE(TIM5_OCMode));
    588            assert_param(IS_TIM5_OUTPUT_STATE(TIM5_OutputState));
    589            assert_param(IS_TIM5_OC_POLARITY(TIM5_OCPolarity));
    590            assert_param(IS_TIM5_OCIDLE_STATE(TIM5_OCIdleState));
    591          
    592            tmpccmr1 = TIM5->CCMR1;
   \   000006 C6 5309      LD        A, L:0x5309
   \   000009 B7 ..        LD        S:?b4, A
    593          
    594            /* Disable the Channel 1: Reset the CCE Bit */
    595            TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC1E);
   \   00000B 7211 530B    BRES      L:0x530b, #0x0
    596            /* Reset the Output Compare Bits */
    597            tmpccmr1 &= (uint8_t)(~TIM_CCMR_OCM);
   \   00000F B6 ..        LD        A, S:?b4
   \   000011 A4 8F        AND       A, #0x8f
   \   000013 B7 ..        LD        S:?b4, A
    598          
    599            /* Set the Output Compare Mode */
    600            tmpccmr1 |= (uint8_t)TIM5_OCMode;
   \   000015 B6 ..        LD        A, S:?b3
   \   000017 BA ..        OR        A, S:?b4
   \   000019 B7 ..        LD        S:?b4, A
    601          
    602            TIM5->CCMR1 = tmpccmr1;
   \   00001B B6 ..        LD        A, S:?b4
   \   00001D C7 5309      LD        L:0x5309, A
    603          
    604            /* Set the Output State */
    605            if (TIM5_OutputState == TIM5_OutputState_Enable)
   \   000020 B6 ..        LD        A, S:?b0
   \   000022 A1 01        CP        A, #0x1
   \   000024 26 06        JRNE      L:??TIM5_OC1Init_0
    606            {
    607              TIM5->CCER1 |= TIM_CCER1_CC1E;
   \   000026 7210 530B    BSET      L:0x530b, #0x0
   \   00002A 20 04        JRA       L:??TIM5_OC1Init_1
    608            }
    609            else
    610            {
    611              TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC1E);
   \                     ??TIM5_OC1Init_0:
   \   00002C 7211 530B    BRES      L:0x530b, #0x0
    612            }
    613          
    614            /* Set the Output Polarity */
    615            if (TIM5_OCPolarity == TIM5_OCPolarity_Low)
   \                     ??TIM5_OC1Init_1:
   \   000030 B6 ..        LD        A, S:?b1
   \   000032 A1 01        CP        A, #0x1
   \   000034 26 06        JRNE      L:??TIM5_OC1Init_2
    616            {
    617              TIM5->CCER1 |= TIM_CCER1_CC1P;
   \   000036 7212 530B    BSET      L:0x530b, #0x1
   \   00003A 20 04        JRA       L:??TIM5_OC1Init_3
    618            }
    619            else
    620            {
    621              TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC1P);
   \                     ??TIM5_OC1Init_2:
   \   00003C 7213 530B    BRES      L:0x530b, #0x1
    622            }
    623          
    624            /* Set the Output Idle state */
    625            if (TIM5_OCIdleState == TIM5_OCIdleState_Set)
   \                     ??TIM5_OC1Init_3:
   \   000040 B6 ..        LD        A, S:?b2
   \   000042 A1 01        CP        A, #0x1
   \   000044 26 06        JRNE      L:??TIM5_OC1Init_4
    626            {
    627              TIM5->OISR |= TIM_OISR_OIS1;
   \   000046 7210 5316    BSET      L:0x5316, #0x0
   \   00004A 20 04        JRA       L:??TIM5_OC1Init_5
    628            }
    629            else
    630            {
    631              TIM5->OISR &= (uint8_t)(~TIM_OISR_OIS1);
   \                     ??TIM5_OC1Init_4:
   \   00004C 7211 5316    BRES      L:0x5316, #0x0
    632            }
    633          
    634            /* Set the Pulse value */
    635            TIM5->CCR1H = (uint8_t)(TIM5_Pulse >> 8);
   \                     ??TIM5_OC1Init_5:
   \   000050 93           LDW       X, Y
   \   000051 4F           CLR       A
   \   000052 01           RRWA      X, A
   \   000053 9F           LD        A, XL
   \   000054 C7 5311      LD        L:0x5311, A
    636            TIM5->CCR1L = (uint8_t)(TIM5_Pulse);
   \   000057 909F         LD        A, YL
   \   000059 C7 5312      LD        L:0x5312, A
    637          }
   \   00005C 87           RETF
    638          
    639          /**
    640            * @brief  Initializes the TIM5 Channel2 according to the specified parameters.
    641            * @param  TIM5_OCMode: Output Compare Mode 
    642            *          This parameter can be one of the following values:
    643            *            @arg TIM5_OCMode_Timing: Timing (Frozen) Mode
    644            *            @arg TIM5_OCMode_Active: Active Mode
    645            *            @arg TIM5_OCMode_Inactive: Inactive Mode
    646            *            @arg TIM5_OCMode_Toggle: Toggle Mode
    647            *            @arg TIM5_OCMode_PWM1: PWM Mode 1
    648            *            @arg TIM5_OCMode_PWM2: PWM Mode 2          
    649            * @param  TIM5_OutputState: Output state
    650            *          This parameter can be one of the following values:
    651            *            @arg TIM5_OutputState_Disable: Output compare State disabled (channel output disabled)
    652            *            @arg TIM5_OutputState_Enable: Output compare State enabled (channel output enabled)
    653            * @param  TIM5_Pulse: This parameter must be a value between 0x0000 and 0xFFFF.
    654            * @param  TIM5_OCPolarity: Polarity
    655            *          This parameter can be one of the following values:
    656            *            @arg TIM5_OCPolarity_High: Output compare polarity  = High
    657            *            @arg TIM5_OCPolarity_Low: Output compare polarity  = Low 
    658            * @param  TIM5_OCIdleState: Output Compare Idle State
    659            *          This parameter can be one of the following values:
    660            *            @arg TIM5_OCIdleState_Reset: Output Compare Idle state  = Reset
    661            *            @arg TIM5_OCIdleState_Set: Output Compare Idle state  = Set
    662            * @retval None
    663            */

   \                                 In section .far_func.text, align 1
    664          void TIM5_OC2Init(TIM5_OCMode_TypeDef TIM5_OCMode,
    665                            TIM5_OutputState_TypeDef TIM5_OutputState,
    666                            uint16_t TIM5_Pulse,
    667                            TIM5_OCPolarity_TypeDef TIM5_OCPolarity,
    668                            TIM5_OCIdleState_TypeDef TIM5_OCIdleState)
    669          {
   \                     TIM5_OC2Init:
   \   000000 B7 ..        LD        S:?b3, A
   \   000002 9093         LDW       Y, X
    670            uint8_t tmpccmr2 = 0;
   \   000004 3F ..        CLR       S:?b4
    671          
    672            /* Check the parameters */
    673            assert_param(IS_TIM5_OC_MODE(TIM5_OCMode));
    674            assert_param(IS_TIM5_OUTPUT_STATE(TIM5_OutputState));
    675            assert_param(IS_TIM5_OC_POLARITY(TIM5_OCPolarity));
    676            assert_param(IS_TIM5_OCIDLE_STATE(TIM5_OCIdleState));
    677          
    678            tmpccmr2 = TIM5->CCMR2;
   \   000006 C6 530A      LD        A, L:0x530a
   \   000009 B7 ..        LD        S:?b4, A
    679          
    680            /* Disable the Channel 2: Reset the CCE Bit */
    681            TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC2E);
   \   00000B 7219 530B    BRES      L:0x530b, #0x4
    682          
    683            /* Reset the Output Compare Bits */
    684            tmpccmr2 &= (uint8_t)(~TIM_CCMR_OCM);
   \   00000F B6 ..        LD        A, S:?b4
   \   000011 A4 8F        AND       A, #0x8f
   \   000013 B7 ..        LD        S:?b4, A
    685          
    686            /* Set the Output Compare Mode */
    687            tmpccmr2 |= (uint8_t)TIM5_OCMode;
   \   000015 B6 ..        LD        A, S:?b3
   \   000017 BA ..        OR        A, S:?b4
   \   000019 B7 ..        LD        S:?b4, A
    688          
    689            TIM5->CCMR2 = tmpccmr2;
   \   00001B B6 ..        LD        A, S:?b4
   \   00001D C7 530A      LD        L:0x530a, A
    690          
    691            /* Set the Output State */
    692            if (TIM5_OutputState == TIM5_OutputState_Enable)
   \   000020 B6 ..        LD        A, S:?b0
   \   000022 A1 01        CP        A, #0x1
   \   000024 26 06        JRNE      L:??TIM5_OC2Init_0
    693            {
    694              TIM5->CCER1 |= TIM_CCER1_CC2E;
   \   000026 7218 530B    BSET      L:0x530b, #0x4
   \   00002A 20 04        JRA       L:??TIM5_OC2Init_1
    695            }
    696            else
    697            {
    698              TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC2E);
   \                     ??TIM5_OC2Init_0:
   \   00002C 7219 530B    BRES      L:0x530b, #0x4
    699            }
    700          
    701            /* Set the Output Polarity */
    702            if (TIM5_OCPolarity == TIM5_OCPolarity_Low)
   \                     ??TIM5_OC2Init_1:
   \   000030 B6 ..        LD        A, S:?b1
   \   000032 A1 01        CP        A, #0x1
   \   000034 26 06        JRNE      L:??TIM5_OC2Init_2
    703            {
    704              TIM5->CCER1 |= TIM_CCER1_CC2P;
   \   000036 721A 530B    BSET      L:0x530b, #0x5
   \   00003A 20 04        JRA       L:??TIM5_OC2Init_3
    705            }
    706            else
    707            {
    708              TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC2P);
   \                     ??TIM5_OC2Init_2:
   \   00003C 721B 530B    BRES      L:0x530b, #0x5
    709            }
    710          
    711          
    712            /* Set the Output Idle state */
    713            if (TIM5_OCIdleState == TIM5_OCIdleState_Set)
   \                     ??TIM5_OC2Init_3:
   \   000040 B6 ..        LD        A, S:?b2
   \   000042 A1 01        CP        A, #0x1
   \   000044 26 06        JRNE      L:??TIM5_OC2Init_4
    714            {
    715              TIM5->OISR |= TIM_OISR_OIS2;
   \   000046 7214 5316    BSET      L:0x5316, #0x2
   \   00004A 20 04        JRA       L:??TIM5_OC2Init_5
    716            }
    717            else
    718            {
    719              TIM5->OISR &= (uint8_t)(~TIM_OISR_OIS2);
   \                     ??TIM5_OC2Init_4:
   \   00004C 7215 5316    BRES      L:0x5316, #0x2
    720            }
    721          
    722            /* Set the Pulse value */
    723            TIM5->CCR2H = (uint8_t)(TIM5_Pulse >> 8);
   \                     ??TIM5_OC2Init_5:
   \   000050 93           LDW       X, Y
   \   000051 4F           CLR       A
   \   000052 01           RRWA      X, A
   \   000053 9F           LD        A, XL
   \   000054 C7 5313      LD        L:0x5313, A
    724            TIM5->CCR2L = (uint8_t)(TIM5_Pulse);
   \   000057 909F         LD        A, YL
   \   000059 C7 5314      LD        L:0x5314, A
    725          }
   \   00005C 87           RETF
    726          
    727          /**
    728            * @brief  Configures the Break feature, dead time, Lock level, the OSSI,
    729            *         and the AOE(automatic output enable).
    730            * @param  TIM5_OSSIState: Off-State Selection for Idle mode states.
    731            *          This parameter can be one of the following values:
    732            *            @arg TIM5_OSSIState_Enable: Off-State Selection for Idle mode enabled
    733            *            @arg TIM5_OSSIState_Disable: Off-State Selection for Idle mode disabled 
    734            * @param  TIM5_LockLevel: Lock level.
    735            *          This parameter can be one of the following values:
    736            *            @arg TIM5_LockLevel_Off: Lock option disabled
    737            *            @arg TIM5_LockLevel_1: Select Lock Level 1
    738            *            @arg TIM5_LockLevel_2: Select Lock Level 2
    739            *            @arg TIM5_LockLevel_3: Select Lock Level 3    
    740            * @param  TIM5_BreakState: Break Input enable/disable .
    741            *          This parameter can be one of the following values:
    742            *            @arg TIM5_BreakState_Disable: Break State disabled (break option disabled)
    743            *            @arg TIM5_BreakState_Enable: Break State enabled (break option enabled) 
    744            * @param  TIM5_BreakPolarity: Break Polarity.
    745            *          This parameter can be one of the following values:
    746            *            @arg TIM5_BreakPolarity_High: if Break, channel polarity = High
    747            *            @arg TIM5_BreakPolarity_Low: if Break, channel polarity = Low   
    748            * @param  TIM5_AutomaticOutput: TIM5 AOE Bit Set/Reset .
    749            *          This parameter can be one of the following values:
    750            *            @arg TIM5_AutomaticOutput_Enable: Automatic Output option enabled
    751            *            @arg TIM5_AutomaticOutput_Disable: Automatic Output option disabled
    752            * @retval None
    753            */

   \                                 In section .far_func.text, align 1
    754          void TIM5_BKRConfig(TIM5_OSSIState_TypeDef TIM5_OSSIState,
    755                              TIM5_LockLevel_TypeDef TIM5_LockLevel,
    756                              TIM5_BreakState_TypeDef TIM5_BreakState,
    757                              TIM5_BreakPolarity_TypeDef TIM5_BreakPolarity,
    758                              TIM5_AutomaticOutput_TypeDef TIM5_AutomaticOutput)
    759          
    760          {
   \                     TIM5_BKRConfig:
   \   000000 B7 ..        LD        S:?b4, A
   \   000002 B6 ..        LD        A, S:?b2
    761            /* Check the parameters */
    762            assert_param(IS_TIM5_OSSI_STATE(TIM5_OSSIState));
    763            assert_param(IS_TIM5_LOCK_LEVEL(TIM5_LockLevel));
    764            assert_param(IS_TIM5_BREAK_STATE(TIM5_BreakState));
    765            assert_param(IS_TIM5_BREAK_POLARITY(TIM5_BreakPolarity));
    766            assert_param(IS_TIM5_AUTOMATIC_OUTPUT_STATE(TIM5_AutomaticOutput));
    767          
    768          
    769          
    770            /* Set the Lock level, the Break enable Bit and the Polarity, the OSSI State,
    771            the dead time value and the Automatic Output Enable Bit */
    772            TIM5->BKR = (uint8_t)((uint8_t)((uint8_t)((uint8_t)((uint8_t)TIM5_OSSIState | (uint8_t)TIM5_LockLevel) | \
    773                                            (uint8_t)((uint8_t)TIM5_BreakState | (uint8_t)TIM5_BreakPolarity)) | \
    774                                            TIM5_AutomaticOutput));
   \   000004 BA ..        OR        A, S:?b1
   \   000006 88           PUSH      A
   \   000007 B6 ..        LD        A, S:?b0
   \   000009 BA ..        OR        A, S:?b4
   \   00000B B7 ..        LD        S:?b0, A
   \   00000D 84           POP       A
   \   00000E BA ..        OR        A, S:?b0
   \   000010 BA ..        OR        A, S:?b3
   \   000012 C7 5315      LD        L:0x5315, A
    775          }
   \   000015 87           RETF
    776          
    777          /**
    778            * @brief  Enables or disables the TIM5 peripheral Main Outputs.
    779            * @param  NewState: The new state of the TIM5 peripheral.
    780            *          This parameter can be ENABLE or DISABLE
    781            * @retval None
    782            */

   \                                 In section .far_func.text, align 1
    783          void TIM5_CtrlPWMOutputs(FunctionalState NewState)
    784          {
    785            /* Check the parameters */
    786            assert_param(IS_FUNCTIONAL_STATE(NewState));
    787          
    788            /* Set or Reset the MOE Bit */
    789          
    790            if (NewState != DISABLE)
   \                     TIM5_CtrlPWMOutputs:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM5_CtrlPWMOutputs_0
    791            {
    792              TIM5->BKR |= TIM_BKR_MOE ;
   \   000003 721E 5315    BSET      L:0x5315, #0x7
   \   000007 87           RETF
    793            }
    794            else
    795            {
    796              TIM5->BKR &= (uint8_t)(~TIM_BKR_MOE) ;
   \                     ??TIM5_CtrlPWMOutputs_0:
   \   000008 721F 5315    BRES      L:0x5315, #0x7
    797            }
    798          }
   \   00000C 87           RETF
    799          
    800          /**
    801            * @brief  Selects the TIM5 Output Compare Mode. This function disables the
    802            *         selected channel before changing the Output Compare Mode. User has to
    803            *         enable this channel using TIM5_CCxCmd and TIM5_CCxNCmd functions.
    804            * @param  TIM5_Channel: Specifies the TIM5 Channel.
    805            *          This parameter can be one of the following values:
    806            *            @arg TIM5_Channel_1: Channel 1
    807            *            @arg TIM5_Channel_2: Channel 2  
    808            * @param  TIM5_OCMode: Specifies the TIM5 Output Compare Mode.
    809            *          This parameter can be one of the following values:
    810            *            @arg TIM5_OCMode_Timing: Timing (Frozen) Mode
    811            *            @arg TIM5_OCMode_Active: Active Mode
    812            *            @arg TIM5_OCMode_Inactive: Inactive Mode
    813            *            @arg TIM5_OCMode_Toggle: Toggle Mode
    814            *            @arg TIM5_OCMode_PWM1: PWM Mode 1
    815            *            @arg TIM5_OCMode_PWM2: PWM Mode 2    
    816            * @retval None
    817            */

   \                                 In section .far_func.text, align 1
    818          void TIM5_SelectOCxM(TIM5_Channel_TypeDef TIM5_Channel,
    819                               TIM5_OCMode_TypeDef TIM5_OCMode)
    820          {
    821            /* Check the parameters */
    822            assert_param(IS_TIM5_CHANNEL(TIM5_Channel));
    823            assert_param(IS_TIM5_OCM(TIM5_OCMode));
    824          
    825            if (TIM5_Channel == TIM5_Channel_1)
   \                     TIM5_SelectOCxM:
   \   000000 4D           TNZ       A
   \   000001 26 15        JRNE      L:??TIM5_SelectOCxM_0
    826            {
    827              /* Disable the Channel 1: Reset the CCE Bit */
    828              TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC1E);
   \   000003 7211 530B    BRES      L:0x530b, #0x0
    829          
    830              /* Reset the Output Compare Bits */
    831              TIM5->CCMR1 &= (uint8_t)(~TIM_CCMR_OCM);
   \   000007 C6 5309      LD        A, L:0x5309
   \   00000A A4 8F        AND       A, #0x8f
   \   00000C C7 5309      LD        L:0x5309, A
    832          
    833              /* Set the Output Compare Mode */
    834              TIM5->CCMR1 |= (uint8_t)TIM5_OCMode;
   \   00000F B6 ..        LD        A, S:?b0
   \   000011 CA 5309      OR        A, L:0x5309
   \   000014 C7 5309      LD        L:0x5309, A
   \   000017 87           RETF
    835            }
    836            else /* if (TIM5_Channel == TIM5_Channel_2) */
    837            {
    838              /* Disable the Channel 2: Reset the CCE Bit */
    839              TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC2E);
   \                     ??TIM5_SelectOCxM_0:
   \   000018 7219 530B    BRES      L:0x530b, #0x4
    840          
    841              /* Reset the Output Compare Bits */
    842              TIM5->CCMR2 &= (uint8_t)(~TIM_CCMR_OCM);
   \   00001C C6 530A      LD        A, L:0x530a
   \   00001F A4 8F        AND       A, #0x8f
   \   000021 C7 530A      LD        L:0x530a, A
    843          
    844              /* Set the Output Compare Mode */
    845              TIM5->CCMR2 |= (uint8_t)TIM5_OCMode;
   \   000024 B6 ..        LD        A, S:?b0
   \   000026 CA 530A      OR        A, L:0x530a
   \   000029 C7 530A      LD        L:0x530a, A
    846            }
    847          }
   \   00002C 87           RETF
    848          
    849          /**
    850            * @brief  Sets the TIM5 Capture Compare1 Register value.
    851            * @param  Compare: Specifies the Capture Compare1 register new value.
    852            *         This parameter is between 0x0000 and 0xFFFF.
    853            * @retval None
    854            */

   \                                 In section .far_func.text, align 1
    855          void TIM5_SetCompare1(uint16_t Compare)
    856          {
   \                     TIM5_SetCompare1:
   \   000000 9093         LDW       Y, X
    857            /* Set the Capture Compare1 Register value */
    858            TIM5->CCR1H = (uint8_t)(Compare >> 8);
   \   000002 93           LDW       X, Y
   \   000003 4F           CLR       A
   \   000004 01           RRWA      X, A
   \   000005 9F           LD        A, XL
   \   000006 C7 5311      LD        L:0x5311, A
    859            TIM5->CCR1L = (uint8_t)(Compare);
   \   000009 909F         LD        A, YL
   \   00000B C7 5312      LD        L:0x5312, A
    860          }
   \   00000E 87           RETF
    861          
    862          /**
    863            * @brief  Sets the TIM5 Capture Compare2 Register value.
    864            * @param  Compare: Specifies the Capture Compare2 register new value.
    865            *         This parameter is between 0x0000 and 0xFFFF.
    866            * @retval None
    867            */

   \                                 In section .far_func.text, align 1
    868          void TIM5_SetCompare2(uint16_t Compare)
    869          {
   \                     TIM5_SetCompare2:
   \   000000 9093         LDW       Y, X
    870            /* Set the Capture Compare2 Register value */
    871            TIM5->CCR2H = (uint8_t)(Compare >> 8);
   \   000002 93           LDW       X, Y
   \   000003 4F           CLR       A
   \   000004 01           RRWA      X, A
   \   000005 9F           LD        A, XL
   \   000006 C7 5313      LD        L:0x5313, A
    872            TIM5->CCR2L = (uint8_t)(Compare);
   \   000009 909F         LD        A, YL
   \   00000B C7 5314      LD        L:0x5314, A
    873          }
   \   00000E 87           RETF
    874          
    875          /**
    876            * @brief  Forces the TIM5 Channel1 output waveform to active or inactive level.
    877            * @param  TIM5_ForcedAction: Specifies the forced Action to be set to the output waveform.
    878            *          This parameter can be one of the following values:
    879            *            @arg TIM5_ForcedAction_Active: Output Reference is forced low 
    880            *            @arg TIM5_ForcedAction_Inactive: Output Reference is forced high 
    881            * @retval None
    882            */

   \                                 In section .far_func.text, align 1
    883          void TIM5_ForcedOC1Config(TIM5_ForcedAction_TypeDef TIM5_ForcedAction)
    884          {
   \                     TIM5_ForcedOC1Config:
   \   000000 B7 ..        LD        S:?b0, A
    885            uint8_t tmpccmr1 = 0;
   \   000002 3F ..        CLR       S:?b1
    886          
    887            /* Check the parameters */
    888            assert_param(IS_TIM5_FORCED_ACTION(TIM5_ForcedAction));
    889          
    890            tmpccmr1 = TIM5->CCMR1;
   \   000004 C6 5309      LD        A, L:0x5309
   \   000007 B7 ..        LD        S:?b1, A
    891          
    892            /* Reset the OCM Bits */
    893            tmpccmr1 &= (uint8_t)(~TIM_CCMR_OCM);
   \   000009 B6 ..        LD        A, S:?b1
   \   00000B A4 8F        AND       A, #0x8f
   \   00000D B7 ..        LD        S:?b1, A
    894          
    895            /* Configure The Forced output Mode */
    896            tmpccmr1 |= (uint8_t)TIM5_ForcedAction;
   \   00000F B6 ..        LD        A, S:?b0
   \   000011 BA ..        OR        A, S:?b1
   \   000013 B7 ..        LD        S:?b1, A
    897          
    898            TIM5->CCMR1 = tmpccmr1;
   \   000015 B6 ..        LD        A, S:?b1
   \   000017 C7 5309      LD        L:0x5309, A
    899          }
   \   00001A 87           RETF
    900          
    901          /**
    902            * @brief  Forces the TIM5 Channel2 output waveform to active or inactive level.
    903            * @param  TIM5_ForcedAction: Specifies the forced Action to be set to the output waveform.
    904            *          This parameter can be one of the following values:
    905            *            @arg TIM5_ForcedAction_Active: Output Reference is forced low 
    906            *            @arg TIM5_ForcedAction_Inactive: Output Reference is forced high 
    907            * @retval None
    908            */

   \                                 In section .far_func.text, align 1
    909          void TIM5_ForcedOC2Config(TIM5_ForcedAction_TypeDef TIM5_ForcedAction)
    910          {
   \                     TIM5_ForcedOC2Config:
   \   000000 B7 ..        LD        S:?b0, A
    911            uint8_t tmpccmr2 = 0;
   \   000002 3F ..        CLR       S:?b1
    912          
    913            /* Check the parameters */
    914            assert_param(IS_TIM5_FORCED_ACTION(TIM5_ForcedAction));
    915          
    916            tmpccmr2 = TIM5->CCMR2;
   \   000004 C6 530A      LD        A, L:0x530a
   \   000007 B7 ..        LD        S:?b1, A
    917          
    918            /* Reset the OCM Bits */
    919            tmpccmr2 &= (uint8_t)(~TIM_CCMR_OCM);
   \   000009 B6 ..        LD        A, S:?b1
   \   00000B A4 8F        AND       A, #0x8f
   \   00000D B7 ..        LD        S:?b1, A
    920          
    921            /* Configure The Forced output Mode */
    922            tmpccmr2 |= (uint8_t)TIM5_ForcedAction;
   \   00000F B6 ..        LD        A, S:?b0
   \   000011 BA ..        OR        A, S:?b1
   \   000013 B7 ..        LD        S:?b1, A
    923          
    924            TIM5->CCMR2 = tmpccmr2;
   \   000015 B6 ..        LD        A, S:?b1
   \   000017 C7 530A      LD        L:0x530a, A
    925          }
   \   00001A 87           RETF
    926          
    927          /**
    928            * @brief  Enables or disables the TIM5 peripheral Preload Register on CCR1.
    929            * @param  NewState: The new state of the Capture Compare Preload register.
    930            *          This parameter can be ENABLE or DISABLE
    931            * @retval None
    932            */

   \                                 In section .far_func.text, align 1
    933          void TIM5_OC1PreloadConfig(FunctionalState NewState)
    934          {
    935            /* Check the parameters */
    936            assert_param(IS_FUNCTIONAL_STATE(NewState));
    937          
    938            /* Set or Reset the OC1PE Bit */
    939            if (NewState != DISABLE)
   \                     TIM5_OC1PreloadConfig:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM5_OC1PreloadConfig_0
    940            {
    941              TIM5->CCMR1 |= TIM_CCMR_OCxPE ;
   \   000003 7216 5309    BSET      L:0x5309, #0x3
   \   000007 87           RETF
    942            }
    943            else
    944            {
    945              TIM5->CCMR1 &= (uint8_t)(~TIM_CCMR_OCxPE) ;
   \                     ??TIM5_OC1PreloadConfig_0:
   \   000008 7217 5309    BRES      L:0x5309, #0x3
    946            }
    947          }
   \   00000C 87           RETF
    948          
    949          /**
    950            * @brief  Enables or disables the TIM5 peripheral Preload Register on CCR2.
    951            * @param  NewState: The new state of the Capture Compare Preload register.
    952            *          This parameter can be ENABLE or DISABLE
    953            * @retval None
    954            */

   \                                 In section .far_func.text, align 1
    955          void TIM5_OC2PreloadConfig(FunctionalState NewState)
    956          {
    957            /* Check the parameters */
    958            assert_param(IS_FUNCTIONAL_STATE(NewState));
    959          
    960            /* Set or Reset the OC2PE Bit */
    961            if (NewState != DISABLE)
   \                     TIM5_OC2PreloadConfig:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM5_OC2PreloadConfig_0
    962            {
    963              TIM5->CCMR2 |= TIM_CCMR_OCxPE ;
   \   000003 7216 530A    BSET      L:0x530a, #0x3
   \   000007 87           RETF
    964            }
    965            else
    966            {
    967              TIM5->CCMR2 &= (uint8_t)(~TIM_CCMR_OCxPE) ;
   \                     ??TIM5_OC2PreloadConfig_0:
   \   000008 7217 530A    BRES      L:0x530a, #0x3
    968            }
    969          }
   \   00000C 87           RETF
    970          
    971          /**
    972            * @brief  Configures the TIM5 Capture Compare 1 Fast feature.
    973            * @param  NewState: The new state of the Output Compare Fast Enable bit.
    974            *          This parameter can be ENABLE or DISABLE
    975            * @retval None
    976            */

   \                                 In section .far_func.text, align 1
    977          void TIM5_OC1FastConfig(FunctionalState NewState)
    978          {
    979            /* Check the parameters */
    980            assert_param(IS_FUNCTIONAL_STATE(NewState));
    981          
    982            /* Set or Reset the OC1FE Bit */
    983            if (NewState != DISABLE)
   \                     TIM5_OC1FastConfig:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM5_OC1FastConfig_0
    984            {
    985              TIM5->CCMR1 |= TIM_CCMR_OCxFE ;
   \   000003 7214 5309    BSET      L:0x5309, #0x2
   \   000007 87           RETF
    986            }
    987            else
    988            {
    989              TIM5->CCMR1 &= (uint8_t)(~TIM_CCMR_OCxFE) ;
   \                     ??TIM5_OC1FastConfig_0:
   \   000008 7215 5309    BRES      L:0x5309, #0x2
    990            }
    991          }
   \   00000C 87           RETF
    992          
    993          /**
    994            * @brief  Configures the TIM5 Capture Compare 2 Fast feature.
    995            * @param  NewState: The new state of the Output Compare Fast Enable bit.
    996            *          This parameter can be ENABLE or DISABLE
    997            * @retval None
    998            */
    999          

   \                                 In section .far_func.text, align 1
   1000          void TIM5_OC2FastConfig(FunctionalState NewState)
   1001          {
   1002            /* Check the parameters */
   1003            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1004          
   1005            /* Set or Reset the OC2FE Bit */
   1006            if (NewState != DISABLE)
   \                     TIM5_OC2FastConfig:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM5_OC2FastConfig_0
   1007            {
   1008              TIM5->CCMR2 |= TIM_CCMR_OCxFE ;
   \   000003 7214 530A    BSET      L:0x530a, #0x2
   \   000007 87           RETF
   1009            }
   1010            else
   1011            {
   1012              TIM5->CCMR2 &= (uint8_t)(~TIM_CCMR_OCxFE) ;
   \                     ??TIM5_OC2FastConfig_0:
   \   000008 7215 530A    BRES      L:0x530a, #0x2
   1013            }
   1014          }
   \   00000C 87           RETF
   1015          
   1016          /**
   1017            * @brief  Configures the TIM5 Channel 1 polarity.
   1018            * @param  TIM5_OCPolarity: Specifies the OC1 Polarity.
   1019            *          This parameter can be one of the following values:
   1020            *            @arg TIM5_OCPolarity_High: Output compare polarity  = High
   1021            *            @arg TIM5_OCPolarity_Low: Output compare polarity  = Low 
   1022            * @retval None
   1023            */

   \                                 In section .far_func.text, align 1
   1024          void TIM5_OC1PolarityConfig(TIM5_OCPolarity_TypeDef TIM5_OCPolarity)
   1025          {
   1026            /* Check the parameters */
   1027            assert_param(IS_TIM5_OC_POLARITY(TIM5_OCPolarity));
   1028          
   1029            /* Set or Reset the CC1P Bit */
   1030            if (TIM5_OCPolarity == TIM5_OCPolarity_Low)
   \                     TIM5_OC1PolarityConfig:
   \   000000 A1 01        CP        A, #0x1
   \   000002 26 05        JRNE      L:??TIM5_OC1PolarityConfig_0
   1031            {
   1032              TIM5->CCER1 |= TIM_CCER1_CC1P ;
   \   000004 7212 530B    BSET      L:0x530b, #0x1
   \   000008 87           RETF
   1033            }
   1034            else
   1035            {
   1036              TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC1P) ;
   \                     ??TIM5_OC1PolarityConfig_0:
   \   000009 7213 530B    BRES      L:0x530b, #0x1
   1037            }
   1038          }
   \   00000D 87           RETF
   1039          
   1040          /**
   1041            * @brief  Configures the TIM5 Channel 2 polarity.
   1042            * @param  TIM5_OCPolarity: Specifies the OC2 Polarity.
   1043            *          This parameter can be one of the following values:
   1044            *            @arg TIM5_OCPolarity_High: Output compare polarity  = High
   1045            *            @arg TIM5_OCPolarity_Low: Output compare polarity  = Low 
   1046            * @retval None
   1047            */

   \                                 In section .far_func.text, align 1
   1048          void TIM5_OC2PolarityConfig(TIM5_OCPolarity_TypeDef TIM5_OCPolarity)
   1049          {
   1050            /* Check the parameters */
   1051            assert_param(IS_TIM5_OC_POLARITY(TIM5_OCPolarity));
   1052          
   1053            /* Set or Reset the CC2P Bit */
   1054            if (TIM5_OCPolarity == TIM5_OCPolarity_Low)
   \                     TIM5_OC2PolarityConfig:
   \   000000 A1 01        CP        A, #0x1
   \   000002 26 05        JRNE      L:??TIM5_OC2PolarityConfig_0
   1055            {
   1056              TIM5->CCER1 |= TIM_CCER1_CC2P ;
   \   000004 721A 530B    BSET      L:0x530b, #0x5
   \   000008 87           RETF
   1057            }
   1058            else
   1059            {
   1060              TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC2P) ;
   \                     ??TIM5_OC2PolarityConfig_0:
   \   000009 721B 530B    BRES      L:0x530b, #0x5
   1061            }
   1062          }
   \   00000D 87           RETF
   1063          
   1064          /**
   1065            * @brief  Enables or disables the TIM5 Capture Compare Channel x.
   1066            * @param  TIM5_Channel: Specifies the TIM5 Channel.
   1067            *          This parameter can be one of the following values:
   1068            *            @arg TIM5_Channel_1: Channel 1
   1069            *            @arg TIM5_Channel_2: Channel 2  
   1070            * @param  NewState: Specifies the TIM5 Channel CCxE bit new state.
   1071            *          This parameter can be ENABLE or DISABLE
   1072            * @retval None
   1073            */

   \                                 In section .far_func.text, align 1
   1074          void TIM5_CCxCmd(TIM5_Channel_TypeDef TIM5_Channel,
   1075                           FunctionalState NewState)
   1076          {
   1077            /* Check the parameters */
   1078            assert_param(IS_TIM5_CHANNEL(TIM5_Channel));
   1079            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1080          
   1081            if (TIM5_Channel == TIM5_Channel_1)
   \                     TIM5_CCxCmd:
   \   000000 4D           TNZ       A
   \   000001 26 0E        JRNE      L:??TIM5_CCxCmd_0
   1082            {
   1083              /* Set or Reset the CC1E Bit */
   1084              if (NewState != DISABLE)
   \   000003 3D ..        TNZ       S:?b0
   \   000005 27 05        JREQ      L:??TIM5_CCxCmd_1
   1085              {
   1086                TIM5->CCER1 |= TIM_CCER1_CC1E ;
   \   000007 7210 530B    BSET      L:0x530b, #0x0
   \   00000B 87           RETF
   1087              }
   1088              else
   1089              {
   1090                TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC1E) ;
   \                     ??TIM5_CCxCmd_1:
   \   00000C 7211 530B    BRES      L:0x530b, #0x0
   \   000010 87           RETF
   1091              }
   1092          
   1093            }
   1094            else /* if (TIM5_Channel == TIM5_Channel_2) */
   1095            {
   1096              /* Set or Reset the CC2E Bit */
   1097              if (NewState != DISABLE)
   \                     ??TIM5_CCxCmd_0:
   \   000011 3D ..        TNZ       S:?b0
   \   000013 27 05        JREQ      L:??TIM5_CCxCmd_2
   1098              {
   1099                TIM5->CCER1 |= TIM_CCER1_CC2E;
   \   000015 7218 530B    BSET      L:0x530b, #0x4
   \   000019 87           RETF
   1100              }
   1101              else
   1102              {
   1103                TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC2E) ;
   \                     ??TIM5_CCxCmd_2:
   \   00001A 7219 530B    BRES      L:0x530b, #0x4
   1104              }
   1105            }
   1106          }
   \   00001E 87           RETF
   1107          
   1108          /** @defgroup TIM5_Group3 Input Capture management functions
   1109           *  @brief    Input Capture management functions 
   1110           *
   1111          @verbatim   
   1112           ===============================================================================
   1113                                Input Capture management functions
   1114           ===============================================================================  
   1115             
   1116                 ===================================================================      
   1117                        TIM5 Driver: how to use it in Input Capture Mode
   1118                 =================================================================== 
   1119                 To use the Timer in Input Capture mode, the following steps are mandatory:
   1120                 
   1121                 1. Enable TIM5 clock using CLK_PeripheralClockConfig(CLK_Peripheral_TIM5, ENABLE) function.
   1122                 
   1123                 2. Configure the TIM5 pins in input mode by configuring the corresponding GPIO pins
   1124                 
   1125                 3. Configure the Time base unit as described in the first part of this driver, if needed,
   1126                    otherwise the Timer will run with the default configuration:
   1127                    - Autoreload value = 0xFFFF
   1128                    - Prescaler value = 0x0
   1129                    - Counter mode = Up counting
   1130                 
   1131                 4. Call TIM5_ICInit() to configure the desired channel to measure only 
   1132                    frequency or duty cycle of the input signal using the corresponding configuration: 
   1133                    - TIM5 Channel: TIM5_Channel
   1134                    - TIM5 Input Capture polarity: TIM5_ICPolarity
   1135                    - TIM5 Input Capture selection: TIM5_ICSelection
   1136                    - TIM5 Input Capture Prescaler: TIM5_ICPSC
   1137                    - TIM5 Input Capture filter value
   1138                    or,
   1139                    Call TIM5_PWMIConfig() to configure the desired channels with the 
   1140                    corresponding configuration and to measure the frequency and the duty
   1141                    cycle of the input signal.
   1142                    
   1143                 5. Enable global interrupts or the DMA to read the measured frequency. 
   1144                    
   1145                 6. Enable the corresponding interrupt (or DMA request) to read the captured value,
   1146                    using the function TIM5_ITConfig(TIM5_IT_CCx) (or TIM5_DMACmd(TIM5_DMASource_CCx))
   1147                 
   1148                 7. Call the TIM5_Cmd(ENABLE) function to enable the TIM5 counter.
   1149                 
   1150                 8. Use TIM5_GetCapturex() to read the captured value corresponding to
   1151                    channel x.
   1152                 
   1153                 Note1: All other functions can be used separately to modify, if needed,
   1154                    a specific feature of the Timer. 
   1155          
   1156          @endverbatim
   1157            * @{
   1158            */
   1159          
   1160          /**
   1161            * @brief  Initializes the TIM5 peripheral according to the specified parameters.
   1162            * @param  TIM5_Channel: TIM5 Channel
   1163            *          This parameter can be one of the following values:
   1164            *            @arg TIM5_Channel_1: Channel 1
   1165            *            @arg TIM5_Channel_2: Channel 2     
   1166            * @param  TIM5_ICPolarity: Input Capture Polarity
   1167            *          This parameter can be one of the following values:
   1168            *            @arg TIM5_ICPolarity_Rising: Input Capture on Rising Edge
   1169            *            @arg TIM5_ICPolarity_Falling: Input Capture on Falling Edge  
   1170            * @param  TIM5_ICSelection: Input Capture Selection
   1171            *          This parameter can be one of the following values:
   1172            *            @arg TIM5_ICSelection_DirectTI: Input Capture mapped on the direct input
   1173            *            @arg TIM5_ICSelection_IndirectTI: Input Capture mapped on the indirect input
   1174            *            @arg TIM5_ICSelection_TRGI: Input Capture mapped on the Trigger Input   
   1175            * @param  TIM5_ICPrescaler: Input Capture Prescaler
   1176            *          This parameter can be one of the following values:
   1177            *            @arg TIM5_ICPSC_DIV1: Input Capture Prescaler = 1 (one capture every 1 event)
   1178            *            @arg TIM5_ICPSC_DIV2: Input Capture Prescaler = 2 (one capture every 2 events)
   1179            *            @arg TIM5_ICPSC_DIV4: Input Capture Prescaler = 4 (one capture every 4 events)
   1180            *            @arg TIM5_ICPSC_DIV8: Input Capture Prescaler = 8 (one capture every 8 events)   
   1181            * @param  TIM5_ICFilter: This parameter must be a value between 0x00 and 0x0F.
   1182            * @retval None
   1183            */

   \                                 In section .far_func.text, align 1
   1184          void TIM5_ICInit(TIM5_Channel_TypeDef TIM5_Channel,
   1185                           TIM5_ICPolarity_TypeDef TIM5_ICPolarity,
   1186                           TIM5_ICSelection_TypeDef TIM5_ICSelection,
   1187                           TIM5_ICPSC_TypeDef TIM5_ICPrescaler,
   1188                           uint8_t TIM5_ICFilter)
   1189          {
   \                     TIM5_ICInit:
   \   000000 45 .. ..     MOV       S:?b4, S:?b0
   \   000003 45 .. ..     MOV       S:?b0, S:?b1
   \   000006 45 .. ..     MOV       S:?b5, S:?b2
   \   000009 45 .. ..     MOV       S:?b1, S:?b3
   1190            /* Check the parameters */
   1191            assert_param(IS_TIM5_CHANNEL(TIM5_Channel));
   1192          
   1193            if (TIM5_Channel == TIM5_Channel_1)
   \   00000C 4D           TNZ       A
   \   00000D 26 0C        JRNE      L:??TIM5_ICInit_0
   1194            {
   1195              /* TI1 Configuration */
   1196              TI1_Config(TIM5_ICPolarity, TIM5_ICSelection, TIM5_ICFilter);
   \   00000F B6 ..        LD        A, S:?b4
   \   000011 8D ......    CALLF     TI1_Config
   1197          
   1198              /* Set the Input Capture Prescaler value */
   1199              TIM5_SetIC1Prescaler(TIM5_ICPrescaler);
   \   000015 B6 ..        LD        A, S:?b5
   \   000017 AC ......    JPF       TIM5_SetIC1Prescaler
   1200            }
   1201            else /* if (TIM5_Channel == TIM5_Channel_2) */
   1202            {
   1203              /* TI2 Configuration */
   1204              TI2_Config(TIM5_ICPolarity, TIM5_ICSelection, TIM5_ICFilter);
   \                     ??TIM5_ICInit_0:
   \   00001B B6 ..        LD        A, S:?b4
   \   00001D 8D ......    CALLF     TI2_Config
   1205          
   1206              /* Set the Input Capture Prescaler value */
   1207              TIM5_SetIC2Prescaler(TIM5_ICPrescaler);
   \   000021 B6 ..        LD        A, S:?b5
   \   000023 AC ......    JPF       TIM5_SetIC2Prescaler
   1208            }
   1209          }
   1210          
   1211          /**
   1212            * @brief  Configures the TIM5 peripheral in PWM Input Mode according to the
   1213            *         specified parameters.
   1214            * @param  TIM5_Channel: TIM5 Channel
   1215            *          This parameter can be one of the following values:
   1216            *            @arg TIM5_Channel_1: Channel 1
   1217            *            @arg TIM5_Channel_2: Channel 2     
   1218            * @param  TIM5_ICPolarity: Input Capture Polarity
   1219            *          This parameter can be one of the following values:
   1220            *            @arg TIM5_ICPolarity_Rising: Input Capture on Rising Edge
   1221            *            @arg TIM5_ICPolarity_Falling: Input Capture on Falling Edge  
   1222            * @param  TIM5_ICSelection: Input Capture Selection
   1223            *          This parameter can be one of the following values:
   1224            *            @arg TIM5_ICSelection_DirectTI: Input Capture mapped on the direct input
   1225            *            @arg TIM5_ICSelection_IndirectTI: Input Capture mapped on the indirect input
   1226            *            @arg TIM5_ICSelection_TRGI: Input Capture mapped on the Trigger Input   
   1227            * @param  TIM5_ICPrescaler: Input Capture Prescaler
   1228            *          This parameter can be one of the following values:
   1229            *            @arg TIM5_ICPSC_DIV1: Input Capture Prescaler = 1 (one capture every 1 event)
   1230            *            @arg TIM5_ICPSC_DIV2: Input Capture Prescaler = 2 (one capture every 2 events)
   1231            *            @arg TIM5_ICPSC_DIV4: Input Capture Prescaler = 4 (one capture every 4 events)
   1232            *            @arg TIM5_ICPSC_DIV8: Input Capture Prescaler = 8 (one capture every 8 events) 
   1233            * @retval None
   1234            */

   \                                 In section .far_func.text, align 1, keep-with-next
   1235          void TIM5_PWMIConfig(TIM5_Channel_TypeDef TIM5_Channel,
   1236                               TIM5_ICPolarity_TypeDef TIM5_ICPolarity,
   1237                               TIM5_ICSelection_TypeDef TIM5_ICSelection,
   1238                               TIM5_ICPSC_TypeDef TIM5_ICPrescaler,
   1239                               uint8_t TIM5_ICFilter)
   1240          {
   \                     TIM5_PWMIConfig:
   \   000000 8D ......    CALLF     L:?push_w4
   \   000004 B7 ..        LD        S:?b6, A
   \   000006 45 .. ..     MOV       S:?b7, S:?b0
   \   000009 B6 ..        LD        A, S:?b1
   \   00000B 45 .. ..     MOV       S:?b8, S:?b2
   \   00000E 45 .. ..     MOV       S:?b9, S:?b3
   1241            uint8_t icpolarity = TIM5_ICPolarity_Rising;
   \   000011 3F ..        CLR       S:?b5
   1242            uint8_t icselection = TIM5_ICSelection_DirectTI;
   \   000013 35 01 ....   MOV       S:?b4, #0x1
   1243          
   1244            /* Check the parameters */
   1245            assert_param(IS_TIM5_CHANNEL(TIM5_Channel));
   1246          
   1247            /* Select the Opposite Input Polarity */
   1248            if (TIM5_ICPolarity == TIM5_ICPolarity_Rising)
   \   000017 3D ..        TNZ       S:?b7
   \   000019 26 06        JRNE      L:??TIM5_PWMIConfig_0
   1249            {
   1250              icpolarity = TIM5_ICPolarity_Falling;
   \   00001B 35 01 ....   MOV       S:?b5, #0x1
   \   00001F 20 02        JRA       L:??TIM5_PWMIConfig_1
   1251            }
   1252            else
   1253            {
   1254              icpolarity = TIM5_ICPolarity_Rising;
   \                     ??TIM5_PWMIConfig_0:
   \   000021 3F ..        CLR       S:?b5
   1255            }
   1256          
   1257            /* Select the Opposite Input */
   1258            if (TIM5_ICSelection == TIM5_ICSelection_DirectTI)
   \                     ??TIM5_PWMIConfig_1:
   \   000023 A1 01        CP        A, #0x1
   \   000025 26 06        JRNE      L:??TIM5_PWMIConfig_2
   1259            {
   1260              icselection = TIM5_ICSelection_IndirectTI;
   \   000027 35 02 ....   MOV       S:?b4, #0x2
   \   00002B 20 04        JRA       L:??TIM5_PWMIConfig_3
   1261            }
   1262            else
   1263            {
   1264              icselection = TIM5_ICSelection_DirectTI;
   \                     ??TIM5_PWMIConfig_2:
   \   00002D 35 01 ....   MOV       S:?b4, #0x1
   1265            }
   1266          
   1267            if (TIM5_Channel == TIM5_Channel_1)
   \                     ??TIM5_PWMIConfig_3:
   \   000031 3D ..        TNZ       S:?b6
   \   000033 26 27        JRNE      L:??TIM5_PWMIConfig_4
   1268            {
   1269              /* TI1 Configuration */
   1270              TI1_Config(TIM5_ICPolarity, TIM5_ICSelection,
   1271                         TIM5_ICFilter);
   \   000035 45 .. ..     MOV       S:?b1, S:?b9
   \   000038 B7 ..        LD        S:?b0, A
   \   00003A B6 ..        LD        A, S:?b7
   \   00003C 8D ......    CALLF     TI1_Config
   1272          
   1273              /* Set the Input Capture Prescaler value */
   1274              TIM5_SetIC1Prescaler(TIM5_ICPrescaler);
   \   000040 B6 ..        LD        A, S:?b8
   \   000042 8D ......    CALLF     TIM5_SetIC1Prescaler
   1275          
   1276              /* TI2 Configuration */
   1277              TI2_Config((TIM5_ICPolarity_TypeDef)icpolarity, (TIM5_ICSelection_TypeDef)icselection, TIM5_ICFilter);
   \   000046 45 .. ..     MOV       S:?b1, S:?b9
   \   000049 45 .. ..     MOV       S:?b0, S:?b4
   \   00004C B6 ..        LD        A, S:?b5
   \   00004E 8D ......    CALLF     TI2_Config
   1278          
   1279              /* Set the Input Capture Prescaler value */
   1280              TIM5_SetIC2Prescaler(TIM5_ICPrescaler);
   \   000052 B6 ..        LD        A, S:?b8
   \   000054 8D ......    CALLF     TIM5_SetIC2Prescaler
   \   000058 AC ......    JPF       L:?epilogue_w4
   1281            }
   1282            else
   1283            {
   1284              /* TI2 Configuration */
   1285              TI2_Config(TIM5_ICPolarity, TIM5_ICSelection,
   1286                         TIM5_ICFilter);
   \                     ??TIM5_PWMIConfig_4:
   \   00005C 45 .. ..     MOV       S:?b1, S:?b9
   \   00005F B7 ..        LD        S:?b0, A
   \   000061 B6 ..        LD        A, S:?b7
   \   000063 8D ......    CALLF     TI2_Config
   1287          
   1288              /* Set the Input Capture Prescaler value */
   1289              TIM5_SetIC2Prescaler(TIM5_ICPrescaler);
   \   000067 B6 ..        LD        A, S:?b8
   \   000069 8D ......    CALLF     TIM5_SetIC2Prescaler
   1290          
   1291              /* TI1 Configuration */
   1292              TI1_Config((TIM5_ICPolarity_TypeDef)icpolarity, (TIM5_ICSelection_TypeDef)icselection, TIM5_ICFilter);
   \   00006D 45 .. ..     MOV       S:?b1, S:?b9
   \   000070 45 .. ..     MOV       S:?b0, S:?b4
   \   000073 B6 ..        LD        A, S:?b5
   \   000075 8D ......    CALLF     TI1_Config
   1293          
   1294              /* Set the Input Capture Prescaler value */
   1295              TIM5_SetIC1Prescaler(TIM5_ICPrescaler);
   \   000079 B6 ..        LD        A, S:?b8
   \   00007B 8D ......    CALLF     TIM5_SetIC1Prescaler
   1296            }
   1297          }
   \   00007F AC ......    JPF       L:?epilogue_w4
   1298          
   1299          /**
   1300            * @brief  Gets the TIM5 Input Capture 1 value.
   1301            * @param  None
   1302            * @retval Capture Compare 1 Register value.
   1303            */

   \                                 In section .far_func.text, align 1, keep-with-next
   1304          uint16_t TIM5_GetCapture1(void)
   1305          {
   1306            uint16_t tmpccr1 = 0;
   \                     TIM5_GetCapture1:
   \   000000 905F         CLRW      Y
   1307            uint8_t tmpccr1l, tmpccr1h;
   1308          
   1309            tmpccr1h = TIM5->CCR1H;
   \   000002 C6 5311      LD        A, L:0x5311
   \   000005 B7 ..        LD        S:?b0, A
   1310            tmpccr1l = TIM5->CCR1L;
   \   000007 C6 5312      LD        A, L:0x5312
   1311          
   1312            tmpccr1 = (uint16_t)(tmpccr1l);
   \   00000A 5F           CLRW      X
   \   00000B 97           LD        XL, A
   \   00000C 9093         LDW       Y, X
   1313            tmpccr1 |= (uint16_t)((uint16_t)tmpccr1h << 8);
   \   00000E 5F           CLRW      X
   \   00000F 41           EXG       A, XL
   \   000010 B6 ..        LD        A, S:?b0
   \   000012 41           EXG       A, XL
   \   000013 4F           CLR       A
   \   000014 02           RLWA      X, A
   \   000015 BF ..        LDW       S:?w0, X
   \   000017 51           EXGW      X, Y
   \   000018 01           RRWA      X, A
   \   000019 BA ..        OR        A, S:?b1
   \   00001B 01           RRWA      X, A
   \   00001C BA ..        OR        A, S:?b0
   \   00001E 01           RRWA      X, A
   \   00001F 51           EXGW      X, Y
   1314            /* Get the Capture 1 Register value */
   1315            return ((uint16_t)tmpccr1);
   \   000020 93           LDW       X, Y
   \   000021 87           RETF
   1316          }
   1317          
   1318          /**
   1319            * @brief  Gets the TIM5 Input Capture 2 value.
   1320            * @param  None
   1321            * @retval Capture Compare 2 Register value.
   1322            */

   \                                 In section .far_func.text, align 1, keep-with-next
   1323          uint16_t TIM5_GetCapture2(void)
   1324          {
   1325            uint16_t tmpccr2 = 0;
   \                     TIM5_GetCapture2:
   \   000000 905F         CLRW      Y
   1326            uint8_t tmpccr2l, tmpccr2h;
   1327          
   1328            tmpccr2h = TIM5->CCR2H;
   \   000002 C6 5313      LD        A, L:0x5313
   \   000005 B7 ..        LD        S:?b0, A
   1329            tmpccr2l = TIM5->CCR2L;
   \   000007 C6 5314      LD        A, L:0x5314
   1330          
   1331            tmpccr2 = (uint16_t)(tmpccr2l);
   \   00000A 5F           CLRW      X
   \   00000B 97           LD        XL, A
   \   00000C 9093         LDW       Y, X
   1332            tmpccr2 |= (uint16_t)((uint16_t)tmpccr2h << 8);
   \   00000E 5F           CLRW      X
   \   00000F 41           EXG       A, XL
   \   000010 B6 ..        LD        A, S:?b0
   \   000012 41           EXG       A, XL
   \   000013 4F           CLR       A
   \   000014 02           RLWA      X, A
   \   000015 BF ..        LDW       S:?w0, X
   \   000017 51           EXGW      X, Y
   \   000018 01           RRWA      X, A
   \   000019 BA ..        OR        A, S:?b1
   \   00001B 01           RRWA      X, A
   \   00001C BA ..        OR        A, S:?b0
   \   00001E 01           RRWA      X, A
   \   00001F 51           EXGW      X, Y
   1333            /* Get the Capture 2 Register value */
   1334            return ((uint16_t)tmpccr2);
   \   000020 93           LDW       X, Y
   \   000021 87           RETF
   1335          }
   1336          
   1337          /**
   1338            * @brief  Sets the TIM5 Input Capture 1 prescaler.
   1339            * @param  TIM5_IC1Prescaler: Specifies the Input Capture prescaler new value
   1340            *          This parameter can be one of the following values:
   1341            *            @arg TIM5_ICPSC_DIV1: Input Capture Prescaler = 1 (one capture every 1 event)
   1342            *            @arg TIM5_ICPSC_DIV2: Input Capture Prescaler = 2 (one capture every 2 events)
   1343            *            @arg TIM5_ICPSC_DIV4: Input Capture Prescaler = 4 (one capture every 4 events)
   1344            *            @arg TIM5_ICPSC_DIV8: Input Capture Prescaler = 8 (one capture every 8 events) 
   1345            * @retval None
   1346            */

   \                                 In section .far_func.text, align 1, keep-with-next
   1347          void TIM5_SetIC1Prescaler(TIM5_ICPSC_TypeDef TIM5_IC1Prescaler)
   1348          {
   \                     TIM5_SetIC1Prescaler:
   \   000000 B7 ..        LD        S:?b0, A
   1349            uint8_t tmpccmr1 = 0;
   \   000002 3F ..        CLR       S:?b1
   1350          
   1351            /* Check the parameters */
   1352            assert_param(IS_TIM5_IC_PRESCALER(TIM5_IC1Prescaler));
   1353          
   1354            tmpccmr1 = TIM5->CCMR1;
   \   000004 C6 5309      LD        A, L:0x5309
   \   000007 B7 ..        LD        S:?b1, A
   1355          
   1356            /* Reset the IC1PSC Bits */
   1357            tmpccmr1 &= (uint8_t)(~TIM_CCMR_ICxPSC);
   \   000009 B6 ..        LD        A, S:?b1
   \   00000B A4 F3        AND       A, #0xf3
   \   00000D B7 ..        LD        S:?b1, A
   1358          
   1359            /* Set the IC1PSC value */
   1360            tmpccmr1 |= (uint8_t)TIM5_IC1Prescaler;
   \   00000F B6 ..        LD        A, S:?b0
   \   000011 BA ..        OR        A, S:?b1
   \   000013 B7 ..        LD        S:?b1, A
   1361          
   1362            TIM5->CCMR1 = tmpccmr1;
   \   000015 B6 ..        LD        A, S:?b1
   \   000017 C7 5309      LD        L:0x5309, A
   1363          }
   \   00001A 87           RETF
   1364          
   1365          /**
   1366            * @brief  Sets the TIM5 Input Capture 2 prescaler.
   1367            * @param  TIM5_IC2Prescaler: Specifies the Input Capture prescaler new value
   1368            *          This parameter can be one of the following values:
   1369            *            @arg TIM5_ICPSC_DIV1: Input Capture Prescaler = 1 (one capture every 1 event)
   1370            *            @arg TIM5_ICPSC_DIV2: Input Capture Prescaler = 2 (one capture every 2 events)
   1371            *            @arg TIM5_ICPSC_DIV4: Input Capture Prescaler = 4 (one capture every 4 events)
   1372            *            @arg TIM5_ICPSC_DIV8: Input Capture Prescaler = 8 (one capture every 8 events) 
   1373            * @retval None
   1374            */

   \                                 In section .far_func.text, align 1, keep-with-next
   1375          void TIM5_SetIC2Prescaler(TIM5_ICPSC_TypeDef TIM5_IC2Prescaler)
   1376          {
   \                     TIM5_SetIC2Prescaler:
   \   000000 B7 ..        LD        S:?b0, A
   1377            uint8_t tmpccmr2 = 0;
   \   000002 3F ..        CLR       S:?b1
   1378          
   1379            /* Check the parameters */
   1380            assert_param(IS_TIM5_IC_PRESCALER(TIM5_IC2Prescaler));
   1381          
   1382            tmpccmr2 = TIM5->CCMR2;
   \   000004 C6 530A      LD        A, L:0x530a
   \   000007 B7 ..        LD        S:?b1, A
   1383          
   1384            /* Reset the IC2PSC Bits */
   1385            tmpccmr2 &= (uint8_t)(~TIM_CCMR_ICxPSC);
   \   000009 B6 ..        LD        A, S:?b1
   \   00000B A4 F3        AND       A, #0xf3
   \   00000D B7 ..        LD        S:?b1, A
   1386          
   1387            /* Set the IC2PSC value */
   1388            tmpccmr2 |= (uint8_t)TIM5_IC2Prescaler;
   \   00000F B6 ..        LD        A, S:?b0
   \   000011 BA ..        OR        A, S:?b1
   \   000013 B7 ..        LD        S:?b1, A
   1389          
   1390            TIM5->CCMR2 = tmpccmr2;
   \   000015 B6 ..        LD        A, S:?b1
   \   000017 C7 530A      LD        L:0x530a, A
   1391          }
   \   00001A 87           RETF
   1392          
   1393          /**
   1394            * @}
   1395            */
   1396          
   1397          /** @defgroup TIM5_Group4 Interrupts DMA and flags management functions
   1398           *  @brief    Interrupts, DMA and flags management functions 
   1399           *
   1400          @verbatim   
   1401           ===============================================================================
   1402                           Interrupts, DMA and flags management functions
   1403           ===============================================================================  
   1404          
   1405          @endverbatim
   1406            * @{
   1407            */
   1408          
   1409          /**
   1410            * @brief  Enables or disables the specified TIM5 interrupts.
   1411            * @param  TIM5_IT: Specifies the TIM5 interrupts sources to be enabled or disabled.
   1412            *          This parameter can be any combination of the following values:
   1413            *            @arg TIM5_IT_Update: Update
   1414            *            @arg TIM5_IT_CC1: Capture Compare Channel1
   1415            *            @arg TIM5_IT_CC2: Capture Compare Channel2 
   1416            *            @arg TIM5_IT_Trigger: Trigger 
   1417            *            @arg TIM5_IT_Break: Break  
   1418            * @param  NewState: The new state of the TIM5 peripheral.
   1419            *          This parameter can be ENABLE or DISABLE
   1420            * @retval None
   1421            */

   \                                 In section .far_func.text, align 1
   1422          void TIM5_ITConfig(TIM5_IT_TypeDef TIM5_IT, FunctionalState NewState)
   1423          {
   1424            /* Check the parameters */
   1425            assert_param(IS_TIM5_IT(TIM5_IT));
   1426            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1427          
   1428            if (NewState != DISABLE)
   \                     TIM5_ITConfig:
   \   000000 3D ..        TNZ       S:?b0
   \   000002 27 07        JREQ      L:??TIM5_ITConfig_0
   1429            {
   1430              /* Enable the Interrupt sources */
   1431              TIM5->IER |= (uint8_t)TIM5_IT;
   \   000004 CA 5305      OR        A, L:0x5305
   \   000007 C7 5305      LD        L:0x5305, A
   \   00000A 87           RETF
   1432            }
   1433            else
   1434            {
   1435              /* Disable the Interrupt sources */
   1436              TIM5->IER &= (uint8_t)(~(uint8_t)TIM5_IT);
   \                     ??TIM5_ITConfig_0:
   \   00000B 43           CPL       A
   \   00000C C4 5305      AND       A, L:0x5305
   \   00000F C7 5305      LD        L:0x5305, A
   1437            }
   1438          }
   \   000012 87           RETF
   1439          
   1440          /**
   1441            * @brief  Configures the TIM5 event to be generated by software.
   1442            * @param  TIM5_EventSource: Specifies the event source.
   1443            *          This parameter can be any combination of the following values:
   1444            *            @arg TIM5_EventSource_Update: Update
   1445            *            @arg TIM5_EventSource_CC1: Capture Compare Channel1
   1446            *            @arg TIM5_EventSource_CC2: Capture Compare Channel2 
   1447            *            @arg TIM5_EventSource_Trigger: Trigger 
   1448            *            @arg TIM5_EventSource_Break: Break  
   1449            * @retval None
   1450            */

   \                                 In section .far_func.text, align 1
   1451          void TIM5_GenerateEvent(TIM5_EventSource_TypeDef TIM5_EventSource)
   1452          {
   1453            /* Check the parameters */
   1454            assert_param(IS_TIM5_EVENT_SOURCE((uint8_t)TIM5_EventSource));
   1455          
   1456            /* Set the event sources */
   1457            TIM5->EGR |= (uint8_t)TIM5_EventSource;
   \                     TIM5_GenerateEvent:
   \   000000 CA 5308      OR        A, L:0x5308
   \   000003 C7 5308      LD        L:0x5308, A
   1458          }
   \   000006 87           RETF
   1459          
   1460          /**
   1461            * @brief  Checks whether the specified TIM5 flag is set or not.
   1462            * @param  TIM5_FLAG: Specifies the flag to check.
   1463            *          This parameter can be any combination of the following values:
   1464            *            @arg TIM5_FLAG_Update: Update
   1465            *            @arg TIM5_FLAG_CC1: Capture Compare Channel1
   1466            *            @arg TIM5_FLAG_CC2: Capture Compare Channel2 
   1467            *            @arg TIM5_FLAG_Trigger: Trigger 
   1468            *            @arg TIM5_FLAG_Break: Break  
   1469            *            @arg TIM5_FLAG_CC1OF: Capture compare 1 over capture
   1470            *            @arg TIM5_FLAG_CC2OF: Capture compare 2 over capture   
   1471            * @retval FlagStatus: The new state of TIM5_FLAG (SET or RESET)
   1472            */

   \                                 In section .far_func.text, align 1
   1473          FlagStatus TIM5_GetFlagStatus(TIM5_FLAG_TypeDef TIM5_FLAG)
   1474          {
   1475            FlagStatus bitstatus = RESET;
   \                     TIM5_GetFlagStatus:
   \   000000 3F ..        CLR       S:?b0
   1476            uint8_t tim5_flag_l = 0, tim5_flag_h = 0;
   \   000002 3F ..        CLR       S:?b2
   \   000004 3F ..        CLR       S:?b1
   1477          
   1478            /* Check the parameters */
   1479            assert_param(IS_TIM5_GET_FLAG(TIM5_FLAG));
   1480          
   1481            tim5_flag_l = (uint8_t)(TIM5->SR1 & (uint8_t)(TIM5_FLAG));
   \   000006 9F           LD        A, XL
   \   000007 C4 5306      AND       A, L:0x5306
   \   00000A B7 ..        LD        S:?b2, A
   1482            tim5_flag_h = (uint8_t)(TIM5->SR2 & (uint8_t)((uint16_t)TIM5_FLAG >> 8));
   \   00000C 4F           CLR       A
   \   00000D 01           RRWA      X, A
   \   00000E 9F           LD        A, XL
   \   00000F C4 5307      AND       A, L:0x5307
   \   000012 B7 ..        LD        S:?b1, A
   1483          
   1484            if ((uint8_t)(tim5_flag_l | tim5_flag_h) != 0)
   \   000014 B6 ..        LD        A, S:?b1
   \   000016 BA ..        OR        A, S:?b2
   \   000018 A1 00        CP        A, #0x0
   \   00001A 27 06        JREQ      L:??TIM5_GetFlagStatus_0
   1485            {
   1486              bitstatus = SET;
   \   00001C 35 01 ....   MOV       S:?b0, #0x1
   \   000020 20 02        JRA       L:??TIM5_GetFlagStatus_1
   1487            }
   1488            else
   1489            {
   1490              bitstatus = RESET;
   \                     ??TIM5_GetFlagStatus_0:
   \   000022 3F ..        CLR       S:?b0
   1491            }
   1492            return ((FlagStatus)bitstatus);
   \                     ??TIM5_GetFlagStatus_1:
   \   000024 B6 ..        LD        A, S:?b0
   \   000026 87           RETF
   1493          }
   1494          
   1495          /**
   1496            * @brief  Clears the TIM’s pending flags.
   1497            * @param  TIM5_FLAG: Specifies the flag to clear.
   1498            *          This parameter can be any combination of the following values:
   1499            *            @arg TIM5_FLAG_Update: Update
   1500            *            @arg TIM5_FLAG_CC1: Capture Compare Channel1
   1501            *            @arg TIM5_FLAG_CC2: Capture Compare Channel2 
   1502            *            @arg TIM5_FLAG_Trigger: Trigger 
   1503            *            @arg TIM5_FLAG_Break: Break  
   1504            * @retval None
   1505            */

   \                                 In section .far_func.text, align 1
   1506          void TIM5_ClearFlag(TIM5_FLAG_TypeDef TIM5_FLAG)
   1507          {
   1508            /* Check the parameters */
   1509            assert_param(IS_TIM5_CLEAR_FLAG((uint16_t)TIM5_FLAG));
   1510            /* Clear the flags (rc_w0) clear this bit by writing 0. Writing ‘1’ has no effect*/
   1511            TIM5->SR1 = (uint8_t)(~(uint8_t)(TIM5_FLAG));
   \                     TIM5_ClearFlag:
   \   000000 9F           LD        A, XL
   \   000001 43           CPL       A
   \   000002 C7 5306      LD        L:0x5306, A
   1512            TIM5->SR2 = (uint8_t)(~(uint8_t)((uint16_t)TIM5_FLAG >> 8));
   \   000005 4F           CLR       A
   \   000006 01           RRWA      X, A
   \   000007 9F           LD        A, XL
   \   000008 43           CPL       A
   \   000009 C7 5307      LD        L:0x5307, A
   1513          }
   \   00000C 87           RETF
   1514          
   1515          /**
   1516            * @brief  Checks whether the TIM5 interrupt has occurred or not.
   1517            * @param  TIM5_IT: Specifies the TIM5 interrupt source to check.
   1518            *          This parameter can be any combination of the following values:
   1519            *            @arg TIM5_IT_Update: Update
   1520            *            @arg TIM5_IT_CC1: Capture Compare Channel1
   1521            *            @arg TIM5_IT_CC2: Capture Compare Channel2 
   1522            *            @arg TIM5_IT_Trigger: Trigger 
   1523            *            @arg TIM5_IT_Break: Break  
   1524            * @retval ITStatus: The new state of the TIM5_IT (SET or RESET)
   1525            */

   \                                 In section .far_func.text, align 1
   1526          ITStatus TIM5_GetITStatus(TIM5_IT_TypeDef TIM5_IT)
   1527          {
   \                     TIM5_GetITStatus:
   \   000000 B7 ..        LD        S:?b3, A
   1528            ITStatus bitstatus = RESET;
   \   000002 3F ..        CLR       S:?b0
   1529          
   1530            uint8_t TIM5_itStatus = 0x0, TIM5_itEnable = 0x0;
   \   000004 3F ..        CLR       S:?b2
   \   000006 3F ..        CLR       S:?b1
   1531          
   1532            /* Check the parameters */
   1533            assert_param(IS_TIM5_GET_IT(TIM5_IT));
   1534          
   1535            TIM5_itStatus = (uint8_t)(TIM5->SR1 & (uint8_t)TIM5_IT);
   \   000008 B6 ..        LD        A, S:?b3
   \   00000A C4 5306      AND       A, L:0x5306
   \   00000D B7 ..        LD        S:?b2, A
   1536          
   1537            TIM5_itEnable = (uint8_t)(TIM5->IER & (uint8_t)TIM5_IT);
   \   00000F B6 ..        LD        A, S:?b3
   \   000011 C4 5305      AND       A, L:0x5305
   \   000014 B7 ..        LD        S:?b1, A
   1538          
   1539            if ((TIM5_itStatus != (uint8_t)RESET ) && (TIM5_itEnable != (uint8_t)RESET))
   \   000016 3D ..        TNZ       S:?b2
   \   000018 27 0A        JREQ      L:??TIM5_GetITStatus_0
   \   00001A 3D ..        TNZ       S:?b1
   \   00001C 27 06        JREQ      L:??TIM5_GetITStatus_0
   1540            {
   1541              bitstatus = (ITStatus)SET;
   \   00001E 35 01 ....   MOV       S:?b0, #0x1
   \   000022 20 02        JRA       L:??TIM5_GetITStatus_1
   1542            }
   1543            else
   1544            {
   1545              bitstatus = (ITStatus)RESET;
   \                     ??TIM5_GetITStatus_0:
   \   000024 3F ..        CLR       S:?b0
   1546            }
   1547            return ((ITStatus)bitstatus);
   \                     ??TIM5_GetITStatus_1:
   \   000026 B6 ..        LD        A, S:?b0
   \   000028 87           RETF
   1548          }
   1549          
   1550          /**
   1551            * @brief  Clears the TIM's interrupt pending bits.
   1552            * @param  TIM5_IT: Specifies the pending bit to clear.
   1553            *          This parameter can be any combination of the following values:
   1554            *            @arg TIM5_IT_Update: Update
   1555            *            @arg TIM5_IT_CC1: Capture Compare Channel1
   1556            *            @arg TIM5_IT_CC2: Capture Compare Channel2 
   1557            *            @arg TIM5_IT_Trigger: Trigger 
   1558            *            @arg TIM5_IT_Break: Break  
   1559            * @retval None
   1560            */

   \                                 In section .far_func.text, align 1
   1561          void TIM5_ClearITPendingBit(TIM5_IT_TypeDef TIM5_IT)
   1562          {
   1563            /* Check the parameters */
   1564            assert_param(IS_TIM5_IT(TIM5_IT));
   1565          
   1566            /* Clear the IT pending Bit */
   1567            TIM5->SR1 = (uint8_t)(~(uint8_t)TIM5_IT);
   \                     TIM5_ClearITPendingBit:
   \   000000 43           CPL       A
   \   000001 C7 5306      LD        L:0x5306, A
   1568          }
   \   000004 87           RETF
   1569          
   1570          /**
   1571            * @brief  Enables or disables the TIM5 DMA Requests.
   1572            * @param  TIM5_DMASource: specifies the DMA Request sources.
   1573            *          This parameter can be any combination of the following values:
   1574            *            @arg TIM5_DMASource_Update: TIM5 DMA Update Request
   1575            *            @arg TIM5_DMASource_CC1: TIM5 DMA CC1 Request
   1576            *            @arg TIM5_DMASource_CC2: TIM5 DMA CC2 Request 
   1577            * @param  NewState: new state of the DMA Request sources.
   1578            *          This parameter can be: ENABLE or DISABLE.
   1579            * @retval None
   1580            */

   \                                 In section .far_func.text, align 1
   1581          void TIM5_DMACmd( TIM5_DMASource_TypeDef TIM5_DMASource, FunctionalState NewState)
   1582          {
   1583            /* Check the parameters */
   1584            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1585            assert_param(IS_TIM5_DMA_SOURCE(TIM5_DMASource));
   1586          
   1587            if (NewState != DISABLE)
   \                     TIM5_DMACmd:
   \   000000 3D ..        TNZ       S:?b0
   \   000002 27 07        JREQ      L:??TIM5_DMACmd_0
   1588            {
   1589              /* Enable the DMA sources */
   1590              TIM5->DER |= TIM5_DMASource;
   \   000004 CA 5304      OR        A, L:0x5304
   \   000007 C7 5304      LD        L:0x5304, A
   \   00000A 87           RETF
   1591            }
   1592            else
   1593            {
   1594              /* Disable the DMA sources */
   1595              TIM5->DER &= (uint8_t)(~TIM5_DMASource);
   \                     ??TIM5_DMACmd_0:
   \   00000B 43           CPL       A
   \   00000C C4 5304      AND       A, L:0x5304
   \   00000F C7 5304      LD        L:0x5304, A
   1596            }
   1597          }
   \   000012 87           RETF
   1598          
   1599          /**
   1600            * @brief  Selects the TIM5 peripheral Capture Compare DMA source.
   1601            * @param   NewState: new state of the Capture Compare DMA source.
   1602            *           This parameter can be: ENABLE or DISABLE.
   1603            * @retval None
   1604            */

   \                                 In section .far_func.text, align 1
   1605          void TIM5_SelectCCDMA(FunctionalState NewState)
   1606          {
   1607            /* Check the parameters */
   1608            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1609          
   1610            if (NewState != DISABLE)
   \                     TIM5_SelectCCDMA:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM5_SelectCCDMA_0
   1611            {
   1612              /* Set the CCDS Bit */
   1613              TIM5->CR2 |= TIM_CR2_CCDS;
   \   000003 7216 5301    BSET      L:0x5301, #0x3
   \   000007 87           RETF
   1614            }
   1615            else
   1616            {
   1617              /* Reset the CCDS Bit */
   1618              TIM5->CR2 &= (uint8_t)(~TIM_CR2_CCDS);
   \                     ??TIM5_SelectCCDMA_0:
   \   000008 7217 5301    BRES      L:0x5301, #0x3
   1619            }
   1620          }
   \   00000C 87           RETF
   1621          
   1622          /**
   1623            * @}
   1624            */
   1625          
   1626          /** @defgroup TIM5_Group5 Clocks management functions
   1627           *  @brief    Clocks management functions
   1628           *
   1629          @verbatim   
   1630           ===============================================================================
   1631                                   Clocks management functions
   1632           ===============================================================================  
   1633          
   1634          @endverbatim
   1635            * @{
   1636            */
   1637          
   1638          /**
   1639            * @brief  Enables the TIM5 internal Clock.
   1640            * @par Parameters:
   1641            * None
   1642            * @retval None
   1643            */

   \                                 In section .far_func.text, align 1
   1644          void TIM5_InternalClockConfig(void)
   1645          {
   1646            /* Disable slave mode to clock the prescaler directly with the internal clock */
   1647            TIM5->SMCR &=  (uint8_t)(~TIM_SMCR_SMS);
   \                     TIM5_InternalClockConfig:
   \   000000 C6 5302      LD        A, L:0x5302
   \   000003 A4 F8        AND       A, #0xf8
   \   000005 C7 5302      LD        L:0x5302, A
   1648          }
   \   000008 87           RETF
   1649          
   1650          /**
   1651            * @brief  Configures the TIM5 Trigger as External Clock.
   1652            * @param  TIM5_TIxExternalCLKSource: Specifies Trigger source.
   1653            *          This parameter can be one of the following values:
   1654            *            @arg TIM5_TIxExternalCLK1Source_TI1ED: External Clock mode 1 source = TI1ED
   1655            *            @arg TIM5_TIxExternalCLK1Source_TI1: External Clock mode 1 source = TI1 
   1656            *            @arg TIM5_TIxExternalCLK1Source_TI2: External Clock mode 1 source = TI2  
   1657            * @param  TIM5_ICPolarity: Specifies the TIx Polarity.
   1658            *          This parameter can be one of the following values:
   1659            *            @arg TIM5_ICPolarity_Rising: Input Capture on Rising Edge
   1660            *            @arg TIM5_ICPolarity_Falling: Input Capture on Falling Edge  
   1661            * @param  ICFilter: Specifies the filter value.
   1662            *          This parameter must be a value between 0x00 and 0x0F
   1663            * @retval None
   1664            */

   \                                 In section .far_func.text, align 1
   1665          void TIM5_TIxExternalClockConfig(TIM5_TIxExternalCLK1Source_TypeDef TIM5_TIxExternalCLKSource,
   1666                                           TIM5_ICPolarity_TypeDef TIM5_ICPolarity,
   1667                                           uint8_t ICFilter)
   1668          {
   \                     TIM5_TIxExternalClockConfig:
   \   000000 B7 ..        LD        S:?b4, A
   \   000002 45 .. ..     MOV       S:?b2, S:?b0
   1669            /* Check the parameters */
   1670            assert_param(IS_TIM5_TIXCLK_SOURCE(TIM5_TIxExternalCLKSource));
   1671            assert_param(IS_TIM5_IC_POLARITY(TIM5_ICPolarity));
   1672            assert_param(IS_TIM5_IC_FILTER(ICFilter));
   1673          
   1674            /* Configure the TIM5 Input Clock Source */
   1675            if (TIM5_TIxExternalCLKSource == TIM5_TIxExternalCLK1Source_TI2)
   \   000005 B6 ..        LD        A, S:?b4
   \   000007 A1 60        CP        A, #0x60
   \   000009 26 0C        JRNE      L:??TIM5_TIxExternalClockConfig_0
   1676            {
   1677              TI2_Config(TIM5_ICPolarity, TIM5_ICSelection_DirectTI, ICFilter);
   \   00000B 35 01 ....   MOV       S:?b0, #0x1
   \   00000F B6 ..        LD        A, S:?b2
   \   000011 8D ......    CALLF     TI2_Config
   \   000015 20 0A        JRA       L:??TIM5_TIxExternalClockConfig_1
   1678            }
   1679            else
   1680            {
   1681              TI1_Config(TIM5_ICPolarity, TIM5_ICSelection_DirectTI, ICFilter);
   \                     ??TIM5_TIxExternalClockConfig_0:
   \   000017 35 01 ....   MOV       S:?b0, #0x1
   \   00001B B6 ..        LD        A, S:?b2
   \   00001D 8D ......    CALLF     TI1_Config
   1682            }
   1683          
   1684            /* Select the Trigger source */
   1685            TIM5_SelectInputTrigger((TIM5_TRGSelection_TypeDef)TIM5_TIxExternalCLKSource);
   \                     ??TIM5_TIxExternalClockConfig_1:
   \   000021 B6 ..        LD        A, S:?b4
   \   000023 8D ......    CALLF     TIM5_SelectInputTrigger
   1686          
   1687            /* Select the External clock mode1 */
   1688            TIM5->SMCR |= (uint8_t)(TIM5_SlaveMode_External1);
   \   000027 C6 5302      LD        A, L:0x5302
   \   00002A AA 07        OR        A, #0x7
   \   00002C C7 5302      LD        L:0x5302, A
   1689          }
   \   00002F 87           RETF
   1690          
   1691          /**
   1692            * @brief  Configures the TIM5 External clock Mode1.
   1693            * @param  TIM5_ExtTRGPrescaler: Specifies the external Trigger Prescaler.
   1694            *          This parameter can be one of the following values:
   1695            *            @arg TIM5_ExtTRGPSC_OFF: No External Trigger prescaler
   1696            *            @arg TIM5_ExtTRGPSC_DIV2: External Trigger prescaler = 2 (ETRP frequency divided by 2)
   1697            *            @arg TIM5_ExtTRGPSC_DIV4: External Trigger prescaler = 4 (ETRP frequency divided by 4) 
   1698            *            @arg TIM5_ExtTRGPSC_DIV8: External Trigger prescaler = 8 (ETRP frequency divided by 8)   
   1699            * @param  TIM5_ExtTRGPolarity: Specifies the external Trigger Polarity.
   1700            *          This parameter can be one of the following values:
   1701            *            @arg TIM5_ExtTRGPolarity_Inverted: External Trigger Polarity = inverted
   1702            *            @arg TIM5_ExtTRGPolarity_NonInverted: External Trigger Polarity = non inverted
   1703            * @param  ExtTRGFilter: Specifies the External Trigger Filter.
   1704            *          This parameter must be a value between 0x00 and 0x0F
   1705            * @retval None
   1706            */

   \                                 In section .far_func.text, align 1
   1707          void TIM5_ETRClockMode1Config(TIM5_ExtTRGPSC_TypeDef TIM5_ExtTRGPrescaler,
   1708                                        TIM5_ExtTRGPolarity_TypeDef TIM5_ExtTRGPolarity,
   1709                                        uint8_t ExtTRGFilter)
   1710          {
   1711            /* Configure the ETR Clock source */
   1712            TIM5_ETRConfig(TIM5_ExtTRGPrescaler, TIM5_ExtTRGPolarity, ExtTRGFilter);
   \                     TIM5_ETRClockMode1Config:
   \   000000 8D ......    CALLF     TIM5_ETRConfig
   1713          
   1714            /* Select the External clock mode1 */
   1715            TIM5->SMCR &= (uint8_t)(~TIM_SMCR_SMS);
   \   000004 C6 5302      LD        A, L:0x5302
   \   000007 A4 F8        AND       A, #0xf8
   \   000009 C7 5302      LD        L:0x5302, A
   1716            TIM5->SMCR |= (uint8_t)(TIM5_SlaveMode_External1);
   \   00000C C6 5302      LD        A, L:0x5302
   \   00000F AA 07        OR        A, #0x7
   \   000011 C7 5302      LD        L:0x5302, A
   1717          
   1718            /* Select the Trigger selection: ETRF */
   1719            TIM5->SMCR &= (uint8_t)(~TIM_SMCR_TS);
   \   000014 C6 5302      LD        A, L:0x5302
   \   000017 A4 8F        AND       A, #0x8f
   \   000019 C7 5302      LD        L:0x5302, A
   1720            TIM5->SMCR |= (uint8_t)((TIM5_TRGSelection_TypeDef)TIM5_TRGSelection_ETRF);
   \   00001C C6 5302      LD        A, L:0x5302
   \   00001F AA 70        OR        A, #0x70
   \   000021 C7 5302      LD        L:0x5302, A
   1721          }
   \   000024 87           RETF
   1722          
   1723          /**
   1724            * @brief  Configures the TIM5 External clock Mode2.
   1725            * @param  TIM5_ExtTRGPrescaler: Specifies the external Trigger Prescaler.
   1726            *          This parameter can be one of the following values:
   1727            *            @arg TIM5_ExtTRGPSC_OFF: No External Trigger prescaler
   1728            *            @arg TIM5_ExtTRGPSC_DIV2: External Trigger prescaler = 2 (ETRP frequency divided by 2)
   1729            *            @arg TIM5_ExtTRGPSC_DIV4: External Trigger prescaler = 4 (ETRP frequency divided by 4) 
   1730            *            @arg TIM5_ExtTRGPSC_DIV8: External Trigger prescaler = 8 (ETRP frequency divided by 8) 
   1731            * @param  TIM5_ExtTRGPolarity: Specifies the external Trigger Polarity.
   1732            *          This parameter can be one of the following values:
   1733            *            @arg TIM5_ExtTRGPolarity_Inverted: External Trigger Polarity = inverted
   1734            *            @arg TIM5_ExtTRGPolarity_NonInverted: External Trigger Polarity = non inverted
   1735            * @param  ExtTRGFilter: Specifies the External Trigger Filter.
   1736            *          This parameter must be a value between 0x00 and 0x0F
   1737            * @retval None
   1738            */

   \                                 In section .far_func.text, align 1
   1739          void TIM5_ETRClockMode2Config(TIM5_ExtTRGPSC_TypeDef TIM5_ExtTRGPrescaler,
   1740                                        TIM5_ExtTRGPolarity_TypeDef TIM5_ExtTRGPolarity,
   1741                                        uint8_t ExtTRGFilter)
   1742          {
   1743            /* Configure the ETR Clock source */
   1744            TIM5_ETRConfig(TIM5_ExtTRGPrescaler, TIM5_ExtTRGPolarity, ExtTRGFilter);
   \                     TIM5_ETRClockMode2Config:
   \   000000 8D ......    CALLF     TIM5_ETRConfig
   1745          
   1746            /* Enable the External clock mode2 */
   1747            TIM5->ETR |= TIM_ETR_ECE ;
   \   000004 721C 5303    BSET      L:0x5303, #0x6
   1748          }
   \   000008 87           RETF
   1749          
   1750          /**
   1751            * @}
   1752            */
   1753          
   1754          /** @defgroup TIM5_Group6 Synchronization management functions
   1755           *  @brief    Synchronization management functions 
   1756           *
   1757          @verbatim   
   1758           ===============================================================================
   1759                                 Synchronization management functions
   1760           ===============================================================================  
   1761                             
   1762                 ===================================================================      
   1763                        TIM5 Driver: how to use it in synchronization Mode
   1764                 =================================================================== 
   1765                 Case of two/several Timers
   1766                 **************************
   1767                 1. If TIM5 is used as master to other timers use the following functions:
   1768                    - TIM5_SelectOutputTrigger()
   1769                    - TIM5_SelectMasterSlaveMode()
   1770                 2. If TIM5 is used as slave to other timers use the following functions:
   1771                    - TIM5_SelectInputTrigger()
   1772                    - TIM5_SelectSlaveMode()
   1773                    
   1774                 Case of Timers and external trigger (TRIG pin)
   1775                 ********************************************       
   1776                 1. Configure the External trigger using TIM5_ETRConfig()
   1777                 2. Configure the Slave Timer using the following functions:
   1778                    - TIM5_SelectInputTrigger()
   1779                    - TIM5_SelectSlaveMode()
   1780          
   1781          @endverbatim
   1782            * @{
   1783            */
   1784          
   1785          /**
   1786            * @brief  Selects the TIM5 Input Trigger source.
   1787            * @param  TIM5_InputTriggerSource: Specifies Input Trigger source.
   1788            *          This parameter can be one of the following values:
   1789            *            @arg TIM5_TRGSelection_TIM4: TRIG Input source =  TIM TRIG Output
   1790            *            @arg TIM5_TRGSelection_TIM1: TRIG Input source =  TIM TRIG Output
   1791            *            @arg TIM5_TRGSelection_TIM3: TRIG Input source =  TIM TRIG Output
   1792            *            @arg TIM5_TRGSelection_TIM2: TRIG Input source =  TIM TRIG Output
   1793            *            @arg TIM5_TRGSelection_TI1F_ED: TRIG Input source = TI1F_ED (TI1 Edge Detector)
   1794            *            @arg TIM5_TRGSelection_TI1FP1: TRIG Input source = TI1FP1 (Filtered Timer Input 1)
   1795            *            @arg TIM5_TRGSelection_TI2FP2: TRIG Input source = TI2FP2 (Filtered Timer Input 2)
   1796            *            @arg TIM5_TRGSelection_ETRF: TRIG Input source =  ETRF (External Trigger Input )      
   1797            * @retval None
   1798            */

   \                                 In section .far_func.text, align 1
   1799          void TIM5_SelectInputTrigger(TIM5_TRGSelection_TypeDef TIM5_InputTriggerSource)
   1800          {
   \                     TIM5_SelectInputTrigger:
   \   000000 B7 ..        LD        S:?b0, A
   1801            uint8_t tmpsmcr = 0;
   \   000002 3F ..        CLR       S:?b1
   1802          
   1803            /* Check the parameters */
   1804            assert_param(IS_TIM5_TRIGGER_SELECTION(TIM5_InputTriggerSource));
   1805          
   1806            tmpsmcr = TIM5->SMCR;
   \   000004 C6 5302      LD        A, L:0x5302
   \   000007 B7 ..        LD        S:?b1, A
   1807          
   1808            /* Select the Trigger Source */
   1809            tmpsmcr &= (uint8_t)(~TIM_SMCR_TS);
   \   000009 B6 ..        LD        A, S:?b1
   \   00000B A4 8F        AND       A, #0x8f
   \   00000D B7 ..        LD        S:?b1, A
   1810            tmpsmcr |= (uint8_t)TIM5_InputTriggerSource;
   \   00000F B6 ..        LD        A, S:?b0
   \   000011 BA ..        OR        A, S:?b1
   \   000013 B7 ..        LD        S:?b1, A
   1811          
   1812            TIM5->SMCR = (uint8_t)tmpsmcr;
   \   000015 B6 ..        LD        A, S:?b1
   \   000017 C7 5302      LD        L:0x5302, A
   1813          }
   \   00001A 87           RETF
   1814          
   1815          /**
   1816            * @brief  Selects the TIM5 Trigger Output Mode.
   1817            * @param  TIM5_TRGOSource: Specifies the Trigger Output source.
   1818            *          This parameter can be one of the following values:
   1819            *            @arg TIM5_TRGOSource_Reset: Trigger Output source = Reset 
   1820            *            @arg TIM5_TRGOSource_Enable: Trigger Output source = TIM5 is enabled 
   1821            *            @arg TIM5_TRGOSource_Update: Trigger Output source = Update event
   1822            *            @arg TIM5_TRGOSource_OC1: Trigger Output source = output compare channel1
   1823            *            @arg TIM5_TRGOSource_OC1REF: Trigger Output source = output compare channel 1 reference
   1824            *            @arg TIM5_TRGOSource_OC2REF: Trigger Output source = output compare channel 2 reference   
   1825            * @retval None
   1826            */

   \                                 In section .far_func.text, align 1
   1827          void TIM5_SelectOutputTrigger(TIM5_TRGOSource_TypeDef TIM5_TRGOSource)
   1828          {
   \                     TIM5_SelectOutputTrigger:
   \   000000 B7 ..        LD        S:?b0, A
   1829            uint8_t tmpcr2 = 0;
   \   000002 3F ..        CLR       S:?b1
   1830          
   1831            /* Check the parameters */
   1832            assert_param(IS_TIM5_TRGO_SOURCE(TIM5_TRGOSource));
   1833          
   1834            tmpcr2 = TIM5->CR2;
   \   000004 C6 5301      LD        A, L:0x5301
   \   000007 B7 ..        LD        S:?b1, A
   1835          
   1836            /* Reset the MMS Bits */
   1837            tmpcr2 &= (uint8_t)(~TIM_CR2_MMS);
   \   000009 B6 ..        LD        A, S:?b1
   \   00000B A4 8F        AND       A, #0x8f
   \   00000D B7 ..        LD        S:?b1, A
   1838          
   1839            /* Select the TRGO source */
   1840            tmpcr2 |=  (uint8_t)TIM5_TRGOSource;
   \   00000F B6 ..        LD        A, S:?b0
   \   000011 BA ..        OR        A, S:?b1
   \   000013 B7 ..        LD        S:?b1, A
   1841          
   1842            TIM5->CR2 = tmpcr2;
   \   000015 B6 ..        LD        A, S:?b1
   \   000017 C7 5301      LD        L:0x5301, A
   1843          }
   \   00001A 87           RETF
   1844          
   1845          /**
   1846            * @brief  Selects the TIM5 Slave Mode.
   1847            * @param  TIM5_SlaveMode: Specifies the TIM5 Slave Mode.
   1848            *          This parameter can be one of the following values:
   1849            *            @arg TIM5_SlaveMode_Reset: Slave Mode Selection  = Reset
   1850            *            @arg TIM5_SlaveMode_Gated: Slave Mode Selection  = Gated
   1851            *            @arg TIM5_SlaveMode_Trigger: Slave Mode Selection  = Trigger
   1852            *            @arg TIM5_SlaveMode_External1: Slave Mode Selection  = External 1  
   1853            * @retval None
   1854            */

   \                                 In section .far_func.text, align 1
   1855          void TIM5_SelectSlaveMode(TIM5_SlaveMode_TypeDef TIM5_SlaveMode)
   1856          {
   \                     TIM5_SelectSlaveMode:
   \   000000 B7 ..        LD        S:?b0, A
   1857            uint8_t tmpsmcr = 0;
   \   000002 3F ..        CLR       S:?b1
   1858          
   1859            /* Check the parameters */
   1860            assert_param(IS_TIM5_SLAVE_MODE(TIM5_SlaveMode));
   1861          
   1862            tmpsmcr = TIM5->SMCR;
   \   000004 C6 5302      LD        A, L:0x5302
   \   000007 B7 ..        LD        S:?b1, A
   1863          
   1864            /* Reset the SMS Bits */
   1865            tmpsmcr &= (uint8_t)(~TIM_SMCR_SMS);
   \   000009 B6 ..        LD        A, S:?b1
   \   00000B A4 F8        AND       A, #0xf8
   \   00000D B7 ..        LD        S:?b1, A
   1866          
   1867            /* Select the Slave Mode */
   1868            tmpsmcr |= (uint8_t)TIM5_SlaveMode;
   \   00000F B6 ..        LD        A, S:?b0
   \   000011 BA ..        OR        A, S:?b1
   \   000013 B7 ..        LD        S:?b1, A
   1869          
   1870            TIM5->SMCR = tmpsmcr;
   \   000015 B6 ..        LD        A, S:?b1
   \   000017 C7 5302      LD        L:0x5302, A
   1871          }
   \   00001A 87           RETF
   1872          
   1873          /**
   1874            * @brief  Sets or Resets the TIM5 Master/Slave Mode.
   1875            * @param  NewState: The new state of the synchronization between TIM5 and its slaves (through TRGO).
   1876            *          This parameter can be ENABLE or DISABLE
   1877            * @retval None
   1878            */

   \                                 In section .far_func.text, align 1
   1879          void TIM5_SelectMasterSlaveMode(FunctionalState NewState)
   1880          {
   1881            /* Check the parameters */
   1882            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1883          
   1884            /* Set or Reset the MSM Bit */
   1885            if (NewState != DISABLE)
   \                     TIM5_SelectMasterSlaveMode:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM5_SelectMasterSlaveMode_0
   1886            {
   1887              TIM5->SMCR |= TIM_SMCR_MSM;
   \   000003 721E 5302    BSET      L:0x5302, #0x7
   \   000007 87           RETF
   1888            }
   1889            else
   1890            {
   1891              TIM5->SMCR &= (uint8_t)(~TIM_SMCR_MSM);
   \                     ??TIM5_SelectMasterSlaveMode_0:
   \   000008 721F 5302    BRES      L:0x5302, #0x7
   1892            }
   1893          }
   \   00000C 87           RETF
   1894          
   1895          /**
   1896            * @brief  Configures the TIM5 External Trigger.
   1897            * @param  TIM5_ExtTRGPrescaler: Specifies the external Trigger Prescaler.
   1898            *          This parameter can be one of the following values:
   1899            *            @arg TIM5_ExtTRGPSC_OFF: No External Trigger prescaler
   1900            *            @arg TIM5_ExtTRGPSC_DIV2: External Trigger prescaler = 2 (ETRP frequency divided by 2)
   1901            *            @arg TIM5_ExtTRGPSC_DIV4: External Trigger prescaler = 4 (ETRP frequency divided by 4)
   1902            *            @arg TIM5_ExtTRGPSC_DIV8: External Trigger prescaler = 8 (ETRP frequency divided by 8)    
   1903            * @param  TIM5_ExtTRGPolarity: Specifies the external Trigger Polarity.
   1904            *          This parameter can be one of the following values:
   1905            *            @arg TIM5_ExtTRGPolarity_Inverted: External Trigger Polarity = inverted
   1906            *            @arg TIM5_ExtTRGPolarity_NonInverted: External Trigger Polarity = non inverted
   1907            * @param  ExtTRGFilter: Specifies the External Trigger Filter.
   1908            *          This parameter must be a value between 0x00 and 0x0F
   1909            * @retval None
   1910            */

   \                                 In section .far_func.text, align 1
   1911          void TIM5_ETRConfig(TIM5_ExtTRGPSC_TypeDef TIM5_ExtTRGPrescaler,
   1912                              TIM5_ExtTRGPolarity_TypeDef TIM5_ExtTRGPolarity,
   1913                              uint8_t ExtTRGFilter)
   1914          {
   \                     TIM5_ETRConfig:
   \   000000 B7 ..        LD        S:?b2, A
   \   000002 B6 ..        LD        A, S:?b0
   1915            /* Check the parameters */
   1916            assert_param(IS_TIM5_EXT_PRESCALER(TIM5_ExtTRGPrescaler));
   1917            assert_param(IS_TIM5_EXT_POLARITY(TIM5_ExtTRGPolarity));
   1918            assert_param(IS_TIM5_EXT_FILTER(ExtTRGFilter));
   1919          
   1920            /* Set the Prescaler, the Filter value and the Polarity */
   1921            TIM5->ETR |= (uint8_t)((uint8_t)((uint8_t)TIM5_ExtTRGPrescaler | (uint8_t)TIM5_ExtTRGPolarity)
   1922                                   | (uint8_t)ExtTRGFilter);
   \   000004 BA ..        OR        A, S:?b2
   \   000006 BA ..        OR        A, S:?b1
   \   000008 CA 5303      OR        A, L:0x5303
   \   00000B C7 5303      LD        L:0x5303, A
   1923          }
   \   00000E 87           RETF
   1924          
   1925          /**
   1926            * @}
   1927            */
   1928          
   1929          /** @defgroup TIM5_Group7 Specific interface management functions
   1930           *  @brief    Specific interface management functions 
   1931           *
   1932          @verbatim   
   1933           ===============================================================================
   1934                              Specific interface management functions
   1935           ===============================================================================  
   1936          
   1937          @endverbatim
   1938            * @{
   1939            */
   1940          
   1941          /**
   1942            * @brief  Configures the TIM5 Encoder Interface.
   1943            * @param  TIM5_EncoderMode: Specifies the TIM5 Encoder Mode.
   1944            *          This parameter can be one of the following values:
   1945            *            @arg TIM5_EncoderMode_TI1: Encoder mode 1
   1946            *            @arg TIM5_EncoderMode_TI2: Encoder mode 2
   1947            *            @arg TIM5_EncoderMode_TI12: Encoder mode 3   
   1948            * @param  TIM5_IC1Polarity: Specifies the IC1 Polarity.
   1949            *          This parameter can be one of the following values:
   1950            *            @arg TIM5_ICPolarity_Rising: Input Capture on Rising Edge
   1951            *            @arg TIM5_ICPolarity_Falling: Input Capture on Falling Edge  
   1952            * @param  TIM5_IC2Polarity: Specifies the IC2 Polarity.
   1953            *          This parameter can be one of the following values:
   1954            *            @arg TIM5_ICPolarity_Rising: Input Capture on Rising Edge
   1955            *            @arg TIM5_ICPolarity_Falling: Input Capture on Falling Edge  
   1956            * @retval None
   1957            */

   \                                 In section .far_func.text, align 1
   1958          void TIM5_EncoderInterfaceConfig(TIM5_EncoderMode_TypeDef TIM5_EncoderMode,
   1959                                           TIM5_ICPolarity_TypeDef TIM5_IC1Polarity,
   1960                                           TIM5_ICPolarity_TypeDef TIM5_IC2Polarity)
   1961          {
   \                     TIM5_EncoderInterfaceConfig:
   \   000000 B7 ..        LD        S:?b4, A
   1962            uint8_t tmpsmcr = 0;
   \   000002 3F ..        CLR       S:?b5
   1963            uint8_t tmpccmr1 = 0;
   \   000004 3F ..        CLR       S:?b2
   1964            uint8_t tmpccmr2 = 0;
   \   000006 3F ..        CLR       S:?b3
   1965          
   1966            /* Check the parameters */
   1967            assert_param(IS_TIM5_ENCODER_MODE(TIM5_EncoderMode));
   1968            assert_param(IS_TIM5_IC_POLARITY(TIM5_IC1Polarity));
   1969            assert_param(IS_TIM5_IC_POLARITY(TIM5_IC2Polarity));
   1970          
   1971            tmpsmcr = TIM5->SMCR;
   \   000008 C6 5302      LD        A, L:0x5302
   \   00000B B7 ..        LD        S:?b5, A
   1972            tmpccmr1 = TIM5->CCMR1;
   \   00000D C6 5309      LD        A, L:0x5309
   \   000010 B7 ..        LD        S:?b2, A
   1973            tmpccmr2 = TIM5->CCMR2;
   \   000012 C6 530A      LD        A, L:0x530a
   \   000015 B7 ..        LD        S:?b3, A
   1974          
   1975            /* Set the encoder Mode */
   1976            tmpsmcr &= (uint8_t)(TIM_SMCR_MSM | TIM_SMCR_TS)  ;
   \   000017 B6 ..        LD        A, S:?b5
   \   000019 A4 F0        AND       A, #0xf0
   \   00001B B7 ..        LD        S:?b5, A
   1977            tmpsmcr |= (uint8_t)TIM5_EncoderMode;
   \   00001D B6 ..        LD        A, S:?b4
   \   00001F BA ..        OR        A, S:?b5
   \   000021 B7 ..        LD        S:?b5, A
   1978          
   1979            /* Select the Capture Compare 1 and the Capture Compare 2 as input */
   1980            tmpccmr1 &= (uint8_t)(~TIM_CCMR_CCxS);
   \   000023 B6 ..        LD        A, S:?b2
   \   000025 A4 FC        AND       A, #0xfc
   \   000027 B7 ..        LD        S:?b2, A
   1981            tmpccmr2 &= (uint8_t)(~TIM_CCMR_CCxS);
   \   000029 B6 ..        LD        A, S:?b3
   \   00002B A4 FC        AND       A, #0xfc
   \   00002D B7 ..        LD        S:?b3, A
   1982            tmpccmr1 |= TIM_CCMR_TIxDirect_Set;
   \   00002F B6 ..        LD        A, S:?b2
   \   000031 AA 01        OR        A, #0x1
   \   000033 B7 ..        LD        S:?b2, A
   1983            tmpccmr2 |= TIM_CCMR_TIxDirect_Set;
   \   000035 B6 ..        LD        A, S:?b3
   \   000037 AA 01        OR        A, #0x1
   \   000039 B7 ..        LD        S:?b3, A
   1984          
   1985            /* Set the TI1 and the TI2 Polarities */
   1986            if (TIM5_IC1Polarity == TIM5_ICPolarity_Falling)
   \   00003B B6 ..        LD        A, S:?b0
   \   00003D A1 01        CP        A, #0x1
   \   00003F 26 06        JRNE      L:??TIM5_EncoderInterfaceConfig_0
   1987            {
   1988              TIM5->CCER1 |= TIM_CCER1_CC1P ;
   \   000041 7212 530B    BSET      L:0x530b, #0x1
   \   000045 20 04        JRA       L:??TIM5_EncoderInterfaceConfig_1
   1989            }
   1990            else
   1991            {
   1992              TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC1P) ;
   \                     ??TIM5_EncoderInterfaceConfig_0:
   \   000047 7213 530B    BRES      L:0x530b, #0x1
   1993            }
   1994          
   1995            if (TIM5_IC2Polarity == TIM5_ICPolarity_Falling)
   \                     ??TIM5_EncoderInterfaceConfig_1:
   \   00004B B6 ..        LD        A, S:?b1
   \   00004D A1 01        CP        A, #0x1
   \   00004F 26 06        JRNE      L:??TIM5_EncoderInterfaceConfig_2
   1996            {
   1997              TIM5->CCER1 |= TIM_CCER1_CC2P ;
   \   000051 721A 530B    BSET      L:0x530b, #0x5
   \   000055 20 04        JRA       L:??TIM5_EncoderInterfaceConfig_3
   1998            }
   1999            else
   2000            {
   2001              TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC2P) ;
   \                     ??TIM5_EncoderInterfaceConfig_2:
   \   000057 721B 530B    BRES      L:0x530b, #0x5
   2002            }
   2003          
   2004            TIM5->SMCR = tmpsmcr;
   \                     ??TIM5_EncoderInterfaceConfig_3:
   \   00005B B6 ..        LD        A, S:?b5
   \   00005D C7 5302      LD        L:0x5302, A
   2005            TIM5->CCMR1 = tmpccmr1;
   \   000060 B6 ..        LD        A, S:?b2
   \   000062 C7 5309      LD        L:0x5309, A
   2006            TIM5->CCMR2 = tmpccmr2;
   \   000065 B6 ..        LD        A, S:?b3
   \   000067 C7 530A      LD        L:0x530a, A
   2007          }
   \   00006A 87           RETF
   2008          
   2009          /**
   2010            * @brief  Enables or Disables the TIM’s Hall sensor interface.
   2011            * @param  NewState: The new state of the TIM5 Hall sensor interface.
   2012            *          This parameter can be ENABLE or DISABLE
   2013            * @retval None
   2014            */

   \                                 In section .far_func.text, align 1
   2015          void TIM5_SelectHallSensor(FunctionalState NewState)
   2016          {
   2017            /* Check the parameters */
   2018            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2019          
   2020            /* Set or Reset the TI1S Bit */
   2021            if (NewState != DISABLE)
   \                     TIM5_SelectHallSensor:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM5_SelectHallSensor_0
   2022            {
   2023              TIM5->CR2 |= TIM_CR2_TI1S;
   \   000003 721E 5301    BSET      L:0x5301, #0x7
   \   000007 87           RETF
   2024            }
   2025            else
   2026            {
   2027              TIM5->CR2 &= (uint8_t)(~TIM_CR2_TI1S);
   \                     ??TIM5_SelectHallSensor_0:
   \   000008 721F 5301    BRES      L:0x5301, #0x7
   2028            }
   2029          }
   \   00000C 87           RETF
   2030          
   2031          /**
   2032            * @}
   2033            */
   2034          
   2035          /**
   2036            * @brief  Configure the TI1 as Input.
   2037            * @param  TIM5_ICPolarity: Input Capture Polarity
   2038            *          This parameter can be one of the following values:
   2039            *            @arg TIM5_ICPolarity_Rising: Input Capture on Rising Edge
   2040            *            @arg TIM5_ICPolarity_Falling: Input Capture on Falling Edge  
   2041            * @param  TIM5_ICSelection: Specifies the input to be used.
   2042            *          This parameter can be one of the following values:
   2043            *            @arg TIM5_ICSelection_DirectTI: Input Capture mapped on the direct input
   2044            *            @arg TIM5_ICSelection_IndirectTI: Input Capture mapped on the indirect input
   2045            *            @arg TIM5_ICSelection_TRGI: Input Capture mapped on the Trigger Input   
   2046            * @param  TIM5_ICFilter: Specifies the Input Capture Filter.
   2047            *          This parameter must be a value between 0x00 and 0x0F.
   2048            * @retval None
   2049            */

   \                                 In section .far_func.text, align 1
   2050          static void TI1_Config(TIM5_ICPolarity_TypeDef TIM5_ICPolarity, \
   2051                                 TIM5_ICSelection_TypeDef TIM5_ICSelection, \
   2052                                 uint8_t TIM5_ICFilter)
   2053          {
   \                     TI1_Config:
   \   000000 B7 ..        LD        S:?b2, A
   2054            uint8_t tmpccmr1 = 0;
   \   000002 3F ..        CLR       S:?b3
   2055            uint8_t tmpicpolarity = TIM5_ICPolarity;
   2056            tmpccmr1 = TIM5->CCMR1;
   \   000004 C6 5309      LD        A, L:0x5309
   \   000007 B7 ..        LD        S:?b3, A
   2057          
   2058            /* Check the parameters */
   2059            assert_param(IS_TIM5_IC_POLARITY(TIM5_ICPolarity));
   2060            assert_param(IS_TIM5_IC_SELECTION(TIM5_ICSelection));
   2061            assert_param(IS_TIM5_IC_FILTER(TIM5_ICFilter));
   2062          
   2063            /* Disable the Channel 1: Reset the CCE Bit */
   2064            TIM5->CCER1 &=  (uint8_t)(~TIM_CCER1_CC1E);
   \   000009 7211 530B    BRES      L:0x530b, #0x0
   2065          
   2066            /* Select the Input and set the filter */
   2067            tmpccmr1 &= (uint8_t)(~TIM_CCMR_CCxS) & (uint8_t)(~TIM_CCMR_ICxF);
   \   00000D B6 ..        LD        A, S:?b3
   \   00000F A4 0C        AND       A, #0xc
   \   000011 B7 ..        LD        S:?b3, A
   2068            tmpccmr1 |= (uint8_t)(((uint8_t)(TIM5_ICSelection)) | ((uint8_t)(TIM5_ICFilter << 4)));
   \   000013 B6 ..        LD        A, S:?b1
   \   000015 4E           SWAP      A
   \   000016 A4 F0        AND       A, #0xf0
   \   000018 BA ..        OR        A, S:?b0
   \   00001A BA ..        OR        A, S:?b3
   \   00001C B7 ..        LD        S:?b3, A
   2069          
   2070            TIM5->CCMR1 = tmpccmr1;
   \   00001E B6 ..        LD        A, S:?b3
   \   000020 C7 5309      LD        L:0x5309, A
   2071          
   2072            /* Select the Polarity */
   2073            if (tmpicpolarity == (uint8_t)(TIM5_ICPolarity_Falling))
   \   000023 B6 ..        LD        A, S:?b2
   \   000025 A1 01        CP        A, #0x1
   \   000027 26 06        JRNE      L:??TI1_Config_0
   2074            {
   2075              TIM5->CCER1 |= TIM_CCER1_CC1P;
   \   000029 7212 530B    BSET      L:0x530b, #0x1
   \   00002D 20 04        JRA       L:??TI1_Config_1
   2076            }
   2077            else
   2078            {
   2079              TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC1P);
   \                     ??TI1_Config_0:
   \   00002F 7213 530B    BRES      L:0x530b, #0x1
   2080            }
   2081          
   2082            /* Set the CCE Bit */
   2083            TIM5->CCER1 |=  TIM_CCER1_CC1E;
   \                     ??TI1_Config_1:
   \   000033 7210 530B    BSET      L:0x530b, #0x0
   2084          }
   \   000037 87           RETF
   2085          
   2086          /**
   2087            * @brief  Configure the TI2 as Input.
   2088            * @param  TIM5_ICPolarity: Input Capture Polarity
   2089            *          This parameter can be one of the following values:
   2090            *            @arg TIM5_ICPolarity_Rising: Input Capture on Rising Edge
   2091            *            @arg TIM5_ICPolarity_Falling: Input Capture on Falling Edge  
   2092            * @param  TIM5_ICSelection: Specifies the input to be used.
   2093            *          This parameter can be one of the following values:
   2094            *            @arg TIM5_ICSelection_DirectTI: Input Capture mapped on the direct input
   2095            *            @arg TIM5_ICSelection_IndirectTI: Input Capture mapped on the indirect input
   2096            *            @arg TIM5_ICSelection_TRGI: Input Capture mapped on the Trigger Input   
   2097            * @param  TIM5_ICFilter: Specifies the Input Capture Filter.
   2098            *          This parameter must be a value between 0x00 and 0x0F.
   2099            * @retval None
   2100            */

   \                                 In section .far_func.text, align 1
   2101          static void TI2_Config(TIM5_ICPolarity_TypeDef TIM5_ICPolarity,
   2102                                 TIM5_ICSelection_TypeDef TIM5_ICSelection,
   2103                                 uint8_t TIM5_ICFilter)
   2104          {
   \                     TI2_Config:
   \   000000 B7 ..        LD        S:?b2, A
   2105            uint8_t tmpccmr2 = 0;
   \   000002 3F ..        CLR       S:?b3
   2106            uint8_t tmpicpolarity = TIM5_ICPolarity;
   2107          
   2108            /* Check the parameters */
   2109            assert_param(IS_TIM5_IC_POLARITY(TIM5_ICPolarity));
   2110            assert_param(IS_TIM5_IC_SELECTION(TIM5_ICSelection));
   2111            assert_param(IS_TIM5_IC_FILTER(TIM5_ICFilter));
   2112          
   2113            tmpccmr2 = TIM5->CCMR2;
   \   000004 C6 530A      LD        A, L:0x530a
   \   000007 B7 ..        LD        S:?b3, A
   2114          
   2115            /* Disable the Channel 2: Reset the CCE Bit */
   2116            TIM5->CCER1 &=  (uint8_t)(~TIM_CCER1_CC2E);
   \   000009 7219 530B    BRES      L:0x530b, #0x4
   2117          
   2118            /* Select the Input and set the filter */
   2119            tmpccmr2 &= (uint8_t)(~TIM_CCMR_CCxS) & (uint8_t)(~TIM_CCMR_ICxF);
   \   00000D B6 ..        LD        A, S:?b3
   \   00000F A4 0C        AND       A, #0xc
   \   000011 B7 ..        LD        S:?b3, A
   2120            tmpccmr2 |= (uint8_t)(((uint8_t)(TIM5_ICSelection)) | ((uint8_t)(TIM5_ICFilter << 4)));
   \   000013 B6 ..        LD        A, S:?b1
   \   000015 4E           SWAP      A
   \   000016 A4 F0        AND       A, #0xf0
   \   000018 BA ..        OR        A, S:?b0
   \   00001A BA ..        OR        A, S:?b3
   \   00001C B7 ..        LD        S:?b3, A
   2121          
   2122            TIM5->CCMR2 = tmpccmr2;
   \   00001E B6 ..        LD        A, S:?b3
   \   000020 C7 530A      LD        L:0x530a, A
   2123          
   2124            /* Select the Polarity */
   2125            if (tmpicpolarity == TIM5_ICPolarity_Falling)
   \   000023 B6 ..        LD        A, S:?b2
   \   000025 A1 01        CP        A, #0x1
   \   000027 26 06        JRNE      L:??TI2_Config_0
   2126            {
   2127              TIM5->CCER1 |= TIM_CCER1_CC2P ;
   \   000029 721A 530B    BSET      L:0x530b, #0x5
   \   00002D 20 04        JRA       L:??TI2_Config_1
   2128            }
   2129            else
   2130            {
   2131              TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC2P) ;
   \                     ??TI2_Config_0:
   \   00002F 721B 530B    BRES      L:0x530b, #0x5
   2132            }
   2133          
   2134            /* Set the CCE Bit */
   2135            TIM5->CCER1 |=  TIM_CCER1_CC2E;
   \                     ??TI2_Config_1:
   \   000033 7218 530B    BSET      L:0x530b, #0x4
   2136          }
   \   000037 87           RETF
   2137          
   2138          /**
   2139            * @}
   2140            */ 
   2141          
   2142          /**
   2143            * @}
   2144            */ 
   2145            
   2146          /**
   2147            * @}
   2148            */
   2149          
   2150          /**
   2151            * @}
   2152            */
   2153          
   2154          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Section sizes:

   Bytes  Function/Label
   -----  --------------
      56  TI1_Config
      56  TI2_Config
      13  TIM5_ARRPreloadConfig
      22  TIM5_BKRConfig
      31  TIM5_CCxCmd
      13  TIM5_ClearFlag
       5  TIM5_ClearITPendingBit
      13  TIM5_Cmd
      27  TIM5_CounterModeConfig
      13  TIM5_CtrlPWMOutputs
      19  TIM5_DMACmd
     101  TIM5_DeInit
      37  TIM5_ETRClockMode1Config
       9  TIM5_ETRClockMode2Config
      15  TIM5_ETRConfig
     107  TIM5_EncoderInterfaceConfig
      27  TIM5_ForcedOC1Config
      27  TIM5_ForcedOC2Config
       7  TIM5_GenerateEvent
      34  TIM5_GetCapture1
      34  TIM5_GetCapture2
      34  TIM5_GetCounter
      39  TIM5_GetFlagStatus
      41  TIM5_GetITStatus
       4  TIM5_GetPrescaler
      39  TIM5_ICInit
      19  TIM5_ITConfig
       9  TIM5_InternalClockConfig
      13  TIM5_OC1FastConfig
      93  TIM5_OC1Init
      14  TIM5_OC1PolarityConfig
      13  TIM5_OC1PreloadConfig
      13  TIM5_OC2FastConfig
      93  TIM5_OC2Init
      14  TIM5_OC2PolarityConfig
      13  TIM5_OC2PreloadConfig
     131  TIM5_PWMIConfig
      19  TIM5_PrescalerConfig
      13  TIM5_SelectCCDMA
      13  TIM5_SelectHallSensor
      27  TIM5_SelectInputTrigger
      13  TIM5_SelectMasterSlaveMode
      45  TIM5_SelectOCxM
      14  TIM5_SelectOnePulseMode
      27  TIM5_SelectOutputTrigger
      27  TIM5_SelectSlaveMode
      15  TIM5_SetAutoreload
      15  TIM5_SetCompare1
      15  TIM5_SetCompare2
      15  TIM5_SetCounter
      27  TIM5_SetIC1Prescaler
      27  TIM5_SetIC2Prescaler
      48  TIM5_TIxExternalClockConfig
      42  TIM5_TimeBaseInit
      13  TIM5_UpdateDisableConfig
      14  TIM5_UpdateRequestConfig

 
 1 677 bytes in section .far_func.text
 
 1 677 bytes of CODE memory

Errors: none
Warnings: none
