###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.42.1.142 for STM8               01/Jul/2016  17:36:13 #
# Copyright 2010-2013 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  E:\hwpro-2016\20160627_L\utils\lib\ringbufindex.c        #
#    Command line =  E:\hwpro-2016\20160627_L\utils\lib\ringbufindex.c -e     #
#                    -Ol --no_cse --no_unroll --no_inline --no_code_motion    #
#                    --no_tbaa --no_cross_call --debug --code_model medium    #
#                    --data_model medium -o E:\hwpro-2016\20160627_L\iar\Debu #
#                    g\Obj\ --dlib_config "C:\Program Files (x86)\IAR         #
#                    Systems\Embedded Workbench 6.5\stm8\LIB\dlstm8mmn.h" -D  #
#                    STM8L15X_MD -lC E:\hwpro-2016\20160627_L\iar\Debug\List\ #
#                     -I E:\hwpro-2016\20160627_L\iar\..\stm8l15x_lib\inc\    #
#                    -I E:\hwpro-2016\20160627_L\iar\..\user\inc\ -I          #
#                    E:\hwpro-2016\20160627_L\iar\..\utils\xprintf\ -I        #
#                    E:\hwpro-2016\20160627_L\iar\..\drivers\ -I              #
#                    E:\hwpro-2016\20160627_L\iar\..\utils\ -I                #
#                    E:\hwpro-2016\20160627_L\iar\..\app\ --vregs 16          #
#    List file    =  E:\hwpro-2016\20160627_L\iar\Debug\List\ringbufindex.lst #
#    Object file  =  E:\hwpro-2016\20160627_L\iar\Debug\Obj\ringbufindex.o    #
#                                                                             #
#                                                                             #
###############################################################################

E:\hwpro-2016\20160627_L\utils\lib\ringbufindex.c
      1          /*
      2           * Copyright (c) 2015, SICS Swedish ICT.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without
      6           * modification, are permitted provided that the following conditions
      7           * are met:
      8           * 1. Redistributions of source code must retain the above copyright
      9           *    notice, this list of conditions and the following disclaimer.
     10           * 2. Redistributions in binary form must reproduce the above copyright
     11           *    notice, this list of conditions and the following disclaimer in the
     12           *    documentation and/or other materials provided with the distribution.
     13           * 3. Neither the name of the Institute nor the names of its contributors
     14           *    may be used to endorse or promote products derived from this software
     15           *    without specific prior written permission.
     16           *
     17           * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
     18           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     19           * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     20           * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
     21           * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     22           * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
     23           * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
     24           * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
     25           * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
     26           * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
     27           * SUCH DAMAGE.
     28           *
     29           * This file is part of the Contiki operating system.
     30           *
     31           */
     32          
     33          /**
     34           * \file
     35           *         ringbufindex library. Implements basic support for ring buffers
     36           *         of any type, as opposed to the core/lib/ringbuf module which
     37           *         is only for byte arrays. Simply returns index in the ringbuf
     38           *         rather than actual elements. The ringbuf size must be power of two.
     39           *         Like the original ringbuf, this module implements atomic put and get.
     40           * \author
     41           *         Simon Duquennoy <simonduq@sics.se>
     42           *         based on Contiki's core/lib/ringbuf library by Adam Dunkels
     43           */
     44          
     45          #include <string.h>
     46          #include "lib/ringbufindex.h"
     47          
     48          /* Initialize a ring buffer. The size must be a power of two */

   \                                 In section .far_func.text, align 1
     49          void
     50          ringbufindex_init(struct ringbufindex *r, uint8_t size)
     51          {
     52            r->mask = size - 1;
   \                     ringbufindex_init:
   \   000000 AB FF        ADD       A, #0xff
   \   000002 F7           LD        (X), A
     53            r->put_ptr = 0;
   \   000003 9093         LDW       Y, X
   \   000005 905C         INCW      Y
   \   000007 4F           CLR       A
   \   000008 90F7         LD        (Y), A
     54            r->get_ptr = 0;
   \   00000A 1C 0002      ADDW      X, #0x2
   \   00000D 4F           CLR       A
   \   00000E F7           LD        (X), A
     55          }
   \   00000F 87           RETF
     56          /* Put one element to the ring buffer */

   \                                 In section .far_func.text, align 1
     57          int
     58          ringbufindex_put(struct ringbufindex *r)
     59          {
     60            /* Check if buffer is full. If it is full, return 0 to indicate that
     61               the element was not inserted.
     62          
     63               XXX: there is a potential risk for a race condition here, because
     64               the ->get_ptr field may be written concurrently by the
     65               ringbufindex_get() function. To avoid this, access to ->get_ptr must
     66               be atomic. We use an uint8_t type, which makes access atomic on
     67               most platforms, but C does not guarantee this.
     68             */
     69            if(((r->put_ptr - r->get_ptr) & r->mask) == r->mask) {
   \                     ringbufindex_put:
   \   000000 9093         LDW       Y, X
   \   000002 72A9 0002    ADDW      Y, #0x2
   \   000006 90BF ..      LDW       S:?w0, Y
   \   000009 9093         LDW       Y, X
   \   00000B 905C         INCW      Y
   \   00000D 90F6         LD        A, (Y)
   \   00000F 92C0 ..      SUB       A, [S:?w0.w]
   \   000012 F4           AND       A, (X)
   \   000013 F1           CP        A, (X)
   \   000014 26 02        JRNE      L:??ringbufindex_put_0
     70              return 0;
   \   000016 5F           CLRW      X
   \   000017 87           RETF
     71            }
     72            r->put_ptr = (r->put_ptr + 1) & r->mask;
   \                     ??ringbufindex_put_0:
   \   000018 9093         LDW       Y, X
   \   00001A 905C         INCW      Y
   \   00001C 90F6         LD        A, (Y)
   \   00001E AB 01        ADD       A, #0x1
   \   000020 F4           AND       A, (X)
   \   000021 5C           INCW      X
   \   000022 F7           LD        (X), A
     73            return 1;
   \   000023 5F           CLRW      X
   \   000024 5C           INCW      X
   \   000025 87           RETF
     74          }
     75          /* Check if there is space to put an element.
     76           * Return the index where the next element is to be added */

   \                                 In section .far_func.text, align 1
     77          int
     78          ringbufindex_peek_put(const struct ringbufindex *r)
     79          {
     80            /* Check if there are bytes in the buffer. If so, we return the
     81               first one. If there are no bytes left, we return -1.
     82             */
     83            if(((r->put_ptr - r->get_ptr) & r->mask) == r->mask) {
   \                     ringbufindex_peek_put:
   \   000000 9093         LDW       Y, X
   \   000002 72A9 0002    ADDW      Y, #0x2
   \   000006 90BF ..      LDW       S:?w0, Y
   \   000009 9093         LDW       Y, X
   \   00000B 905C         INCW      Y
   \   00000D 90F6         LD        A, (Y)
   \   00000F 92C0 ..      SUB       A, [S:?w0.w]
   \   000012 F4           AND       A, (X)
   \   000013 F1           CP        A, (X)
   \   000014 26 03        JRNE      L:??ringbufindex_peek_put_0
     84              return -1;
   \   000016 5F           CLRW      X
   \   000017 5A           DECW      X
   \   000018 87           RETF
     85            }
     86            return (r->put_ptr + 1) & r->mask;
   \                     ??ringbufindex_peek_put_0:
   \   000019 9093         LDW       Y, X
   \   00001B 905C         INCW      Y
   \   00001D 90F6         LD        A, (Y)
   \   00001F 905F         CLRW      Y
   \   000021 9097         LD        YL, A
   \   000023 905C         INCW      Y
   \   000025 F6           LD        A, (X)
   \   000026 5F           CLRW      X
   \   000027 97           LD        XL, A
   \   000028 BF ..        LDW       S:?w0, X
   \   00002A 93           LDW       X, Y
   \   00002B 01           RRWA      X, A
   \   00002C B4 ..        AND       A, S:?b1
   \   00002E 01           RRWA      X, A
   \   00002F B4 ..        AND       A, S:?b0
   \   000031 01           RRWA      X, A
   \   000032 87           RETF
     87          }
     88          /* Remove the first element and return its index */

   \                                 In section .far_func.text, align 1
     89          int
     90          ringbufindex_get(struct ringbufindex *r)
     91          {
   \                     ringbufindex_get:
   \   000000 BF ..        LDW       S:?w0, X
     92            int get_ptr;
     93          
     94            /* Check if there are bytes in the buffer. If so, we return the
     95               first one and increase the pointer. If there are no bytes left, we
     96               return -1.
     97          
     98               XXX: there is a potential risk for a race condition here, because
     99               the ->put_ptr field may be written concurrently by the
    100               ringbufindex_put() function. To avoid this, access to ->get_ptr must
    101               be atomic. We use an uint8_t type, which makes access atomic on
    102               most platforms, but C does not guarantee this.
    103             */
    104            if(((r->put_ptr - r->get_ptr) & r->mask) > 0) {
   \   000002 BE ..        LDW       X, S:?w0
   \   000004 1C 0002      ADDW      X, #0x2
   \   000007 9093         LDW       Y, X
   \   000009 BE ..        LDW       X, S:?w0
   \   00000B 5C           INCW      X
   \   00000C F6           LD        A, (X)
   \   00000D 90F0         SUB       A, (Y)
   \   00000F 92C4 ..      AND       A, [S:?w0.w]
   \   000012 A1 01        CP        A, #0x1
   \   000014 25 20        JRC       L:??ringbufindex_get_0
    105              get_ptr = r->get_ptr;
   \   000016 BE ..        LDW       X, S:?w0
   \   000018 1C 0002      ADDW      X, #0x2
   \   00001B F6           LD        A, (X)
   \   00001C 5F           CLRW      X
   \   00001D 97           LD        XL, A
    106              r->get_ptr = (r->get_ptr + 1) & r->mask;
   \   00001E 90BE ..      LDW       Y, S:?w0
   \   000021 72A9 0002    ADDW      Y, #0x2
   \   000025 90F6         LD        A, (Y)
   \   000027 AB 01        ADD       A, #0x1
   \   000029 92C4 ..      AND       A, [S:?w0.w]
   \   00002C 90BE ..      LDW       Y, S:?w0
   \   00002F 72A9 0002    ADDW      Y, #0x2
   \   000033 90F7         LD        (Y), A
    107              return get_ptr;
   \   000035 87           RETF
    108            } else {
    109              return -1;
   \                     ??ringbufindex_get_0:
   \   000036 5F           CLRW      X
   \   000037 5A           DECW      X
   \   000038 87           RETF
    110            }
    111          }
    112          /* Return the index of the first element
    113           * (which will be removed if calling ringbufindex_peek) */

   \                                 In section .far_func.text, align 1
    114          int
    115          ringbufindex_peek_get(const struct ringbufindex *r)
    116          {
   \                     ringbufindex_peek_get:
   \   000000 9093         LDW       Y, X
    117            /* Check if there are bytes in the buffer. If so, we return the
    118               first one. If there are no bytes left, we return -1.
    119             */
    120            if(((r->put_ptr - r->get_ptr) & r->mask) > 0) {
   \   000002 93           LDW       X, Y
   \   000003 1C 0002      ADDW      X, #0x2
   \   000006 BF ..        LDW       S:?w0, X
   \   000008 93           LDW       X, Y
   \   000009 5C           INCW      X
   \   00000A F6           LD        A, (X)
   \   00000B 92C0 ..      SUB       A, [S:?w0.w]
   \   00000E 90F4         AND       A, (Y)
   \   000010 A1 01        CP        A, #0x1
   \   000012 25 19        JRC       L:??ringbufindex_peek_get_0
    121              return (r->get_ptr + 1) & r->mask;
   \   000014 93           LDW       X, Y
   \   000015 1C 0002      ADDW      X, #0x2
   \   000018 F6           LD        A, (X)
   \   000019 5F           CLRW      X
   \   00001A 97           LD        XL, A
   \   00001B 5C           INCW      X
   \   00001C 90F6         LD        A, (Y)
   \   00001E 905F         CLRW      Y
   \   000020 9097         LD        YL, A
   \   000022 90BF ..      LDW       S:?w0, Y
   \   000025 01           RRWA      X, A
   \   000026 B4 ..        AND       A, S:?b1
   \   000028 01           RRWA      X, A
   \   000029 B4 ..        AND       A, S:?b0
   \   00002B 01           RRWA      X, A
   \   00002C 87           RETF
    122            } else {
    123              return -1;
   \                     ??ringbufindex_peek_get_0:
   \   00002D 5F           CLRW      X
   \   00002E 5A           DECW      X
   \   00002F 87           RETF
    124            }
    125          }
    126          /* Return the ring buffer size */

   \                                 In section .far_func.text, align 1
    127          int
    128          ringbufindex_size(const struct ringbufindex *r)
    129          {
    130            return r->mask + 1;
   \                     ringbufindex_size:
   \   000000 F6           LD        A, (X)
   \   000001 5F           CLRW      X
   \   000002 97           LD        XL, A
   \   000003 5C           INCW      X
   \   000004 87           RETF
    131          }
    132          /* Return the number of elements currently in the ring buffer */

   \                                 In section .far_func.text, align 1
    133          int
    134          ringbufindex_elements(const struct ringbufindex *r)
    135          {
   \                     ringbufindex_elements:
   \   000000 9093         LDW       Y, X
    136            return (r->put_ptr - r->get_ptr) & r->mask;
   \   000002 93           LDW       X, Y
   \   000003 1C 0002      ADDW      X, #0x2
   \   000006 F6           LD        A, (X)
   \   000007 5F           CLRW      X
   \   000008 97           LD        XL, A
   \   000009 BF ..        LDW       S:?w0, X
   \   00000B 93           LDW       X, Y
   \   00000C 5C           INCW      X
   \   00000D F6           LD        A, (X)
   \   00000E 5F           CLRW      X
   \   00000F 97           LD        XL, A
   \   000010 72B0 ....    SUBW      X, S:?w0
   \   000014 90F6         LD        A, (Y)
   \   000016 905F         CLRW      Y
   \   000018 9097         LD        YL, A
   \   00001A 90BF ..      LDW       S:?w0, Y
   \   00001D 01           RRWA      X, A
   \   00001E B4 ..        AND       A, S:?b1
   \   000020 01           RRWA      X, A
   \   000021 B4 ..        AND       A, S:?b0
   \   000023 01           RRWA      X, A
   \   000024 87           RETF
    137          }
    138          /* Is the ring buffer full? */

   \                                 In section .far_func.text, align 1
    139          int
    140          ringbufindex_full(const struct ringbufindex *r)
    141          {
   \                     ringbufindex_full:
   \   000000 BF ..        LDW       S:?w0, X
    142            return ((r->put_ptr - r->get_ptr) & r->mask) == r->mask;
   \   000002 90BE ..      LDW       Y, S:?w0
   \   000005 72A9 0002    ADDW      Y, #0x2
   \   000009 BE ..        LDW       X, S:?w0
   \   00000B 5C           INCW      X
   \   00000C F6           LD        A, (X)
   \   00000D 90F0         SUB       A, (Y)
   \   00000F 92C4 ..      AND       A, [S:?w0.w]
   \   000012 92C1 ..      CP        A, [S:?w0.w]
   \   000015 26 04        JRNE      L:??ringbufindex_full_0
   \   000017 A6 01        LD        A, #0x1
   \   000019 20 01        JRA       L:??ringbufindex_full_1
   \                     ??ringbufindex_full_0:
   \   00001B 4F           CLR       A
   \                     ??ringbufindex_full_1:
   \   00001C 5F           CLRW      X
   \   00001D 97           LD        XL, A
   \   00001E 87           RETF
    143          }
    144          /* Is the ring buffer empty? */

   \                                 In section .far_func.text, align 1
    145          int
    146          ringbufindex_empty(const struct ringbufindex *r)
    147          {
    148            return ringbufindex_elements(r) == 0;
   \                     ringbufindex_empty:
   \   000000 8D ......    CALLF     ringbufindex_elements
   \   000004 5D           TNZW      X
   \   000005 26 04        JRNE      L:??ringbufindex_empty_0
   \   000007 A6 01        LD        A, #0x1
   \   000009 20 01        JRA       L:??ringbufindex_empty_1
   \                     ??ringbufindex_empty_0:
   \   00000B 4F           CLR       A
   \                     ??ringbufindex_empty_1:
   \   00000C 5F           CLRW      X
   \   00000D 97           LD        XL, A
   \   00000E 87           RETF
    149          }

   Section sizes:

   Bytes  Function/Label
   -----  --------------
      37  ringbufindex_elements
      15  ringbufindex_empty
      31  ringbufindex_full
      57  ringbufindex_get
      16  ringbufindex_init
      48  ringbufindex_peek_get
      51  ringbufindex_peek_put
      38  ringbufindex_put
       5  ringbufindex_size

 
 298 bytes in section .far_func.text
 
 298 bytes of CODE memory

Errors: none
Warnings: none
