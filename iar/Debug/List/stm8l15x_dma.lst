###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.42.1.142 for STM8               01/Jul/2016  17:30:47 #
# Copyright 2010-2013 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  E:\hwpro-2016\20160627_L\stm8l15x_lib\src\stm8l15x_dma.c #
#    Command line =  E:\hwpro-2016\20160627_L\stm8l15x_lib\src\stm8l15x_dma.c #
#                     -e -Ol --no_cse --no_unroll --no_inline                 #
#                    --no_code_motion --no_tbaa --no_cross_call --debug       #
#                    --code_model medium --data_model medium -o               #
#                    E:\hwpro-2016\20160627_L\iar\Debug\Obj\ --dlib_config    #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.5\stm8\LIB\dlstm8mmn.h" -D STM8L15X_MD -lC             #
#                    E:\hwpro-2016\20160627_L\iar\Debug\List\ -I              #
#                    E:\hwpro-2016\20160627_L\iar\..\stm8l15x_lib\inc\ -I     #
#                    E:\hwpro-2016\20160627_L\iar\..\user\inc\ -I             #
#                    E:\hwpro-2016\20160627_L\iar\..\utils\xprintf\ -I        #
#                    E:\hwpro-2016\20160627_L\iar\..\drivers\ -I              #
#                    E:\hwpro-2016\20160627_L\iar\..\utils\ -I                #
#                    E:\hwpro-2016\20160627_L\iar\..\app\ --vregs 16          #
#    List file    =  E:\hwpro-2016\20160627_L\iar\Debug\List\stm8l15x_dma.lst #
#    Object file  =  E:\hwpro-2016\20160627_L\iar\Debug\Obj\stm8l15x_dma.o    #
#                                                                             #
#                                                                             #
###############################################################################

E:\hwpro-2016\20160627_L\stm8l15x_lib\src\stm8l15x_dma.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm8l15x_dma.c
      4            * @author  MCD Application Team
      5            * @version V1.6.1
      6            * @date    30-September-2014
      7            * @brief   This file provides all the DMA firmware functions.
      8           * @brief   This file provides firmware functions to manage the following 
      9            *          functionalities of the Direct Memory Access controller (DMA):           
     10            *           - Initialization and Configuration
     11            *           - Data Counter
     12            *           - Interrupts and flags management
     13            *           
     14            *  @verbatim
     15            *      
     16            *          ===================================================================      
     17            *                                 How to use this driver
     18            *          =================================================================== 
     19            *          1. Enable The DMA controller clock using CLK_PeripheralClockConfig() 
     20            *            function: CLK_PeripheralClockConfig(CLK_Peripheral_DMA1, ENABLE).
     21            *
     22            *          2. Enable and configure the peripheral to be connected to the DMA 
     23            *            channel (except for internal SRAM / FLASH memories: no 
     24            *            initialization is necessary). 
     25            *        
     26            *          3. For a given Channel, program the Source and Destination 
     27            *             addresses, the transfer Direction, the Buffer Size, the 
     28            *             Peripheral and Memory Incrementation mode and Data Size, 
     29            *             the Circular or Normal mode, the channel transfer Priority 
     30            *             and the Memory-to-Memory transfer mode (for channel 3 only, 
     31            *             if needed) using the DMA_Init() function.
     32            *
     33            *          4. Enable the corresponding interrupt(s) using the function 
     34            *             DMA_ITConfig() if you need to use DMA interrupts. 
     35            *
     36            *          5. Enable the DMA channel using the DMA_Cmd() function. 
     37            *                
     38            *          6. Activate the needed channel Request using PPP_DMACmd() function 
     39            *            for any PPP peripheral except internal SRAM and FLASH (ie. TIM4, 
     40            *             USART ...). The function allowing this operation is provided in 
     41            *             each PPP peripheral driver (ie. TIM4_DMACmd for TIM4 peripheral).     
     42            *
     43            *          7. Optionally, you can configure the number of data to be 
     44            *             transferred when the channel is disabled (ie. after each 
     45            *             Transfer Complete event or when a Transfer Error occurs) using 
     46            *             the function DMA_SetCurrDataCounter().
     47            *             And you can get the number of remaining data to be transferred 
     48            *             using the function DMA_GetCurrDataCounter() at run time (when 
     49            *             the DMA channel is enabled and running).  
     50            *                   
     51            *          8. To control DMA events you can use one of the following 
     52            *              two methods:
     53            *               a- Check on DMA channel flags using the function 
     54            *                  DMA_GetFlagStatus().  
     55            *               b- Use DMA interrupts through the function DMA_ITConfig() 
     56            *                   at initialization phase and DMA_GetITStatus() function 
     57            *                   into interrupt routines in communication phase.  
     58            *              After checking on a flag you should clear it using 
     59            *              DMA_ClearFlag() function. And after checking on an interrupt 
     60            *              event you should clear it using DMA_ClearITPendingBit() 
     61            *              function.     
     62            *                 
     63            *  @endverbatim
     64            *                                  
     65            ******************************************************************************
     66            * @attention
     67            *
     68            * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
     69            *
     70            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     71            * You may not use this file except in compliance with the License.
     72            * You may obtain a copy of the License at:
     73            *
     74            *        http://www.st.com/software_license_agreement_liberty_v2
     75            *
     76            * Unless required by applicable law or agreed to in writing, software 
     77            * distributed under the License is distributed on an "AS IS" BASIS, 
     78            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     79            * See the License for the specific language governing permissions and
     80            * limitations under the License.
     81            *
     82            ******************************************************************************
     83            */ 
     84          
     85          /* Includes ------------------------------------------------------------------*/
     86          #include "stm8l15x_dma.h"
     87          
     88          /** @addtogroup STM8L15x_StdPeriph_Driver
     89            * @{
     90            */
     91          
     92          /** @defgroup DMA 
     93            * @brief  DMA driver modules
     94            * @{
     95            */ 
     96          /* Private typedef -----------------------------------------------------------*/
     97          /* Private define ------------------------------------------------------------*/
     98          /* Private macro -------------------------------------------------------------*/
     99          /* Private variables ---------------------------------------------------------*/
    100          /* Private function prototypes -----------------------------------------------*/
    101          /* Private functions ---------------------------------------------------------*/
    102          
    103          /** @defgroup DMA_Private_Functions
    104            * @{
    105            */ 
    106          
    107          /** @defgroup DMA_Group1 Initialization and Configuration functions
    108           *  @brief   Initialization and Configuration functions
    109           *
    110          @verbatim   
    111           ===============================================================================
    112                           Initialization and Configuration functions
    113           ===============================================================================  
    114          
    115            This subsection provides functions allowing to initialize the DMA channel 
    116            source and destination addresses, incrementation and data sizes, transfer 
    117            direction, buffer size, circular/normal mode selection, memory-to-memory mode 
    118            selection and channel priority value.
    119            
    120            - The DMA_Init() function follows the DMA configuration procedures.
    121            - All DMA channels can be enabled and disabled in the same time using 
    122              DMA_GlobalCmd() function.
    123            - The DMA has 4 channels, User can enable or disable channels using 
    124              DMA_Cmd() function.
    125            - The timeout duration (number of wait cycles starting from the latest 
    126              request) is configured using DMA_SetTimeOut() function. The DMA then waits 
    127              until this timeout has elapsed before requesting from the core a high 
    128              priority access to the bus. 
    129          
    130          @endverbatim
    131            * @{
    132            */
    133          
    134          /**
    135            * @brief  Deinitializes the DMA Global Status register to its default reset
    136            *         values.
    137            * @param  None
    138            * @retval None
    139            */

   \                                 In section .far_func.text, align 1
    140          void DMA_GlobalDeInit(void)
    141          {
    142            /* Disable the  DMA    */
    143            DMA1->GCSR &= (uint8_t)~(DMA_GCSR_GE);
   \                     DMA_GlobalDeInit:
   \   000000 7211 5070    BRES      L:0x5070, #0x0
    144          
    145            /* Reset DMA Channelx control register */
    146            DMA1->GCSR  = (uint8_t)DMA_GCSR_RESET_VALUE;
   \   000004 35 FC 5070   MOV       L:0x5070, #0xfc
    147          }
   \   000008 87           RETF
    148          
    149          /**
    150            * @brief  Deinitializes the DMA Channelx registers to their default reset 
    151            *         values.
    152            * @param  DMA_Channelx: selects the DMA Channelx where x can be 0 to 3
    153            * @retval None
    154            */

   \                                 In section .far_func.text, align 1
    155          void DMA_DeInit(DMA_Channel_TypeDef* DMA_Channelx)
    156          {
    157            /* Check the parameters */
    158            assert_param(IS_DMA_CHANNEL(DMA_Channelx));
    159          
    160            /* Disable the selected DMA Channelx */
    161            DMA_Channelx->CCR &= (uint8_t)~(DMA_CCR_CE);
   \                     DMA_DeInit:
   \   000000 F6           LD        A, (X)
   \   000001 A4 FE        AND       A, #0xfe
   \   000003 F7           LD        (X), A
    162          
    163            /* Reset DMA Channelx control register */
    164            DMA_Channelx->CCR  = DMA_CCR_RESET_VALUE;
   \   000004 4F           CLR       A
   \   000005 F7           LD        (X), A
    165          
    166            /* Reset DMA Channelx remaining bytes register */
    167            DMA_Channelx->CNBTR = DMA_CNBTR_RESET_VALUE;
   \   000006 9093         LDW       Y, X
   \   000008 72A9 0002    ADDW      Y, #0x2
   \   00000C 4F           CLR       A
   \   00000D 90F7         LD        (Y), A
    168          
    169            /* Reset DMA Channelx peripheral address register */
    170            if (DMA_Channelx == DMA1_Channel3)
   \   00000F A3 5093      CPW       X, #0x5093
   \   000012 26 15        JRNE      L:??DMA_DeInit_0
    171            {
    172              DMA_Channelx->CPARH  = DMA_C3PARH_RESET_VALUE;
   \   000014 9093         LDW       Y, X
   \   000016 72A9 0003    ADDW      Y, #0x3
   \   00001A A6 40        LD        A, #0x40
   \   00001C 90F7         LD        (Y), A
    173              DMA_Channelx->CM0EAR = DMA_C3M0EAR_RESET_VALUE;
   \   00001E 9093         LDW       Y, X
   \   000020 72A9 0005    ADDW      Y, #0x5
   \   000024 4F           CLR       A
   \   000025 90F7         LD        (Y), A
   \   000027 20 0A        JRA       L:??DMA_DeInit_1
    174            }
    175            else
    176            {
    177              DMA_Channelx->CPARH  = DMA_CPARH_RESET_VALUE;
   \                     ??DMA_DeInit_0:
   \   000029 9093         LDW       Y, X
   \   00002B 72A9 0003    ADDW      Y, #0x3
   \   00002F A6 52        LD        A, #0x52
   \   000031 90F7         LD        (Y), A
    178            }
    179            DMA_Channelx->CPARL  = DMA_CPARL_RESET_VALUE;
   \                     ??DMA_DeInit_1:
   \   000033 9093         LDW       Y, X
   \   000035 72A9 0004    ADDW      Y, #0x4
   \   000039 4F           CLR       A
   \   00003A 90F7         LD        (Y), A
    180          
    181            /* Reset DMA Channelx memory address register */
    182            DMA_Channelx->CM0ARH = DMA_CM0ARH_RESET_VALUE;
   \   00003C 9093         LDW       Y, X
   \   00003E 72A9 0006    ADDW      Y, #0x6
   \   000042 4F           CLR       A
   \   000043 90F7         LD        (Y), A
    183            DMA_Channelx->CM0ARL = DMA_CM0ARL_RESET_VALUE;
   \   000045 9093         LDW       Y, X
   \   000047 72A9 0007    ADDW      Y, #0x7
   \   00004B 4F           CLR       A
   \   00004C 90F7         LD        (Y), A
    184          
    185            /* Reset interrupt pending bits for DMA Channel */
    186            DMA_Channelx->CSPR = DMA_CSPR_RESET_VALUE;
   \   00004E 5C           INCW      X
   \   00004F 4F           CLR       A
   \   000050 F7           LD        (X), A
    187          }
   \   000051 87           RETF
    188          
    189          
    190          /**
    191            * @brief  Initializes the DMA Channelx according to the specified parameters.
    192            * @param  DMA_Channelx: selects the DMA Channelx where x can be 0 to 3
    193            * @param  DMA_Memory0BaseAddr: Specifies  Memory 0 Base Address
    194            * @param  DMA_PeripheralMemory1BaseAddr: Specifies DMA channelx Peripheral 
    195            *         Base Address (if data is from/to  peripheral) or DMA channelx 
    196            *         Memory1 Base Address (if data is from Memory0 to Memory1).
    197            * @param  DMA_BufferSize: Specifies the size of the DMA channelx Buffer.
    198            *         This parameter must be a value greater than 0.
    199            * @param  DMA_DIR: Specifies the DMA Channelx transfer direction.
    200            *          This parameter can be one of the following values:
    201            *            @arg DMA_DIR_PeripheralToMemory: Data transfer direction is Peripheral To Memory
    202            *            @arg DMA_DIR_MemoryToPeripheral: Data transfer direction is Memory To Peripheral
    203            *            @arg DMA_DIR_Memory0ToMemory1: Data transfer direction is Memory0 To Memory 1    
    204            * @param  DMA_Mode: Specifies the DMA channelx mode.
    205            *          This parameter can be one of the following values:
    206            *            @arg DMA_Mode_Normal: DMA normal buffer mode
    207            *            @arg DMA_Mode_Circular: DMA circular buffer mode
    208            * @param  DMA_MemoryIncMode: Specifies the DMA channelx memory Incremental/Decremental mode 
    209            *          This parameter can be one of the following values:
    210            *            @arg DMA_MemoryIncMode_Dec: DMA memory incremented mode is decremental
    211            *            @arg DMA_MemoryIncMode_Inc: DMA memory incremented mode is incremental  
    212            * @param  DMA_Priority: Specifies the DMA channelx priority.
    213            *          This parameter can be one of the following values:
    214            *            @arg DMA_Priority_Low: Software Priority is Low
    215            *            @arg DMA_Priority_Medium: Software Priority is Medium
    216            *            @arg DMA_Priority_High: Software Priority is High
    217            *            @arg DMA_Priority_VeryHigh: Software Priority is Very High
    218            * @param  DMA_MemoryDataSize: Specifies the DMA channelx transfer Data size
    219            *          This parameter can be one of the following values:
    220            *            @arg DMA_MemoryDataSize_Byte: Memory Data Size is 1 Byte
    221            *            @arg DMA_MemoryDataSize_HalfWord: Memory Data Size is 2 Bytes  
    222            * @retval None
    223            */

   \                                 In section .far_func.text, align 1
    224          void DMA_Init(DMA_Channel_TypeDef* DMA_Channelx,
    225                        uint32_t DMA_Memory0BaseAddr,
    226                        uint16_t DMA_PeripheralMemory1BaseAddr,
    227                        uint8_t DMA_BufferSize,
    228                        DMA_DIR_TypeDef DMA_DIR,
    229                        DMA_Mode_TypeDef DMA_Mode,
    230                        DMA_MemoryIncMode_TypeDef DMA_MemoryIncMode,
    231                        DMA_Priority_TypeDef DMA_Priority,
    232                        DMA_MemoryDataSize_TypeDef DMA_MemoryDataSize )
    233          {
   \                     DMA_Init:
   \   000000 8D ......    CALLF     L:?push_l2
   \   000004 8D ......    CALLF     L:?push_w6
   \   000008 BF ..        LDW       S:?w6, X
   \   00000A 8D ......    CALLF     L:?mov_l2_l0
   \   00000E B7 ..        LD        S:?b0, A
    234            /* Check the parameters */
    235            assert_param(IS_DMA_CHANNEL(DMA_Channelx));
    236            assert_param(IS_DMA_DIR(DMA_DIR));
    237            assert_param(IS_DMA_BUFFER_SIZE(DMA_BufferSize));
    238            assert_param(IS_DMA_MODE(DMA_Mode));
    239            assert_param(IS_DMA_MEMORY_INC_MODE(DMA_MemoryIncMode));
    240            assert_param(IS_DMA_PRIORITY(DMA_Priority));
    241          
    242            /*--------------------------- DMA Channelx CCR Configuration ---------------*/
    243            /* Disable the selected DMA Channelx */
    244            DMA_Channelx->CCR &= (uint8_t)~(DMA_CCR_CE);
   \   000010 92C6 ..      LD        A, [S:?w6.w]
   \   000013 A4 FE        AND       A, #0xfe
   \   000015 92C7 ..      LD        [S:?w6.w], A
    245          
    246            /* Reset DMA Channelx control register */
    247            DMA_Channelx->CCR  = DMA_CCR_RESET_VALUE;
   \   000018 4F           CLR       A
   \   000019 92C7 ..      LD        [S:?w6.w], A
    248          
    249            /* Set DMA direction & Mode & Incremental Memory mode */
    250            DMA_Channelx->CCR |= (uint8_t)((uint8_t)((uint8_t)DMA_DIR | \
    251                                                     (uint8_t)DMA_Mode) | \
    252                                                     (uint8_t)DMA_MemoryIncMode);
   \   00001C B6 ..        LD        A, S:?b5
   \   00001E BA ..        OR        A, S:?b4
   \   000020 BA ..        OR        A, S:?b6
   \   000022 92CA ..      OR        A, [S:?w6.w]
   \   000025 92C7 ..      LD        [S:?w6.w], A
    253          
    254            /*Clear old priority and memory data size  option */
    255            DMA_Channelx->CSPR &= (uint8_t)(~(uint8_t)(DMA_CSPR_PL | DMA_CSPR_16BM));
   \   000028 BE ..        LDW       X, S:?w6
   \   00002A 5C           INCW      X
   \   00002B F6           LD        A, (X)
   \   00002C A4 C7        AND       A, #0xc7
   \   00002E BE ..        LDW       X, S:?w6
   \   000030 5C           INCW      X
   \   000031 F7           LD        (X), A
    256          
    257            /* Set old priority and memory data size  option */
    258            DMA_Channelx->CSPR |= (uint8_t)((uint8_t)DMA_Priority | \
    259                                            (uint8_t)DMA_MemoryDataSize);
   \   000032 7B 0A        LD        A, (0xa,SP)
   \   000034 BA ..        OR        A, S:?b7
   \   000036 BE ..        LDW       X, S:?w6
   \   000038 5C           INCW      X
   \   000039 FA           OR        A, (X)
   \   00003A BE ..        LDW       X, S:?w6
   \   00003C 5C           INCW      X
   \   00003D F7           LD        (X), A
    260          
    261            /*--------------------------- DMA Channelx CNDTR Configuration -------------*/
    262            /* Write to DMA Channelx CNDTR */
    263            DMA_Channelx->CNBTR = (uint8_t)DMA_BufferSize;
   \   00003E BE ..        LDW       X, S:?w6
   \   000040 1C 0002      ADDW      X, #0x2
   \   000043 B6 ..        LD        A, S:?b0
   \   000045 F7           LD        (X), A
    264          
    265            /*--------------------------- DMA Channelx CPAR Configuration --------------*/
    266            /* Write to DMA Channelx (0, 1 or 2)  Peripheral address  or  Write to 
    267            DMA Channel 3 Memory 1 address  */
    268            DMA_Channelx->CPARH = (uint8_t)(DMA_PeripheralMemory1BaseAddr >> (uint8_t)8);
   \   000046 93           LDW       X, Y
   \   000047 4F           CLR       A
   \   000048 01           RRWA      X, A
   \   000049 9F           LD        A, XL
   \   00004A BE ..        LDW       X, S:?w6
   \   00004C 1C 0003      ADDW      X, #0x3
   \   00004F F7           LD        (X), A
    269            DMA_Channelx->CPARL = (uint8_t)(DMA_PeripheralMemory1BaseAddr);
   \   000050 BE ..        LDW       X, S:?w6
   \   000052 1C 0004      ADDW      X, #0x4
   \   000055 909F         LD        A, YL
   \   000057 F7           LD        (X), A
    270          
    271            /*--------------------------- DMA Channelx CMAR Configuration --------------*/
    272            /* Write to DMA Channelx Memory address */
    273            if (DMA_Channelx == DMA1_Channel3)
   \   000058 BE ..        LDW       X, S:?w6
   \   00005A A3 5093      CPW       X, #0x5093
   \   00005D 26 12        JRNE      L:??DMA_Init_0
    274            {
    275              DMA_Channelx->CM0EAR = (uint8_t)(DMA_Memory0BaseAddr >> (uint8_t)16);
   \   00005F 8D ......    CALLF     L:?mov_l0_l2
   \   000063 A6 10        LD        A, #0x10
   \   000065 8D ......    CALLF     L:?srl32_l0_l0_a
   \   000069 B6 ..        LD        A, S:?b3
   \   00006B BE ..        LDW       X, S:?w6
   \   00006D 1C 0005      ADDW      X, #0x5
   \   000070 F7           LD        (X), A
    276            }
    277            DMA_Channelx->CM0ARH = (uint8_t)(DMA_Memory0BaseAddr >> (uint8_t)8);
   \                     ??DMA_Init_0:
   \   000071 BE ..        LDW       X, S:?w5
   \   000073 4F           CLR       A
   \   000074 01           RRWA      X, A
   \   000075 9F           LD        A, XL
   \   000076 BE ..        LDW       X, S:?w6
   \   000078 1C 0006      ADDW      X, #0x6
   \   00007B F7           LD        (X), A
    278            DMA_Channelx->CM0ARL = (uint8_t)(DMA_Memory0BaseAddr);
   \   00007C B6 ..        LD        A, S:?b11
   \   00007E BE ..        LDW       X, S:?w6
   \   000080 1C 0007      ADDW      X, #0x7
   \   000083 F7           LD        (X), A
    279          
    280          }
   \   000084 AC ......    JPF       L:?epilogue_l2_w6
    281          
    282          /**
    283            * @brief  Enables or disables All the DMA.
    284            * @param  NewState: new state of the DMA. This parameter can be: ENABLE 
    285            *                   or DISABLE.
    286            * @retval None
    287            */

   \                                 In section .far_func.text, align 1
    288          void DMA_GlobalCmd(FunctionalState NewState)
    289          {
    290            /* Check the parameters */
    291            assert_param(IS_FUNCTIONAL_STATE(NewState));
    292          
    293            if (NewState != DISABLE)
   \                     DMA_GlobalCmd:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??DMA_GlobalCmd_0
    294            {
    295              /* Enable the  DMA      */
    296              DMA1->GCSR |= (uint8_t)DMA_GCSR_GE;
   \   000003 7210 5070    BSET      L:0x5070, #0x0
   \   000007 87           RETF
    297            }
    298            else
    299            {
    300              /* Disable the DMA */
    301              DMA1->GCSR &= (uint8_t)(~DMA_GCSR_GE);
   \                     ??DMA_GlobalCmd_0:
   \   000008 7211 5070    BRES      L:0x5070, #0x0
    302            }
    303          }
   \   00000C 87           RETF
    304          
    305          /**
    306            * @brief  Enables or disables the specified DMA Channelx.
    307            * @note   DMA_GlobalCmd function must be called first to enable or disable
    308            *         the global DMA.
    309            * @param  DMA_Channelx: selects the DMA Channelx where x can be 0 to 3
    310            * @param  NewState: new state of the DMA Channelx.
    311              *         This parameter can be: ENABLE or DISABLE.
    312            * @retval None
    313            */

   \                                 In section .far_func.text, align 1
    314          void DMA_Cmd(DMA_Channel_TypeDef* DMA_Channelx, FunctionalState NewState)
    315          {
    316            /* Check the parameters */
    317            assert_param(IS_DMA_CHANNEL(DMA_Channelx));
    318            assert_param(IS_FUNCTIONAL_STATE(NewState));
    319          
    320            if (NewState != DISABLE)
   \                     DMA_Cmd:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??DMA_Cmd_0
    321            {
    322              /* Enable the selected DMA Channelx */
    323              DMA_Channelx->CCR |= DMA_CCR_CE;
   \   000003 F6           LD        A, (X)
   \   000004 AA 01        OR        A, #0x1
   \   000006 F7           LD        (X), A
   \   000007 87           RETF
    324            }
    325            else
    326            {
    327              /* Disable the selected DMA Channelx */
    328              DMA_Channelx->CCR &= (uint8_t)(~DMA_CCR_CE);
   \                     ??DMA_Cmd_0:
   \   000008 F6           LD        A, (X)
   \   000009 A4 FE        AND       A, #0xfe
   \   00000B F7           LD        (X), A
    329            }
    330          }
   \   00000C 87           RETF
    331          
    332          /**
    333            * @brief  Sets the Time out Value.
    334            * @param  DMA_TimeOut: an integer from 0 to 63
    335            * @note   If timeout duration >0 (number of wait cycles starting from the
    336            *         latest request), the DMA waits until this timeout has elapsed before
    337            *         requesting from the core a high priority access to the bus.
    338            * @note   If timeout duration =0, there is no timeout and once a request is served,
    339            *         the DMA immediately asks to the CPU a high priority access to the bus.
    340            * @retval None
    341            */

   \                                 In section .far_func.text, align 1
    342          void DMA_SetTimeOut(uint8_t DMA_TimeOut)
    343          {
    344            /* Check the parameters */
    345            assert_param(IS_DMA_TIMEOUT(DMA_TimeOut));
    346          
    347            /* set the time out, GB and GE must be = 0 */
    348            DMA1->GCSR = 0;
   \                     DMA_SetTimeOut:
   \   000000 35 00 5070   MOV       L:0x5070, #0x0
    349            DMA1->GCSR = (uint8_t)(DMA_TimeOut << (uint8_t)2);
   \   000004 48           SLL       A
   \   000005 48           SLL       A
   \   000006 C7 5070      LD        L:0x5070, A
    350          
    351          }
   \   000009 87           RETF
    352          
    353          /**
    354            * @}
    355            */
    356          
    357          /** @defgroup DMA_Group2 Data Counter functions
    358           *  @brief   Data Counter functions 
    359           *
    360          @verbatim   
    361           ===============================================================================
    362                                     Data Counter functions
    363           ===============================================================================  
    364          
    365            This subsection provides functions allowing to configure and read the buffer 
    366            size (number of data to be transferred). 
    367          
    368            The DMA data counter can be written only when the DMA channel is disabled 
    369            (ie. after transfer complete event).
    370          
    371            The DMA_SetCurrDataCounter() function can be used to write the Channel data 
    372            counter value.
    373            
    374          
    375            Note: It is advised to use this function rather than DMA_Init() (DMA_BufferSize 
    376                  parameter) in situations where only the Data buffer needs to be reloaded.
    377          
    378            The DMA data counter can be read to indicate the number of remaining transfers 
    379            for the relative DMA channel. This counter is decremented at the end of each 
    380            data transfer and when the transfer is complete: 
    381             - If Normal mode is selected: the counter is set to 0.
    382             - If Circular mode is selected: the counter is reloaded with the initial value
    383               (configured before enabling the DMA channel)
    384             
    385            The DMA_GetCurrDataCounter() function can be used to read the Channel current 
    386            data counter value.
    387               
    388          @endverbatim
    389            * @{
    390            */
    391            
    392          /**
    393            * @brief  Set the number of data units to transfer for DMA Channelx.
    394            * @param  DMA_Channelx: selects the DMA Channelx where x can be 0 to 3
    395            * @param  DataNumber: The number of  data units to transfer, it can be any value
    396            *         from 0 to 255
    397            * @note   It is advised to use this function rather than DMA_Init() in situations
    398            *         where only the Data buffer needs to be reloaded.  
    399            * @retval None
    400            */

   \                                 In section .far_func.text, align 1
    401          void DMA_SetCurrDataCounter(DMA_Channel_TypeDef* DMA_Channelx, uint8_t DataNumber)
    402          {
    403            /* Check the parameters */
    404            assert_param(IS_DMA_CHANNEL(DMA_Channelx));
    405          
    406            /*Set the number of data units for DMA Channelx */
    407            DMA_Channelx->CNBTR = DataNumber;
   \                     DMA_SetCurrDataCounter:
   \   000000 1C 0002      ADDW      X, #0x2
   \   000003 F7           LD        (X), A
    408          }
   \   000004 87           RETF
    409          
    410          /**
    411            * @brief  Returns the number of remaining data units in the current DMA Channelx transfer.
    412            * @param  DMA_Channelx: selects the DMA Channelx where x can be 0 to 3
    413            * @retval The number of remaining data units in the current DMA Channelx
    414            */

   \                                 In section .far_func.text, align 1
    415          uint8_t DMA_GetCurrDataCounter(DMA_Channel_TypeDef* DMA_Channelx)
    416          {
    417            /* Check the parameters */
    418            assert_param(IS_DMA_CHANNEL(DMA_Channelx));
    419          
    420            /* Return the number of remaining data units for DMA Channelx */
    421            return ((uint8_t)(DMA_Channelx->CNBTR));
   \                     DMA_GetCurrDataCounter:
   \   000000 1C 0002      ADDW      X, #0x2
   \   000003 F6           LD        A, (X)
   \   000004 87           RETF
    422          }
    423          
    424          /**
    425            * @}
    426            */
    427          
    428          /** @defgroup DMA_Group3 Interrupts and flags management functions
    429           *  @brief   Interrupts and flags management functions 
    430           *
    431          @verbatim   
    432           ===============================================================================
    433                            Interrupts and flags management functions
    434           ===============================================================================  
    435          
    436            This subsection provides functions allowing to configure the DMA Interrupts 
    437            sources and check or clear the flags or pending bits status.
    438            The user should identify which mode will be used in his application to manage 
    439            the DMA controller events: Polling mode or Interrupt mode. 
    440              
    441            Polling Mode
    442            =============
    443              Each DMA channel can be managed through 2 event Flags:
    444              (x: DMA channel number )
    445                 1. DMA1_FLAG_TCx: to indicate that a Transfer Complete event occurred
    446                 2. DMA1_FLAG_HTx: to indicate that a Half-Transfer Complete event 
    447                                    occurred
    448          
    449             In this Mode it is advised to use DMA_GetFlagStatus() and  DMA_ClearFlag() 
    450             functions. 
    451                
    452          
    453            Interrupt Mode
    454            ===============
    455              Each DMA channel can be managed through 2 Interrupts:
    456          
    457              Interrupt Source
    458              ----------------
    459                 1. DMA_IT_TC: specifies the interrupt source for the Transfer Complete 
    460                               event.  
    461                 2. DMA_IT_HT: specifies the interrupt source for the Half-transfer 
    462                                Complete event.
    463               
    464            In this Mode it is advised to use DMA_ITConfig(), DMA_GetITStatus() and
    465            DMA_ClearITPendingBit() functions.
    466          
    467          @endverbatim
    468            * @{
    469            */
    470          
    471          /**
    472            * @brief  Enables or disables the specified DMA Channelx interrupts.
    473            * @param  DMA_Channelx: selects the DMA Channelx where x can be 0 to 3
    474            * @param  DMA_ITx: specifies the DMA interrupts sources to be enabled or disabled. 
    475            *          This parameter can be one of the following values:
    476            *            @arg DMA_ITx_TC: Transaction Complete Interrupt
    477            *            @arg DMA_ITx_HT: Half Transaction Interrupt  
    478            * @param  NewState: new state of the specified DMA interrupts.
    479              *       This parameter can be: ENABLE or DISABLE.
    480            * @retval None
    481            */

   \                                 In section .far_func.text, align 1
    482          void DMA_ITConfig(DMA_Channel_TypeDef* DMA_Channelx, 
    483                            DMA_ITx_TypeDef DMA_ITx,
    484                            FunctionalState NewState)
    485          {
    486            /* Check the parameters */
    487            assert_param(IS_DMA_CHANNEL(DMA_Channelx));
    488            assert_param(IS_DMA_CONFIG_ITX(DMA_ITx));
    489            assert_param(IS_FUNCTIONAL_STATE(NewState));
    490          
    491            if (NewState != DISABLE)
   \                     DMA_ITConfig:
   \   000000 3D ..        TNZ       S:?b0
   \   000002 27 03        JREQ      L:??DMA_ITConfig_0
    492            {
    493              /* Enable the selected DMA interrupts */
    494              DMA_Channelx->CCR |= (uint8_t)(DMA_ITx);
   \   000004 FA           OR        A, (X)
   \   000005 F7           LD        (X), A
   \   000006 87           RETF
    495            }
    496            else
    497            {
    498              /* Disable the selected DMA interrupts */
    499              DMA_Channelx->CCR &= (uint8_t)~(DMA_ITx);
   \                     ??DMA_ITConfig_0:
   \   000007 43           CPL       A
   \   000008 F4           AND       A, (X)
   \   000009 F7           LD        (X), A
    500            }
    501          }
   \   00000A 87           RETF
    502          
    503          /**
    504            * @brief  Checks whether the specified DMA Channelx flag is set or not.
    505            * @param  DMA_FLAG: specifies the flag to check.
    506            *          This parameter can be one of the following values:
    507            *            @arg DMA1_FLAG_GB: Global Busy Flag
    508            *            @arg DMA1_FLAG_IFC0: Global Interrupt Flag Channel 0
    509            *            @arg DMA1_FLAG_IFC1: Global Interrupt Flag Channel 1
    510            *            @arg DMA1_FLAG_IFC2: Global Interrupt Flag Channel 2
    511            *            @arg DMA1_FLAG_IFC3: Global Interrupt Flag Channel 3
    512            *            @arg DMA1_FLAG_TC0: Transaction Complete Interrupt Flag Channel 0
    513            *            @arg DMA1_FLAG_TC1: Transaction Complete Interrupt Flag Channel 1
    514            *            @arg DMA1_FLAG_TC2: Transaction Complete Interrupt Flag Channel 2
    515            *            @arg DMA1_FLAG_TC2: Transaction Complete Interrupt Flag Channel 3
    516            *            @arg DMA1_FLAG_HT0: Half Transaction Interrupt Flag Channel 0
    517            *            @arg DMA1_FLAG_HT1: Half Transaction Interrupt Flag Channel 1
    518            *            @arg DMA1_FLAG_HT2: Half Transaction Interrupt Flag Channel 2
    519            *            @arg DMA1_FLAG_HT3: Half Transaction Interrupt Flag Channel 3
    520            *            @arg DMA1_FLAG_PEND0: DMA Request pending on Channel 0
    521            *            @arg DMA1_FLAG_PEND1: DMA Request pending on Channel 1
    522            *            @arg DMA1_FLAG_PEND2: DMA Request pending on Channel 2
    523            *            @arg DMA1_FLAG_PEND3: DMA Request pending on Channel 3
    524            *            @arg DMA1_FLAG_BUSY0: No DMA transfer on going in Channel 0
    525            *            @arg DMA1_FLAG_BUSY1: No DMA transfer on going in Channel 1 
    526            *            @arg DMA1_FLAG_BUSY2: No DMA transfer on going in Channel 2 
    527            *            @arg DMA1_FLAG_BUSY3: No DMA transfer on going in Channel 3                                        
    528            * @retval  The status of DMA_FLAG (SET or RESET).
    529            */

   \                                 In section .far_func.text, align 1
    530          FlagStatus DMA_GetFlagStatus(DMA_FLAG_TypeDef DMA_FLAG)
    531          {
   \                     DMA_GetFlagStatus:
   \   000000 BF ..        LDW       S:?w0, X
    532            FlagStatus flagstatus = RESET;
   \   000002 3F ..        CLR       S:?b3
    533            DMA_Channel_TypeDef* DMA_Channelx =  DMA1_Channel0;
   \   000004 AE 5075      LDW       X, #0x5075
    534            uint8_t tmpgir1 = 0;
   \   000007 3F ..        CLR       S:?b4
    535            uint8_t tmpgcsr = 0;
   \   000009 3F ..        CLR       S:?b2
    536          
    537            /* Check the parameters */
    538            assert_param(IS_DMA_GET_FLAG(DMA_FLAG));
    539          
    540            /* Get flags registers values*/
    541            tmpgcsr = DMA1->GCSR;
   \   00000B C6 5070      LD        A, L:0x5070
   \   00000E B7 ..        LD        S:?b2, A
    542            tmpgir1 = DMA1->GIR1;
   \   000010 C6 5071      LD        A, L:0x5071
   \   000013 B7 ..        LD        S:?b4, A
    543          
    544            if (((uint16_t)DMA_FLAG & (uint16_t)0x0F00) != (uint16_t)RESET)
   \   000015 90BE ..      LDW       Y, S:?w0
   \   000018 51           EXGW      X, Y
   \   000019 02           RLWA      X, A
   \   00001A A4 0F        AND       A, #0xf
   \   00001C 02           RLWA      X, A
   \   00001D A4 00        AND       A, #0x0
   \   00001F 02           RLWA      X, A
   \   000020 51           EXGW      X, Y
   \   000021 905D         TNZW      Y
   \   000023 27 3E        JREQ      L:??DMA_GetFlagStatus_0
    545            {
    546              /* find  the used DMA  channel */
    547              if (((uint16_t)DMA_FLAG & 0x0100) != (uint16_t)RESET)
   \   000025 BE ..        LDW       X, S:?w0
   \   000027 02           RLWA      X, A
   \   000028 A4 01        AND       A, #0x1
   \   00002A 02           RLWA      X, A
   \   00002B A4 00        AND       A, #0x0
   \   00002D 02           RLWA      X, A
   \   00002E 5D           TNZW      X
   \   00002F 27 05        JREQ      L:??DMA_GetFlagStatus_1
    548              {
    549                DMA_Channelx = DMA1_Channel0;
   \   000031 AE 5075      LDW       X, #0x5075
   \   000034 20 25        JRA       L:??DMA_GetFlagStatus_2
    550              }
    551              else if  (((uint16_t)DMA_FLAG & 0x0200) != (uint16_t)RESET)
   \                     ??DMA_GetFlagStatus_1:
   \   000036 BE ..        LDW       X, S:?w0
   \   000038 02           RLWA      X, A
   \   000039 A4 02        AND       A, #0x2
   \   00003B 02           RLWA      X, A
   \   00003C A4 00        AND       A, #0x0
   \   00003E 02           RLWA      X, A
   \   00003F 5D           TNZW      X
   \   000040 27 05        JREQ      L:??DMA_GetFlagStatus_3
    552              {
    553                DMA_Channelx = DMA1_Channel1;
   \   000042 AE 507F      LDW       X, #0x507f
   \   000045 20 14        JRA       L:??DMA_GetFlagStatus_2
    554              }
    555              else if  (((uint16_t)DMA_FLAG & 0x0400) != (uint16_t)RESET)
   \                     ??DMA_GetFlagStatus_3:
   \   000047 BE ..        LDW       X, S:?w0
   \   000049 02           RLWA      X, A
   \   00004A A4 04        AND       A, #0x4
   \   00004C 02           RLWA      X, A
   \   00004D A4 00        AND       A, #0x0
   \   00004F 02           RLWA      X, A
   \   000050 5D           TNZW      X
   \   000051 27 05        JREQ      L:??DMA_GetFlagStatus_4
    556              {
    557                DMA_Channelx = DMA1_Channel2;
   \   000053 AE 5089      LDW       X, #0x5089
   \   000056 20 03        JRA       L:??DMA_GetFlagStatus_2
    558              }
    559              else
    560              {
    561                DMA_Channelx = DMA1_Channel3;
   \                     ??DMA_GetFlagStatus_4:
   \   000058 AE 5093      LDW       X, #0x5093
    562              }
    563          
    564              /*   Get the specified DMA Channelx flag status. */
    565              flagstatus = (FlagStatus)((uint8_t)(DMA_Channelx->CSPR) & (uint8_t)DMA_FLAG);
   \                     ??DMA_GetFlagStatus_2:
   \   00005B 5C           INCW      X
   \   00005C B6 ..        LD        A, S:?b1
   \   00005E F4           AND       A, (X)
   \   00005F B7 ..        LD        S:?b3, A
   \   000061 20 1A        JRA       L:??DMA_GetFlagStatus_5
    566            }
    567            else if (((uint16_t)DMA_FLAG & 0x1000) != (uint16_t)RESET)
   \                     ??DMA_GetFlagStatus_0:
   \   000063 BE ..        LDW       X, S:?w0
   \   000065 02           RLWA      X, A
   \   000066 A4 10        AND       A, #0x10
   \   000068 02           RLWA      X, A
   \   000069 A4 00        AND       A, #0x0
   \   00006B 02           RLWA      X, A
   \   00006C 5D           TNZW      X
   \   00006D 27 08        JREQ      L:??DMA_GetFlagStatus_6
    568            {
    569              /*   Get the specified DMA Channelx flag status. */
    570              flagstatus = (FlagStatus)(tmpgir1 & (uint8_t)DMA_FLAG);
   \   00006F B6 ..        LD        A, S:?b1
   \   000071 B4 ..        AND       A, S:?b4
   \   000073 B7 ..        LD        S:?b3, A
   \   000075 20 06        JRA       L:??DMA_GetFlagStatus_5
    571            }
    572            else /*if ((DMA_FLAG & DMA_FLAG_GB) != (uint16_t)RESET)*/
    573            {
    574              /*   Get the specified DMA Channelx flag status. */
    575              flagstatus = (FlagStatus)(tmpgcsr & DMA_GCSR_GB);
   \                     ??DMA_GetFlagStatus_6:
   \   000077 B6 ..        LD        A, S:?b2
   \   000079 A4 02        AND       A, #0x2
   \   00007B B7 ..        LD        S:?b3, A
    576            }
    577          
    578            /*  Return the specified DMA Channelx flag status. */
    579            return (flagstatus);
   \                     ??DMA_GetFlagStatus_5:
   \   00007D B6 ..        LD        A, S:?b3
   \   00007F 87           RETF
    580          }
    581          
    582          /**
    583            * @brief  Clears the DMA Channels selected flags.
    584            * @param  DMA_FLAG: specifies the flag to clear.
    585            *          This parameter can be one or a combination (for the same channel)of
    586            *          the following values:
    587            *            @arg DMA1_FLAG_TC0: Transaction Complete Interrupt Flag Channel 0
    588            *            @arg DMA1_FLAG_TC1: Transaction Complete Interrupt Flag Channel 1
    589            *            @arg DMA1_FLAG_TC2: Transaction Complete Interrupt Flag Channel 2
    590            *            @arg DMA1_FLAG_TC2: Transaction Complete Interrupt Flag Channel 3
    591            *            @arg DMA1_FLAG_HT0: Half Transaction Interrupt Flag Channel 0
    592            *            @arg DMA1_FLAG_HT1: Half Transaction Interrupt Flag Channel 1
    593            *            @arg DMA1_FLAG_HT2: Half Transaction Interrupt Flag Channel 2
    594            *            @arg DMA1_FLAG_HT3: Half Transaction Interrupt Flag Channel 3
    595            * @retval None
    596            */

   \                                 In section .far_func.text, align 1
    597          void DMA_ClearFlag(DMA_FLAG_TypeDef DMA_FLAG)
    598          {
   \                     DMA_ClearFlag:
   \   000000 BF ..        LDW       S:?w0, X
    599            DMA_Channel_TypeDef* DMA_Channelx =  DMA1_Channel0;
   \   000002 AE 5075      LDW       X, #0x5075
    600          
    601            /* Check the parameters */
    602            assert_param(IS_DMA_CLEAR_FLAG(DMA_FLAG));
    603          
    604            /* Identify  the used DMA  channel */
    605            if (((uint16_t)DMA_FLAG & (uint16_t)0x0100) != (uint16_t)RESET)
   \   000005 90BE ..      LDW       Y, S:?w0
   \   000008 51           EXGW      X, Y
   \   000009 02           RLWA      X, A
   \   00000A A4 01        AND       A, #0x1
   \   00000C 02           RLWA      X, A
   \   00000D A4 00        AND       A, #0x0
   \   00000F 02           RLWA      X, A
   \   000010 51           EXGW      X, Y
   \   000011 905D         TNZW      Y
   \   000013 27 05        JREQ      L:??DMA_ClearFlag_0
    606            {
    607              DMA_Channelx = DMA1_Channel0;
   \   000015 AE 5075      LDW       X, #0x5075
   \   000018 20 25        JRA       L:??DMA_ClearFlag_1
    608            }
    609            else
    610            {
    611              if (((uint16_t)DMA_FLAG & (uint16_t)0x0200) != (uint16_t)RESET)
   \                     ??DMA_ClearFlag_0:
   \   00001A BE ..        LDW       X, S:?w0
   \   00001C 02           RLWA      X, A
   \   00001D A4 02        AND       A, #0x2
   \   00001F 02           RLWA      X, A
   \   000020 A4 00        AND       A, #0x0
   \   000022 02           RLWA      X, A
   \   000023 5D           TNZW      X
   \   000024 27 05        JREQ      L:??DMA_ClearFlag_2
    612              {
    613                DMA_Channelx = DMA1_Channel1;
   \   000026 AE 507F      LDW       X, #0x507f
   \   000029 20 14        JRA       L:??DMA_ClearFlag_1
    614              }
    615              else
    616              {
    617                if (((uint16_t)DMA_FLAG & (uint16_t)0x0400) != (uint16_t)RESET)
   \                     ??DMA_ClearFlag_2:
   \   00002B BE ..        LDW       X, S:?w0
   \   00002D 02           RLWA      X, A
   \   00002E A4 04        AND       A, #0x4
   \   000030 02           RLWA      X, A
   \   000031 A4 00        AND       A, #0x0
   \   000033 02           RLWA      X, A
   \   000034 5D           TNZW      X
   \   000035 27 05        JREQ      L:??DMA_ClearFlag_3
    618                {
    619                  DMA_Channelx = DMA1_Channel2;
   \   000037 AE 5089      LDW       X, #0x5089
   \   00003A 20 03        JRA       L:??DMA_ClearFlag_1
    620                }
    621                else
    622                {
    623                  DMA_Channelx = DMA1_Channel3;
   \                     ??DMA_ClearFlag_3:
   \   00003C AE 5093      LDW       X, #0x5093
    624                }
    625              }
    626            }
    627          
    628            /*Clears the DMA flags.*/
    629            DMA_Channelx->CSPR &= (uint8_t)~(uint8_t)((uint8_t)DMA_FLAG & (uint8_t)0x06);
   \                     ??DMA_ClearFlag_1:
   \   00003F B6 ..        LD        A, S:?b1
   \   000041 A4 06        AND       A, #0x6
   \   000043 43           CPL       A
   \   000044 9093         LDW       Y, X
   \   000046 905C         INCW      Y
   \   000048 90F4         AND       A, (Y)
   \   00004A 5C           INCW      X
   \   00004B F7           LD        (X), A
    630          }
   \   00004C 87           RETF
    631          
    632          /**
    633            * @brief  Checks whether the specified DMA Channelx interrupt has occurred or not.
    634            * @param  DMA_IT: specifies the DMA interrupt source to check.
    635            *          This parameter can be one or a combination of the following values:
    636            *            @arg DMA1_IT_TC0: Transaction Complete Interrupt Channel 0
    637            *            @arg DMA1_IT_TC1: Transaction Complete Interrupt Channel 1
    638            *            @arg DMA1_IT_TC2: Transaction Complete Interrupt Channel 2
    639            *            @arg DMA1_IT_TC3: Transaction Complete Interrupt Channel 3
    640            *            @arg DMA1_IT_HT0: Half Transaction Interrupt Channel 0
    641            *            @arg DMA1_IT_HT1: Half Transaction Interrupt Channel 1
    642            *            @arg DMA1_IT_HT2: Half Transaction Interrupt Channel 2
    643            *            @arg DMA1_IT_HT3: Half Transaction Interrupt Channel 3    
    644            * @retval ITStatus: The status of DMA_IT (SET or RESET).
    645            */

   \                                 In section .far_func.text, align 1
    646          ITStatus DMA_GetITStatus(DMA_IT_TypeDef DMA_IT)
    647          {
   \                     DMA_GetITStatus:
   \   000000 B7 ..        LD        S:?b2, A
    648            ITStatus itstatus = RESET;
   \   000002 3F ..        CLR       S:?b1
    649            uint8_t tmpreg = 0;
   \   000004 3F ..        CLR       S:?b3
    650            uint8_t tmp2 = 0;
   \   000006 3F ..        CLR       S:?b0
    651            DMA_Channel_TypeDef* DMA_Channelx =  DMA1_Channel0;
   \   000008 AE 5075      LDW       X, #0x5075
    652          
    653            /* Check the parameters */
    654            assert_param(IS_DMA_GET_IT(DMA_IT));
    655          
    656            /* Identify  the used DMA  channel */
    657            if ((DMA_IT & 0x10) != (uint8_t)RESET)
   \   00000B B6 ..        LD        A, S:?b2
   \   00000D A4 10        AND       A, #0x10
   \   00000F A1 00        CP        A, #0x0
   \   000011 27 05        JREQ      L:??DMA_GetITStatus_0
    658            {
    659              DMA_Channelx = DMA1_Channel0;
   \   000013 AE 5075      LDW       X, #0x5075
   \   000016 20 1D        JRA       L:??DMA_GetITStatus_1
    660            }
    661            else
    662            {
    663              if  ((DMA_IT & 0x20) != (uint8_t)RESET)
   \                     ??DMA_GetITStatus_0:
   \   000018 B6 ..        LD        A, S:?b2
   \   00001A A4 20        AND       A, #0x20
   \   00001C A1 00        CP        A, #0x0
   \   00001E 27 05        JREQ      L:??DMA_GetITStatus_2
    664              {
    665                DMA_Channelx = DMA1_Channel1;
   \   000020 AE 507F      LDW       X, #0x507f
   \   000023 20 10        JRA       L:??DMA_GetITStatus_1
    666              }
    667              else
    668              {
    669                if  ((DMA_IT & 0x40) != (uint8_t)RESET)
   \                     ??DMA_GetITStatus_2:
   \   000025 B6 ..        LD        A, S:?b2
   \   000027 A4 40        AND       A, #0x40
   \   000029 A1 00        CP        A, #0x0
   \   00002B 27 05        JREQ      L:??DMA_GetITStatus_3
    670                {
    671                  DMA_Channelx = DMA1_Channel2;
   \   00002D AE 5089      LDW       X, #0x5089
   \   000030 20 03        JRA       L:??DMA_GetITStatus_1
    672                }
    673                else
    674                {
    675                  DMA_Channelx = DMA1_Channel3;
   \                     ??DMA_GetITStatus_3:
   \   000032 AE 5093      LDW       X, #0x5093
    676                }
    677              }
    678            }
    679            /*   Get the specified DMA Channelx interrupt status. */
    680            tmpreg =  DMA_Channelx->CSPR ;
   \                     ??DMA_GetITStatus_1:
   \   000035 9093         LDW       Y, X
   \   000037 905C         INCW      Y
   \   000039 90F6         LD        A, (Y)
   \   00003B B7 ..        LD        S:?b3, A
    681            tmpreg &= DMA_Channelx->CCR ;
   \   00003D F6           LD        A, (X)
   \   00003E B4 ..        AND       A, S:?b3
   \   000040 B7 ..        LD        S:?b3, A
    682            tmp2 = (uint8_t)(DMA_IT & (uint8_t)(DMA_CCR_TCIE | DMA_CCR_HTIE));
   \   000042 B6 ..        LD        A, S:?b2
   \   000044 A4 06        AND       A, #0x6
   \   000046 B7 ..        LD        S:?b0, A
    683            itstatus = (ITStatus)((uint8_t)tmpreg & (uint8_t)tmp2);
   \   000048 B6 ..        LD        A, S:?b0
   \   00004A B4 ..        AND       A, S:?b3
   \   00004C B7 ..        LD        S:?b1, A
    684          
    685            /*   Return the specified DMA Channelx interrupt status. */
    686            return (itstatus);
   \   00004E B6 ..        LD        A, S:?b1
   \   000050 87           RETF
    687          }
    688          
    689          /**
    690            * @brief  Clears the DMA Channelxs interrupt pending bits.
    691            * @param  DMA_IT: specifies the DMA interrupt pending bit to clear.
    692            *          This parameter can be one or a combination(for the same channel)of 
    693            *          the following values:
    694            *            @arg DMA1_IT_TC0: Transaction Complete Interrupt Channel 0
    695            *            @arg DMA1_IT_TC1: Transaction Complete Interrupt Channel 1
    696            *            @arg DMA1_IT_TC2: Transaction Complete Interrupt Channel 2
    697            *            @arg DMA1_IT_TC3: Transaction Complete Interrupt Channel 3
    698            *            @arg DMA1_IT_HT0: Half Transaction Interrupt Channel 0
    699            *            @arg DMA1_IT_HT1: Half Transaction Interrupt Channel 1
    700            *            @arg DMA1_IT_HT2: Half Transaction Interrupt Channel 2
    701            *            @arg DMA1_IT_HT3: Half Transaction Interrupt Channel 3 
    702            * @retval None
    703            */

   \                                 In section .far_func.text, align 1
    704          void DMA_ClearITPendingBit(DMA_IT_TypeDef DMA_IT)
    705          {
   \                     DMA_ClearITPendingBit:
   \   000000 B7 ..        LD        S:?b0, A
    706            DMA_Channel_TypeDef* DMA_Channelx =  DMA1_Channel0;
   \   000002 AE 5075      LDW       X, #0x5075
    707          
    708            /* Check the parameters */
    709            assert_param(IS_DMA_CLEAR_IT(DMA_IT));
    710            /* Identify  the used DMA  channel */
    711            if ((DMA_IT & 0x10) != (uint8_t)RESET)
   \   000005 B6 ..        LD        A, S:?b0
   \   000007 A4 10        AND       A, #0x10
   \   000009 A1 00        CP        A, #0x0
   \   00000B 27 05        JREQ      L:??DMA_ClearITPendingBit_0
    712            {
    713              DMA_Channelx = DMA1_Channel0;
   \   00000D AE 5075      LDW       X, #0x5075
   \   000010 20 1D        JRA       L:??DMA_ClearITPendingBit_1
    714            }
    715            else
    716            {
    717              if ((DMA_IT & 0x20) != (uint8_t)RESET)
   \                     ??DMA_ClearITPendingBit_0:
   \   000012 B6 ..        LD        A, S:?b0
   \   000014 A4 20        AND       A, #0x20
   \   000016 A1 00        CP        A, #0x0
   \   000018 27 05        JREQ      L:??DMA_ClearITPendingBit_2
    718              {
    719                DMA_Channelx = DMA1_Channel1;
   \   00001A AE 507F      LDW       X, #0x507f
   \   00001D 20 10        JRA       L:??DMA_ClearITPendingBit_1
    720              }
    721              else
    722              {
    723                if ((DMA_IT & 0x40) != (uint8_t)RESET)
   \                     ??DMA_ClearITPendingBit_2:
   \   00001F B6 ..        LD        A, S:?b0
   \   000021 A4 40        AND       A, #0x40
   \   000023 A1 00        CP        A, #0x0
   \   000025 27 05        JREQ      L:??DMA_ClearITPendingBit_3
    724                {
    725                  DMA_Channelx = DMA1_Channel2;
   \   000027 AE 5089      LDW       X, #0x5089
   \   00002A 20 03        JRA       L:??DMA_ClearITPendingBit_1
    726                }
    727                else
    728                {
    729                  DMA_Channelx = DMA1_Channel3;
   \                     ??DMA_ClearITPendingBit_3:
   \   00002C AE 5093      LDW       X, #0x5093
    730                }
    731              }
    732            }
    733            /*Clears the DMA Channelxs interrupt pending bits*/
    734            DMA_Channelx->CSPR &= (uint8_t)~(uint8_t)(DMA_IT & (uint8_t)0x06);
   \                     ??DMA_ClearITPendingBit_1:
   \   00002F B6 ..        LD        A, S:?b0
   \   000031 A4 06        AND       A, #0x6
   \   000033 43           CPL       A
   \   000034 9093         LDW       Y, X
   \   000036 905C         INCW      Y
   \   000038 90F4         AND       A, (Y)
   \   00003A 5C           INCW      X
   \   00003B F7           LD        (X), A
    735          }
   \   00003C 87           RETF
    736          
    737          /**
    738            * @}
    739            */ 
    740          
    741          /**
    742            * @}
    743            */ 
    744            
    745          /**
    746            * @}
    747            */
    748          
    749          /**
    750            * @}
    751            */
    752          
    753          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Section sizes:

   Bytes  Function/Label
   -----  --------------
      77  DMA_ClearFlag
      61  DMA_ClearITPendingBit
      13  DMA_Cmd
      82  DMA_DeInit
       5  DMA_GetCurrDataCounter
     128  DMA_GetFlagStatus
      81  DMA_GetITStatus
      13  DMA_GlobalCmd
       9  DMA_GlobalDeInit
      11  DMA_ITConfig
     136  DMA_Init
       5  DMA_SetCurrDataCounter
      10  DMA_SetTimeOut

 
 631 bytes in section .far_func.text
 
 631 bytes of CODE memory

Errors: none
Warnings: none
