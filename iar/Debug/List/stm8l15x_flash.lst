###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.42.1.142 for STM8               01/Jul/2016  17:30:48 #
# Copyright 2010-2013 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  E:\hwpro-2016\20160627_L\stm8l15x_lib\src\stm8l15x_flash #
#                    .c                                                       #
#    Command line =  E:\hwpro-2016\20160627_L\stm8l15x_lib\src\stm8l15x_flash #
#                    .c -e -Ol --no_cse --no_unroll --no_inline               #
#                    --no_code_motion --no_tbaa --no_cross_call --debug       #
#                    --code_model medium --data_model medium -o               #
#                    E:\hwpro-2016\20160627_L\iar\Debug\Obj\ --dlib_config    #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.5\stm8\LIB\dlstm8mmn.h" -D STM8L15X_MD -lC             #
#                    E:\hwpro-2016\20160627_L\iar\Debug\List\ -I              #
#                    E:\hwpro-2016\20160627_L\iar\..\stm8l15x_lib\inc\ -I     #
#                    E:\hwpro-2016\20160627_L\iar\..\user\inc\ -I             #
#                    E:\hwpro-2016\20160627_L\iar\..\utils\xprintf\ -I        #
#                    E:\hwpro-2016\20160627_L\iar\..\drivers\ -I              #
#                    E:\hwpro-2016\20160627_L\iar\..\utils\ -I                #
#                    E:\hwpro-2016\20160627_L\iar\..\app\ --vregs 16          #
#    List file    =  E:\hwpro-2016\20160627_L\iar\Debug\List\stm8l15x_flash.l #
#                    st                                                       #
#    Object file  =  E:\hwpro-2016\20160627_L\iar\Debug\Obj\stm8l15x_flash.o  #
#                                                                             #
#                                                                             #
###############################################################################

E:\hwpro-2016\20160627_L\stm8l15x_lib\src\stm8l15x_flash.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm8l15x_flash.c
      4            * @author  MCD Application Team
      5            * @version V1.6.1
      6            * @date    30-September-2014
      7            * @brief   This file provides all the Flash firmware functions. These functions 
      8            *          can be executed from Internal FLASH or Internal RAM memories.
      9            *            - FLASH program and Data EEPROM memories interface configuration
     10            *            - FLASH program and Data EEPROM memories Programming
     11            *            - Option Bytes Programming
     12            *            - Interrupts and flags management
     13            *            - Functions to be executed from RAM
     14            *               
     15            *  @verbatim
     16            *  
     17            *          ===================================================================
     18            *                                 How to use this driver
     19            *          ===================================================================
     20            *                           
     21            *          This driver provides functions to configure and program the Flash 
     22            *          memory of all STM8L15x devices
     23            *          These functions are split in 4 groups
     24            * 
     25            *           1. FLASH program and Data EEPROM memories interface configuration 
     26            *              functions: this group includes the management of the following 
     27            *              features:
     28            *                    - Set the fixed programming time
     29            *                    - Configure the power state during WFI mode
     30            *                    - Configure the power state during run, low power run and
     31            *                      WFE modes (should be executed from internal RAM) 
     32            *  
     33            *           2. FLASH program and Data EEPROM memories Programming functions: 
     34            *              this group includes all needed functions to erase and program 
     35            *              the FLASH program or the Data EEPROM memory.
     36            *                    - Lock and Unlock the Flash program interface.
     37            *                    - Lock and Unlock the Data EEPROM interface.  
     38            *                    - Erase function: Erase Byte, Erase Word and Erase Block 
     39            *                      (should be executed from internal RAM). 
     40            *                    - Program functions: Program Byte, Program Word, 
     41            *                      Program Block (should be executed from internal RAM) 
     42            *                      and Fast Program Block (should be executed from internal
     43            *                      RAM).
     44            *    
     45            *           3. FLASH Option Bytes Programming functions: this group includes 
     46            *              all needed functions to:
     47            *                    - Program/erase the user option Bytes 
     48            *                    - Get the Read Out Protection status (ROP option byte)
     49            *                    - Get the User Boot Code size (UBC option byte)
     50            *                    - Get the Protected Code size (PCODE option byte) 
     51            *                    
     52            *            Note: Option byte programming is very similar to data EEPROM byte
     53            *                  programming.          
     54            *  
     55            *           4. FLASH Interrupts and flag management functions: this group 
     56            *              includes all needed functions to:
     57            *                    - Enable/Disable the flash interrupt sources
     58            *                    - Get flags status
     59            *                    - Wait for last flash operation(can be executed from 
     60            *                      internal RAM)
     61            *                        
     62            *           5. Functions to be executed from RAM: this group includes the functions
     63            *              that should be executed from RAM and provides description on how 
     64            *              to handle this with the different supported toolchains
     65            *   
     66            *  The table below lists the functions that can be executed from RAM.
     67            *  
     68            *   +--------------------------------------------------------------------------------|
     69            *   |   Functions prototypes      |    RAM execution            |     Comments       |
     70            *   ---------------------------------------------------------------------------------|
     71            *   |                             | Mandatory in case of block  | Can be executed    |
     72            *   | FLASH_WaitForLastOperation  | Operation:                  | from Flash in case |
     73            *   |                             | - Block programming         | of byte and word   |
     74            *   |                             | - Block erase               | Operations         |
     75            *   |--------------------------------------------------------------------------------|
     76            *   | FLASH_PowerRunModeConfig    |       Exclusively           | useless from Flash |
     77            *   |--------------------------------------------------------------------------------|
     78            *   | FLASH_GetPowerStatus        |       Exclusively           | useless from Flash |
     79            *   |--------------------------------------------------------------------------------|
     80            *   | FLASH_ProgramBlock          |       Exclusively           | useless from Flash |
     81            *   |--------------------------------------------------------------------------------|
     82            *   | FLASH_EraseBlock            |       Exclusively           | useless from Flash |
     83            *   |--------------------------------------------------------------------------------|
     84            *  
     85            *  To be able to execute functions from RAM several steps have to be followed.
     86            *   These steps may differ from one toolchain to another.
     87            *   A detailed description is available below within this driver.
     88            *   You can also refer to the Flash_DataProgram example provided within the
     89            *   STM8L15x_StdPeriph_Lib package.
     90            * 
     91            *  @endverbatim
     92            *                      
     93            ******************************************************************************
     94            * @attention
     95            *
     96            * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
     97            *
     98            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     99            * You may not use this file except in compliance with the License.
    100            * You may obtain a copy of the License at:
    101            *
    102            *        http://www.st.com/software_license_agreement_liberty_v2
    103            *
    104            * Unless required by applicable law or agreed to in writing, software 
    105            * distributed under the License is distributed on an "AS IS" BASIS, 
    106            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    107            * See the License for the specific language governing permissions and
    108            * limitations under the License.
    109            *
    110            ******************************************************************************
    111            */
    112          /* Includes ------------------------------------------------------------------*/
    113          #include "stm8l15x_flash.h"
    114          
    115          /** @addtogroup STM8L15x_StdPeriph_Driver
    116            * @{
    117            */
    118          
    119          /** @defgroup FLASH 
    120            * @brief FLASH driver modules
    121            * @{
    122            */
    123            
    124          /* Private typedef -----------------------------------------------------------*/
    125          /* Private define ------------------------------------------------------------*/
    126          /** @defgroup FLASH_Private_Define
    127            * @{
    128            */ 
    129          #define FLASH_CLEAR_BYTE   ((uint8_t)0x00)
    130          #define FLASH_SET_BYTE     ((uint8_t)0xFF)
    131          #define OPERATION_TIMEOUT  ((uint16_t)0xFFFF)
    132          /**
    133            * @}
    134            */
    135          /* Private macro -------------------------------------------------------------*/
    136          /* Private variables ---------------------------------------------------------*/
    137          /* Private function prototypes -----------------------------------------------*/
    138          /* Private functions ---------------------------------------------------------*/
    139           
    140          /** @defgroup FLASH_Private_Functions
    141            * @{
    142            */ 
    143          
    144          /** @defgroup FLASH_Group1 FLASH program and Data EEPROM memories Interface 
    145            *                        configuration functions
    146            *  @brief   FLASH Interface configuration functions 
    147           *
    148          @verbatim   
    149           ===============================================================================
    150                FLASH program and Data EEPROM memories interface configuration functions
    151           ===============================================================================  
    152          
    153             The FLASH program and Data EEPROM memories interface configuration functions,
    154              includes the following functions:
    155          		
    156             - FLASH_ProgramTime_TypeDef FLASH_GetProgrammingTime(void);
    157             - void FLASH_SetProgrammingTime(FLASH_ProgramTime_TypeDef FLASH_ProgTime);
    158          	 - void FLASH_PowerWaitModeConfig(FLASH_Power_TypeDef FLASH_Power);
    159          
    160             These functions don't need the unlock sequence.
    161          
    162          @endverbatim
    163            * @{
    164            */
    165          	
    166          /**
    167            * @brief  Sets the fixed programming time
    168            * @param  FLASH_ProgTime : Indicates the programming time to be fixed
    169            *          This parameter can be one of the following values:
    170            *            @arg FLASH_ProgramTime_Standard: Standard programming time fixed at 1/2 tprog
    171            *            @arg FLASH_ProgramTime_TProg: Programming time fixed at tprog 
    172            * @retval None
    173            */

   \                                 In section .far_func.text, align 1
    174          void FLASH_SetProgrammingTime(FLASH_ProgramTime_TypeDef FLASH_ProgTime)
    175          {
    176            /* Check parameter */
    177            assert_param(IS_FLASH_PROGRAM_TIME(FLASH_ProgTime));
    178            
    179            FLASH->CR1 &= (uint8_t)(~FLASH_CR1_FIX);
   \                     FLASH_SetProgrammingTime:
   \   000000 7211 5050    BRES      L:0x5050, #0x0
    180            FLASH->CR1 |= (uint8_t)FLASH_ProgTime;
   \   000004 CA 5050      OR        A, L:0x5050
   \   000007 C7 5050      LD        L:0x5050, A
    181          }
   \   00000A 87           RETF
    182          
    183          /**
    184            * @brief  Returns the fixed programming time
    185            * @param  None
    186            * @retval Fixed programming time value
    187            */

   \                                 In section .far_func.text, align 1
    188          FLASH_ProgramTime_TypeDef FLASH_GetProgrammingTime(void)
    189          {
    190            return((FLASH_ProgramTime_TypeDef)(FLASH->CR1 & FLASH_CR1_FIX));
   \                     FLASH_GetProgrammingTime:
   \   000000 C6 5050      LD        A, L:0x5050
   \   000003 A4 01        AND       A, #0x1
   \   000005 87           RETF
    191          }
    192          
    193          /**
    194            * @brief  Configures the power state for Flash program and data EEPROM during
    195            *          wait for interrupt mode
    196            * @param  FLASH_Power: The power state for Flash program and data EEPROM during
    197            *         wait for interrupt mode
    198            *          This parameter can be one of the following values:
    199            *            @arg FLASH_Power_IDDQ: Flash program and data EEPROM in IDDQ
    200            *            @arg FLASH_Power_On: Flash program and data EEPROM not in IDDQ 
    201            * @retval None
    202            */

   \                                 In section .far_func.text, align 1
    203          void FLASH_PowerWaitModeConfig(FLASH_Power_TypeDef FLASH_Power)
    204          {
    205            /* Check parameter */
    206            assert_param(IS_FLASH_POWER(FLASH_Power));
    207          
    208            /* Flash program and data EEPROM in IDDQ during wait for interrupt mode*/
    209            if(FLASH_Power != FLASH_Power_On)
   \                     FLASH_PowerWaitModeConfig:
   \   000000 A1 01        CP        A, #0x1
   \   000002 27 05        JREQ      L:??FLASH_PowerWaitModeConfig_0
    210            {
    211              FLASH->CR1 |= (uint8_t)FLASH_CR1_WAITM;
   \   000004 7214 5050    BSET      L:0x5050, #0x2
   \   000008 87           RETF
    212            }
    213            /* Flash program and data EEPROM not in IDDQ during wait for interrupt mode*/
    214            else
    215            {
    216              FLASH->CR1 &= (uint8_t)(~FLASH_CR1_WAITM);
   \                     ??FLASH_PowerWaitModeConfig_0:
   \   000009 7215 5050    BRES      L:0x5050, #0x2
    217            }
    218          }
   \   00000D 87           RETF
    219          
    220          /**
    221            * @}
    222            */
    223          
    224          /** @defgroup FLASH_Group2 FLASH Memory Programming functions
    225           *  @brief   FLASH Memory Programming functions
    226           *
    227          @verbatim   
    228           ===============================================================================
    229                                FLASH Memory Programming functions
    230           ===============================================================================  
    231          
    232             The FLASH Memory Programming functions, includes the following functions:
    233              - void FLASH_DeInit(void);
    234              - void FLASH_Unlock(FLASH_MemType_TypeDef FLASH_MemType);
    235              - void FLASH_Lock(FLASH_MemType_TypeDef FLASH_MemType);
    236              - void FLASH_ProgramByte(uint32_t Address, uint8_t Data);
    237              - void FLASH_EraseByte(uint32_t Address);
    238              - void FLASH_ProgramWord(uint32_t Address, uint32_t Data);
    239              - uint8_t FLASH_ReadByte(uint32_t Address);
    240             
    241             Any operation of erase or program should follow these steps:
    242          
    243             1. Call the FLASH_Unlock(FLASH_MemType) function to enable the memory access
    244          
    245             2. Call the desired function to erase or program data
    246          
    247             3. Call the FLASH_Lock() function to disable the memory access 
    248               (it is recommended to protect the FLASH memory against possible unwanted operation)
    249          
    250          @endverbatim
    251            * @{
    252            */
    253            
    254          /**
    255            * @brief  Deinitializes the FLASH registers to their default reset values.
    256            * @param  None
    257            * @retval None
    258            */

   \                                 In section .far_func.text, align 1
    259          void FLASH_DeInit(void)
    260          {
    261            FLASH->CR1 = FLASH_CR1_RESET_VALUE;
   \                     FLASH_DeInit:
   \   000000 35 00 5050   MOV       L:0x5050, #0x0
    262            FLASH->CR2 = FLASH_CR2_RESET_VALUE;
   \   000004 35 00 5051   MOV       L:0x5051, #0x0
    263            FLASH->IAPSR = FLASH_IAPSR_RESET_VALUE;
   \   000008 35 40 5054   MOV       L:0x5054, #0x40
    264            (void) FLASH->IAPSR; /* Reading of this register causes the clearing of status flags */
   \   00000C C6 5054      LD        A, L:0x5054
    265          }
   \   00000F 87           RETF
    266            
    267          /**
    268            * @brief  Unlocks the program or data EEPROM memory
    269            * @param  FLASH_MemType : Memory type to unlock
    270            *          This parameter can be one of the following values:
    271            *            @arg FLASH_MemType_Program: Program memory
    272            *            @arg FLASH_MemType_Data: Data EEPROM memory 
    273            * @retval None
    274            */

   \                                 In section .far_func.text, align 1
    275          void FLASH_Unlock(FLASH_MemType_TypeDef FLASH_MemType)
    276          {
    277            /* Check parameter */
    278            assert_param(IS_FLASH_MEMORY_TYPE(FLASH_MemType));
    279            
    280            /* Unlock program memory */
    281            if(FLASH_MemType == FLASH_MemType_Program)
   \                     FLASH_Unlock:
   \   000000 A1 FD        CP        A, #0xfd
   \   000002 26 08        JRNE      L:??FLASH_Unlock_0
    282            {
    283              FLASH->PUKR = FLASH_RASS_KEY1;
   \   000004 35 56 5052   MOV       L:0x5052, #0x56
    284              FLASH->PUKR = FLASH_RASS_KEY2;
   \   000008 35 AE 5052   MOV       L:0x5052, #0xae
    285            }
    286            
    287            /* Unlock data memory */
    288            if(FLASH_MemType == FLASH_MemType_Data)
   \                     ??FLASH_Unlock_0:
   \   00000C A1 F7        CP        A, #0xf7
   \   00000E 26 08        JRNE      L:??FLASH_Unlock_1
    289            {
    290              FLASH->DUKR = FLASH_RASS_KEY2; /* Warning: keys are reversed on data memory !!! */
   \   000010 35 AE 5053   MOV       L:0x5053, #0xae
    291              FLASH->DUKR = FLASH_RASS_KEY1;
   \   000014 35 56 5053   MOV       L:0x5053, #0x56
    292            }
    293          }
   \                     ??FLASH_Unlock_1:
   \   000018 87           RETF
    294          
    295          /**
    296            * @brief  Locks the program or data EEPROM memory
    297            * @param  FLASH_MemType : Memory type
    298            *          This parameter can be one of the following values:
    299            *            @arg FLASH_MemType_Program: Program memory
    300            *            @arg FLASH_MemType_Data: Data EEPROM memory 
    301            * @retval None
    302            */

   \                                 In section .far_func.text, align 1
    303          void FLASH_Lock(FLASH_MemType_TypeDef FLASH_MemType)
    304          {
    305            /* Check parameter */
    306            assert_param(IS_FLASH_MEMORY_TYPE(FLASH_MemType));
    307            
    308            /* Lock memory */
    309            FLASH->IAPSR &= (uint8_t)FLASH_MemType;
   \                     FLASH_Lock:
   \   000000 C4 5054      AND       A, L:0x5054
   \   000003 C7 5054      LD        L:0x5054, A
    310          }
   \   000006 87           RETF
    311          
    312          /**
    313            * @brief  Programs one byte in program or data EEPROM memory
    314            * @param  Address : Address where the byte will be programmed
    315            * @param  Data : Value to be programmed
    316            * @retval None
    317            */

   \                                 In section .far_func.text, align 1
    318          void FLASH_ProgramByte(uint32_t Address, uint8_t Data)
    319          {
    320            /* Check parameters */
    321            assert_param(IS_FLASH_ADDRESS(Address));
    322            
    323            *(PointerAttr uint8_t*) (MemoryAddressCast)Address = Data;
   \                     FLASH_ProgramByte:
   \   000000 92C7 ..      LD        [S:?w1.w], A
    324          }
   \   000003 87           RETF
    325          
    326          /**
    327            * @brief  Erases one byte in the program or data EEPROM memory
    328            * @param  Address : Address of the byte to erase
    329            * @retval None
    330            */

   \                                 In section .far_func.text, align 1
    331          void FLASH_EraseByte(uint32_t Address)
    332          {
    333            /* Check parameter */
    334            assert_param(IS_FLASH_ADDRESS(Address));
    335            
    336            *(PointerAttr uint8_t*) (MemoryAddressCast)Address = FLASH_CLEAR_BYTE; /* Erase byte */
   \                     FLASH_EraseByte:
   \   000000 4F           CLR       A
   \   000001 92C7 ..      LD        [S:?w1.w], A
    337          }
   \   000004 87           RETF
    338          
    339          /**
    340            * @brief  Programs one word (4 bytes) in program or data EEPROM memory
    341            * @param  Address : The address where the data will be programmed
    342            * @param  Data : Value to be programmed
    343            * @retval None
    344            */

   \                                 In section .far_func.text, align 1
    345          void FLASH_ProgramWord(uint32_t Address, uint32_t Data)
    346          {
   \                     FLASH_ProgramWord:
   \   000000 8D ......    CALLF     L:?push_l1
    347            /* Check parameters */
    348            assert_param(IS_FLASH_ADDRESS(Address));
    349            /* Enable Word Write Once */
    350            FLASH->CR2 |= FLASH_CR2_WPRG;
   \   000004 721C 5051    BSET      L:0x5051, #0x6
    351            
    352            /* Write one byte - from lowest address*/
    353            *((PointerAttr uint8_t*)(MemoryAddressCast)Address)       = *((uint8_t*)(&Data));   
   \   000008 7B 01        LD        A, (0x1,SP)
   \   00000A 92C7 ..      LD        [S:?w1.w], A
    354            /* Write one byte*/
    355            *(((PointerAttr uint8_t*)(MemoryAddressCast)Address) + 1) = *((uint8_t*)(&Data) + 1);
   \   00000D BE ..        LDW       X, S:?w1
   \   00000F 5C           INCW      X
   \   000010 7B 02        LD        A, (0x2,SP)
   \   000012 F7           LD        (X), A
    356            /* Write one byte*/
    357            *(((PointerAttr uint8_t*)(MemoryAddressCast)Address) + 2) = *((uint8_t*)(&Data) + 2); 
   \   000013 BE ..        LDW       X, S:?w1
   \   000015 1C 0002      ADDW      X, #0x2
   \   000018 7B 03        LD        A, (0x3,SP)
   \   00001A F7           LD        (X), A
    358            /* Write one byte - from higher address*/
    359            *(((PointerAttr uint8_t*)(MemoryAddressCast)Address) + 3) = *((uint8_t*)(&Data) + 3); 
   \   00001B BE ..        LDW       X, S:?w1
   \   00001D 1C 0003      ADDW      X, #0x3
   \   000020 7B 04        LD        A, (0x4,SP)
   \   000022 F7           LD        (X), A
    360          }
   \   000023 5B 04        ADD       SP, #0x4
   \   000025 87           RETF
    361          
    362          /**
    363            * @brief  Reads one byte from flash memory
    364            * @param  Address : Address to read
    365            * @retval Value of the byte
    366            */

   \                                 In section .far_func.text, align 1
    367          uint8_t FLASH_ReadByte(uint32_t Address)
    368          {
    369            /* Read byte */
    370            return(*(PointerAttr uint8_t *) (MemoryAddressCast)Address);
   \                     FLASH_ReadByte:
   \   000000 BE ..        LDW       X, S:?w1
   \   000002 F6           LD        A, (X)
   \   000003 87           RETF
    371          }
    372          /**
    373            * @}
    374            */
    375          
    376          /** @defgroup FLASH_Group3 Option Bytes Programming functions
    377           *  @brief   Option Bytes Programming functions 
    378           *
    379          @verbatim   
    380           ===============================================================================
    381                                  Option Bytes Programming functions
    382           ===============================================================================  
    383          
    384             The FLASH_Option Bytes Programming_functions, includes the following functions:
    385          
    386             - void FLASH_ProgramOptionByte(uint16_t Address, uint8_t Data);
    387             - void FLASH_EraseOptionByte(uint16_t Address);
    388             - FunctionalState FLASH_GetReadOutProtectionStatus(void);
    389             - uint16_t FLASH_GetBootSize(void);
    390             - uint16_t FLASH_GetCodeSize(void);
    391             
    392             Any operation of erase or program should follow these steps:
    393             
    394             1. Call the FLASH_Unlock(FLASH_MemType_Data); function to enable the Flash 
    395                option control register access
    396             
    397             2. Call the desired function to erase or program data
    398                - void FLASH_ProgramOptionByte(uint16_t Address, uint8_t Data); => to program
    399                  the option byte Address with the desired Data value.  
    400                - void FLASH_EraseOptionByte(uint16_t Address); => to erase the option byte
    401                  Address. 			 
    402             
    403             3. Once all needed option bytes to be programmed are correctly written, call the
    404                FLASH_Lock(FLASH_MemType_Data) to disable the memory access ( It is recommended to
    405                protect the FLASH memory against possible unwanted operation)
    406          
    407          @endverbatim
    408            * @{
    409            */
    410            
    411          /**
    412            * @brief  Programs option byte
    413            * @param  Address : option byte address to program
    414            * @param  Data : Value to write
    415            * @retval None
    416            */

   \                                 In section .far_func.text, align 1
    417          void FLASH_ProgramOptionByte(uint16_t Address, uint8_t Data)
    418          {
    419            /* Check parameter */
    420            assert_param(IS_OPTION_BYTE_ADDRESS(Address));
    421          
    422            /* Enable write access to option bytes */
    423            FLASH->CR2 |= FLASH_CR2_OPT;
   \                     FLASH_ProgramOptionByte:
   \   000000 721E 5051    BSET      L:0x5051, #0x7
    424          
    425            /* Program option byte and his complement */
    426            *((PointerAttr uint8_t*)Address) = Data;
   \   000004 F7           LD        (X), A
    427          
    428            FLASH_WaitForLastOperation(FLASH_MemType_Program);
   \   000005 A6 FD        LD        A, #0xfd
   \   000007 8D ......    CALLF     FLASH_WaitForLastOperation
    429          
    430            /* Disable write access to option bytes */
    431            FLASH->CR2 &= (uint8_t)(~FLASH_CR2_OPT);
   \   00000B 721F 5051    BRES      L:0x5051, #0x7
    432          }
   \   00000F 87           RETF
    433          
    434          /**
    435            * @brief  Erases option byte
    436            * @param  Address : Option byte address to erase
    437            * @retval None
    438            */

   \                                 In section .far_func.text, align 1
    439          void FLASH_EraseOptionByte(uint16_t Address)
    440          {
    441            /* Check parameter */
    442            assert_param(IS_OPTION_BYTE_ADDRESS(Address));
    443          
    444            /* Enable write access to option bytes */
    445            FLASH->CR2 |= FLASH_CR2_OPT;
   \                     FLASH_EraseOptionByte:
   \   000000 721E 5051    BSET      L:0x5051, #0x7
    446          
    447            /* Erase option byte and his complement */
    448            *((PointerAttr uint8_t*)Address) = FLASH_CLEAR_BYTE;
   \   000004 4F           CLR       A
   \   000005 F7           LD        (X), A
    449          
    450            FLASH_WaitForLastOperation(FLASH_MemType_Program);
   \   000006 A6 FD        LD        A, #0xfd
   \   000008 8D ......    CALLF     FLASH_WaitForLastOperation
    451          
    452            /* Disable write access to option bytes */
    453            FLASH->CR2 &= (uint8_t)(~FLASH_CR2_OPT);
   \   00000C 721F 5051    BRES      L:0x5051, #0x7
    454          }
   \   000010 87           RETF
    455          
    456          /**
    457            * @brief  Returns the FLASH Read Out Protection Status.
    458            * @param  None
    459            * @retval FLASH Read Out Protection Status.
    460            *         This parameter can be a ENABLE or DISABLE
    461            */

   \                                 In section .far_func.text, align 1
    462          FunctionalState FLASH_GetReadOutProtectionStatus(void)
    463          {
    464            FunctionalState state = DISABLE;
   \                     FLASH_GetReadOutProtectionStatus:
   \   000000 3F ..        CLR       S:?b0
    465            
    466            if(OPT->ROP == FLASH_READOUTPROTECTION_KEY)
   \   000002 C6 4800      LD        A, L:0x4800
   \   000005 A1 AA        CP        A, #0xaa
   \   000007 26 06        JRNE      L:??FLASH_GetReadOutProtectionStatus_0
    467            {
    468              /* The status of the Flash read out protection is enabled*/
    469              state =  ENABLE;
   \   000009 35 01 ....   MOV       S:?b0, #0x1
   \   00000D 20 02        JRA       L:??FLASH_GetReadOutProtectionStatus_1
    470            }
    471            else
    472            {
    473              /* The status of the Flash read out protection is disabled*/
    474              state =  DISABLE;
   \                     ??FLASH_GetReadOutProtectionStatus_0:
   \   00000F 3F ..        CLR       S:?b0
    475            }
    476            
    477            return state;
   \                     ??FLASH_GetReadOutProtectionStatus_1:
   \   000011 B6 ..        LD        A, S:?b0
   \   000013 87           RETF
    478          }
    479          
    480          /**
    481            * @brief  Returns the Boot memory size in bytes
    482            * @param  None
    483            * @retval Boot memory size in bytes
    484            */

   \                                 In section .far_func.text, align 1
    485          uint16_t FLASH_GetBootSize(void)
    486          {
    487            uint16_t temp = 0;
   \                     FLASH_GetBootSize:
   \   000000 905F         CLRW      Y
    488            
    489            /* Calculates the number of bytes */
    490            temp = (uint16_t)((uint16_t)OPT->UBC * (uint16_t)128);
   \   000002 C6 4802      LD        A, L:0x4802
   \   000005 5F           CLRW      X
   \   000006 97           LD        XL, A
   \   000007 BF ..        LDW       S:?w1, X
   \   000009 AE 0080      LDW       X, #0x80
   \   00000C BF ..        LDW       S:?w0, X
   \   00000E BE ..        LDW       X, S:?w1
   \   000010 8D ......    CALLF     L:?mul16_x_x_w0
   \   000014 9093         LDW       Y, X
    491            
    492            /* Correction because size upper 8kb doesn't exist */
    493            if(OPT->UBC > 0x7F)
   \   000016 C6 4802      LD        A, L:0x4802
   \   000019 A1 80        CP        A, #0x80
   \   00001B 25 05        JRC       L:??FLASH_GetBootSize_0
    494            {
    495              temp = 8192;
   \   00001D AE 2000      LDW       X, #0x2000
   \   000020 9093         LDW       Y, X
    496            }
    497            
    498            /* Return value */
    499            return(temp);
   \                     ??FLASH_GetBootSize_0:
   \   000022 93           LDW       X, Y
   \   000023 87           RETF
    500          }
    501          
    502          /**
    503           *
    504            * @brief  Returns the Code Area size in bytes
    505            * @param  None
    506            * @retval Code Area size in bytes
    507            */

   \                                 In section .far_func.text, align 1
    508          uint16_t FLASH_GetCodeSize(void)
    509          {
    510            uint16_t temp = 0;
   \                     FLASH_GetCodeSize:
   \   000000 905F         CLRW      Y
    511            
    512            /* Calculates the number of bytes */
    513            temp = (uint16_t)((uint16_t)OPT->PCODESIZE * (uint16_t)128);
   \   000002 C6 4807      LD        A, L:0x4807
   \   000005 5F           CLRW      X
   \   000006 97           LD        XL, A
   \   000007 BF ..        LDW       S:?w1, X
   \   000009 AE 0080      LDW       X, #0x80
   \   00000C BF ..        LDW       S:?w0, X
   \   00000E BE ..        LDW       X, S:?w1
   \   000010 8D ......    CALLF     L:?mul16_x_x_w0
   \   000014 9093         LDW       Y, X
    514            
    515            /* Correction because size upper of 8kb doesn't exist */
    516            if(OPT->PCODESIZE > 0x7F)
   \   000016 C6 4807      LD        A, L:0x4807
   \   000019 A1 80        CP        A, #0x80
   \   00001B 25 05        JRC       L:??FLASH_GetCodeSize_0
    517            {
    518              temp = 8192;
   \   00001D AE 2000      LDW       X, #0x2000
   \   000020 9093         LDW       Y, X
    519            }
    520            
    521            /* Return value */
    522            return(temp);
   \                     ??FLASH_GetCodeSize_0:
   \   000022 93           LDW       X, Y
   \   000023 87           RETF
    523          }
    524          
    525          /**
    526            * @}
    527            */
    528          
    529          /** @defgroup FLASH_Group4 Interrupts and flags management functions
    530           *  @brief   Interrupts and flags management functions
    531           *
    532          @verbatim   
    533           ===============================================================================
    534                            Interrupts and flags management functions
    535           ===============================================================================  
    536          
    537          @endverbatim
    538            * @{
    539            */
    540            
    541          /**
    542            * @brief  Enables or Disables the Flash interrupt mode
    543            * @param  NewState : The new state of the flash interrupt mode
    544              *         This parameter can be: ENABLE or DISABLE.
    545            * @retval None
    546            */

   \                                 In section .far_func.text, align 1
    547          void FLASH_ITConfig(FunctionalState NewState)
    548          {
    549            /* Check parameter */
    550            assert_param(IS_FUNCTIONAL_STATE(NewState));
    551            
    552            if(NewState != DISABLE)
   \                     FLASH_ITConfig:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??FLASH_ITConfig_0
    553            {
    554              /* Enables the interrupt sources */
    555              FLASH->CR1 |= FLASH_CR1_IE;
   \   000003 7212 5050    BSET      L:0x5050, #0x1
   \   000007 87           RETF
    556            }
    557            else
    558            {
    559              /* Disables the interrupt sources */
    560              FLASH->CR1 &= (uint8_t)(~FLASH_CR1_IE);
   \                     ??FLASH_ITConfig_0:
   \   000008 7213 5050    BRES      L:0x5050, #0x1
    561            }
    562          }
   \   00000C 87           RETF
    563          
    564          /**
    565            * @brief  Checks whether the specified FLASH flag is set or not.
    566            * @param  FLASH_FLAG : specifies the Flash Flag to check.
    567            *          This parameter can be one of the following values:
    568            *            @arg FLASH_FLAG_HVOFF: End of high voltage
    569            *            @arg FLASH_FLAG_DUL: Data EEPROM unlocked
    570            *            @arg FLASH_FLAG_EOP: End of programming (write or erase operation)
    571            *            @arg FLASH_FLAG_PUL: Flash Program memory unlocked
    572            *            @arg FLASH_FLAG_WR_PG_DIS: Write attempted to protected page       
    573            * @retval Indicates the state of the Flash_FLAG.
    574            *         This parameter can be SET or RESET
    575            */

   \                                 In section .far_func.text, align 1
    576          FlagStatus FLASH_GetFlagStatus(FLASH_FLAG_TypeDef FLASH_FLAG)
    577          {
    578            FlagStatus status = RESET;
   \                     FLASH_GetFlagStatus:
   \   000000 3F ..        CLR       S:?b0
    579            assert_param(IS_FLASH_FLAGS(FLASH_FLAG));
    580            
    581            /* Check the status of the specified flash flag*/
    582            if((FLASH->IAPSR  & (uint8_t)FLASH_FLAG) != (uint8_t)RESET)
   \   000002 C4 5054      AND       A, L:0x5054
   \   000005 A1 00        CP        A, #0x0
   \   000007 27 06        JREQ      L:??FLASH_GetFlagStatus_0
    583            {
    584              status = SET; /* Flash_FLAG is set*/
   \   000009 35 01 ....   MOV       S:?b0, #0x1
   \   00000D 20 02        JRA       L:??FLASH_GetFlagStatus_1
    585            }
    586            else
    587            {
    588              status = RESET; /* Flash_FLAG is reset*/
   \                     ??FLASH_GetFlagStatus_0:
   \   00000F 3F ..        CLR       S:?b0
    589            }
    590            
    591            /* Return the Flash_FLAG status*/
    592            return status;
   \                     ??FLASH_GetFlagStatus_1:
   \   000011 B6 ..        LD        A, S:?b0
   \   000013 87           RETF
    593          }
    594          
    595          /**
    596            * @}
    597            */ 
    598            
    599          /** @defgroup FLASH_Group5 Functions to be executed from RAM
    600           *  @brief  Functions to be executed from RAM
    601           *
    602          @verbatim   
    603           ===============================================================================
    604                                   Functions to be executed from RAM
    605           ===============================================================================  
    606           
    607           All the functions defined below must be executed from RAM exclusively, except
    608           for the FLASH_WaitForLastOperation function which can be executed from Flash.
    609          
    610           Steps of the execution from RAM differs from one toolchain to another:
    611           - For Cosmic Compiler:
    612              1- Define a segment FLASH_CODE by the mean of " #pragma section (FLASH_CODE)".
    613              This segment is defined in the stm8l15x_flash.c file.
    614            2- Uncomment the "#define RAM_EXECUTION  (1)" line in the stm8l15x.h file,
    615              or define it in Cosmic compiler preprocessor to enable the FLASH_CODE segment
    616             definition.
    617            3- In STVD Select Project\Settings\Linker\Category "input" and in the RAM section
    618              add the FLASH_CODE segment with "-ic" options.
    619            4- In main.c file call the _fctcpy() function with first segment character as 
    620              parameter "_fctcpy('F');" to load the declared moveable code segment
    621              (FLASH_CODE) in RAM before execution.
    622            5- By default the _fctcpy function is packaged in the Cosmic machine library,
    623              so the function prototype "int _fctcopy(char name);" must be added in main.c
    624              file.
    625          
    626            - For Raisonance Compiler
    627             1- Use the inram keyword in the function declaration to specify that it can be
    628              executed from RAM.
    629              This is done within the stm8l15x_flash.c file, and it's conditioned by 
    630              RAM_EXECUTION definition.
    631             2- Uncomment the "#define RAM_EXECUTION  (1)" line in the stm8l15x.h file, or 
    632             define it in Raisonance compiler preprocessor to enable the access for the 
    633             inram functions.
    634             3- An inram function code is copied from Flash to RAM by the C startup code. 
    635             In some applications, the RAM area where the code was initially stored may be
    636             erased or corrupted, so it may be desirable to perform the copy again. 
    637             Depending on the application memory model, the memcpy() or fmemcpy() functions
    638             should be used to perform the copy.
    639                • In case your project uses the SMALL memory model (code smaller than 64K),
    640                 memcpy()function is recommended to perform the copy
    641                • In case your project uses the LARGE memory model, functions can be 
    642                everywhere in the 24-bits address space (not limited to the first 64KB of
    643                code), In this case, the use of memcpy() function will not be appropriate,
    644                you need to use the specific fmemcpy() function (which copies objects with
    645                24-bit addresses).
    646                - The linker automatically defines 2 symbols for each inram function:
    647                     • __address__functionname is a symbol that holds the Flash address 
    648                     where the given function code is stored.
    649                     • __size__functionname is a symbol that holds the function size in bytes.
    650               And we already have the function address (which is itself a pointer)
    651            4- In main.c file these two steps should be performed for each inram function:
    652               • Import the "__address__functionname" and "__size__functionname" symbols
    653                 as global variables:
    654                   extern int __address__functionname; // Symbol holding the flash address
    655                   extern int __size__functionname;    // Symbol holding the function size
    656               • In case of SMALL memory model use, Call the memcpy() function to copy the
    657                inram function to the RAM destination address:
    658                          memcpy(functionname, // RAM destination address
    659                                (void*)&__address__functionname, // Flash source address
    660                                (int)&__size__functionname); // Code size of the function
    661               • In case of LARGE memory model use, call the fmemcpy() function to copy 
    662               the inram function to the RAM destination address:
    663                           memcpy(functionname, // RAM destination address
    664                                (void @far*)&__address__functionname, // Flash source address
    665                                (int)&__size__functionname); // Code size of the function
    666          
    667           - For IAR Compiler:
    668              1- Use the __ramfunc keyword in the function declaration to specify that it 
    669              can be executed from RAM.
    670              This is done within the stm8l15x_flash.c file, and it's conditioned by 
    671              RAM_EXECUTION definition.
    672              2- Uncomment the "#define RAM_EXECUTION  (1)" line in the stm8l15x.h file, or 
    673             define it in IAR compiler preprocessor to enable the access for the 
    674             __ramfunc functions.
    675           
    676           - Note: 
    677              1- Ignore the IAR compiler warnings, these warnings don't impact the FLASH Program/Erase
    678              operations.
    679              The code performing the Flash Program/erase must be executed from RAM; the variables
    680              initializations don't necessary require the execution from RAM, only CR2 registers 
    681              configuration and data programing must be executed from RAM.
    682              2- These warnings depends on IAR compiler: as the code generation is made using many
    683              runtime library functions to keep code size to a minimum.
    684              3- It is recommended to use High Speed Optimization with IAR (-Ohs), in order 
    685              to reduce the runtime library calls in the generated code.
    686          
    687           The Flash_DataProgram example provided within the STM8L15x_StdPeriph_Lib package
    688           details all the steps described above.
    689          
    690          @endverbatim
    691            * @{
    692            */
    693             
    694          /**
    695            * @brief
    696            *******************************************************************************
    697            *                         Execution from RAM enable
    698            *******************************************************************************
    699            *
    700            * To enable execution from RAM you can either uncomment the following define 
    701            * in the stm8l15x.h file or define it in your toolchain compiler preprocessor
    702            * - #define RAM_EXECUTION  (1) 
    703            */
    704          
    705          #if defined (_COSMIC_) && defined (RAM_EXECUTION)
    706           #pragma section (FLASH_CODE)
    707          #endif  /* _COSMIC_ && RAM_EXECUTION */
    708          
    709          /**
    710            * @brief  Configures the power state for Flash program and data EEPROM during
    711            *         run, low power run and low power wait modes
    712            * @note   This function must be called and executed from RAM.
    713            * @param  FLASH_Power: power state of the Flash program and data EEPROM
    714            *          This parameter can be one of the following values:
    715            *            @arg FLASH_Power_IDDQ: Flash program and data EEPROM in IDDQ
    716            *            @arg FLASH_Power_On: Flash program and data EEPROM not in IDDQ 
    717            * @retval None
    718            */

   \                                 In section .far_func.text, align 1
    719          IN_RAM(void FLASH_PowerRunModeConfig(FLASH_Power_TypeDef FLASH_Power))
    720          {
    721            /* Check parameter */
    722            assert_param(IS_FLASH_POWER(FLASH_Power));
    723            
    724            if(FLASH_Power != FLASH_Power_On)
   \                     FLASH_PowerRunModeConfig:
   \   000000 A1 01        CP        A, #0x1
   \   000002 27 05        JREQ      L:??FLASH_PowerRunModeConfig_0
    725            {
    726              FLASH->CR1 |= (uint8_t)FLASH_CR1_EEPM;
   \   000004 7216 5050    BSET      L:0x5050, #0x3
   \   000008 87           RETF
    727            }
    728            else
    729            {
    730              FLASH->CR1 &= (uint8_t)(~FLASH_CR1_EEPM);
   \                     ??FLASH_PowerRunModeConfig_0:
   \   000009 7217 5050    BRES      L:0x5050, #0x3
    731            }
    732          }
   \   00000D 87           RETF
    733          
    734          /**
    735            * @brief  Checks the power status for Flash program and data EEPROM
    736            * @note   This function should be called and executed from RAM.
    737            * @param  None
    738            * @retval Flash program and data EEPROM power status
    739            *         The returned value can be one of the following:
    740            *         - FLASH_PowerStatus_IDDQDuringWaitMode: IDDQ during Wait mode
    741            *         - FLASH_PowerStatus_IDDQDuringRunMode: IDDQ during Run mode
    742            *         - FLASH_PowerStatus_IDDQDuringWaitAndRunModes: IDDQ during Wait/Run mode
    743            *         - FLASH_PowerStatus_On: Powered on during Wait and Run modes
    744            */

   \                                 In section .far_func.text, align 1
    745          IN_RAM(FLASH_PowerStatus_TypeDef FLASH_GetPowerStatus(void))
    746          {
    747            return((FLASH_PowerStatus_TypeDef)(FLASH->CR1 & (uint8_t)0x0C));
   \                     FLASH_GetPowerStatus:
   \   000000 C6 5050      LD        A, L:0x5050
   \   000003 A4 0C        AND       A, #0xc
   \   000005 87           RETF
    748          }
    749          
    750          /**
    751            * @brief  Programs a memory block
    752            * @note   This function should be called and executed from RAM.
    753            * @param  FLASH_MemType : The type of memory to program
    754            *          This parameter can be one of the following values:
    755            *            @arg FLASH_MemType_Program: Program memory
    756            *            @arg FLASH_MemType_Data: Data EEPROM memory 
    757            * @param  BlockNum : The block number
    758            * @param  FLASH_ProgMode : The programming mode.
    759            *          This parameter can be one of the following values:
    760            *            @arg FLASH_ProgramMode_Standard: Standard programming mode
    761            *            @arg FLASH_ProgramMode_Fast: Fast programming mode
    762            * @param  Buffer : Pointer to buffer containing source data.
    763            * @retval None.
    764            */

   \                                 In section .far_func.text, align 1
    765          IN_RAM(void FLASH_ProgramBlock(uint16_t BlockNum, FLASH_MemType_TypeDef FLASH_MemType,
    766                                  FLASH_ProgramMode_TypeDef FLASH_ProgMode, uint8_t *Buffer))
    767          {
   \                     FLASH_ProgramBlock:
   \   000000 8D ......    CALLF     L:?push_l2
   \   000004 8D ......    CALLF     L:?push_w7
   \   000008 3B ....      PUSH      S:?b12
   \   00000B BF ..        LDW       S:?w1, X
   \   00000D 45 .. ..     MOV       S:?b12, S:?b0
   \   000010 90BF ..      LDW       S:?w7, Y
    768            uint16_t Count = 0;
   \   000013 3F ..        CLR       S:?b1
   \   000015 3F ..        CLR       S:?b0
    769            uint32_t startaddress = 0;
   \   000017 5F           CLRW      X
   \   000018 BF ..        LDW       S:?w5, X
   \   00001A BF ..        LDW       S:?w4, X
    770            
    771            /* Check parameters */
    772            assert_param(IS_FLASH_MEMORY_TYPE(FLASH_MemType));
    773            assert_param(IS_FLASH_PROGRAM_MODE(FLASH_ProgMode));
    774            if(FLASH_MemType == FLASH_MemType_Program)
   \   00001C A1 FD        CP        A, #0xfd
   \   00001E 26 0A        JRNE      L:??FLASH_ProgramBlock_0
    775            {
    776              assert_param(IS_FLASH_PROGRAM_BLOCK_NUMBER(BlockNum));
    777              startaddress = FLASH_PROGRAM_START_PHYSICAL_ADDRESS;
   \   000020 AE 8000      LDW       X, #0x8000
   \   000023 BF ..        LDW       S:?w5, X
   \   000025 58           SLLW      X
   \   000026 BF ..        LDW       S:?w4, X
   \   000028 20 08        JRA       L:??FLASH_ProgramBlock_1
    778            }
    779            else
    780            {
    781              assert_param(IS_FLASH_DATA_EEPROM_BLOCK_NUMBER(BlockNum));
    782              startaddress = FLASH_DATA_EEPROM_START_PHYSICAL_ADDRESS;
   \                     ??FLASH_ProgramBlock_0:
   \   00002A AE 1000      LDW       X, #0x1000
   \   00002D BF ..        LDW       S:?w5, X
   \   00002F 5F           CLRW      X
   \   000030 BF ..        LDW       S:?w4, X
    783            }
    784            
    785            /* Point to the first block address */
    786            startaddress = startaddress + ((uint32_t)BlockNum * FLASH_BLOCK_SIZE);
   \                     ??FLASH_ProgramBlock_1:
   \   000032 5F           CLRW      X
   \   000033 BF ..        LDW       S:?w0, X
   \   000035 AE 0080      LDW       X, #0x80
   \   000038 BF ..        LDW       S:?w3, X
   \   00003A 5F           CLRW      X
   \   00003B BF ..        LDW       S:?w2, X
   \   00003D 8D ......    CALLF     L:?mul32_l0_l0_l1
   \   000041 8D ......    CALLF     L:?mov_l1_l0
   \   000045 8D ......    CALLF     L:?mov_l0_l2
   \   000049 8D ......    CALLF     L:?add32_l0_l0_l1
   \   00004D 8D ......    CALLF     L:?mov_l2_l0
    787            
    788            /* Selection of Standard or Fast programming mode */
    789            if(FLASH_ProgMode == FLASH_ProgramMode_Standard)
   \   000051 3D ..        TNZ       S:?b12
   \   000053 26 06        JRNE      L:??FLASH_ProgramBlock_2
    790            {
    791              /* Standard programming mode */
    792              FLASH->CR2 |= FLASH_CR2_PRG;
   \   000055 7210 5051    BSET      L:0x5051, #0x0
   \   000059 20 04        JRA       L:??FLASH_ProgramBlock_3
    793            }
    794            else
    795            {
    796              /* Fast programming mode */
    797              FLASH->CR2 |= FLASH_CR2_FPRG;
   \                     ??FLASH_ProgramBlock_2:
   \   00005B 7218 5051    BSET      L:0x5051, #0x4
    798            }
    799            
    800            /* Copy data bytes from RAM to FLASH memory */
    801            for(Count = 0; Count < FLASH_BLOCK_SIZE; Count++)
   \                     ??FLASH_ProgramBlock_3:
   \   00005F 3F ..        CLR       S:?b1
   \   000061 3F ..        CLR       S:?b0
   \   000063 20 16        JRA       L:??FLASH_ProgramBlock_4
    802            {
    803              *((PointerAttr uint8_t*) (MemoryAddressCast)startaddress + Count) = ((uint8_t)(Buffer[Count]));
   \                     ??FLASH_ProgramBlock_5:
   \   000065 BE ..        LDW       X, S:?w5
   \   000067 72BB ....    ADDW      X, S:?w0
   \   00006B 9093         LDW       Y, X
   \   00006D BE ..        LDW       X, S:?w0
   \   00006F 72BB ....    ADDW      X, S:?w7
   \   000073 F6           LD        A, (X)
   \   000074 90F7         LD        (Y), A
    804            }
   \   000076 BE ..        LDW       X, S:?w0
   \   000078 5C           INCW      X
   \   000079 BF ..        LDW       S:?w0, X
   \                     ??FLASH_ProgramBlock_4:
   \   00007B BE ..        LDW       X, S:?w0
   \   00007D A3 0080      CPW       X, #0x80
   \   000080 25 E3        JRC       L:??FLASH_ProgramBlock_5
    805          }
   \   000082 32 ....      POP       S:?b12
   \   000085 8D ......    CALLF     L:?pop_w7
   \   000089 AC ......    JPF       L:?epilogue_l2
    806          
    807          /**
    808            * @brief  Erases a block in the program or data memory.
    809            * @note   This function should be called and executed from RAM.
    810            * @param  BlockNum : Indicates the block number to erase
    811            * @param  FLASH_MemType :  The type of memory to erase
    812            *          This parameter can be one of the following values:
    813            *            @arg FLASH_MemType_Program: Program memory
    814            *            @arg FLASH_MemType_Data: Data EEPROM memory 
    815            * @retval None.
    816            */

   \                                 In section .far_func.text, align 1
    817          IN_RAM(void FLASH_EraseBlock(uint16_t BlockNum, FLASH_MemType_TypeDef FLASH_MemType))
    818          {
   \                     FLASH_EraseBlock:
   \   000000 9093         LDW       Y, X
    819            uint32_t startaddress = 0;
   \   000002 5F           CLRW      X
   \   000003 BF ..        LDW       S:?w3, X
   \   000005 BF ..        LDW       S:?w2, X
    820          #if defined (STM8L15X_MD) || defined (STM8L15X_MDP) || defined (STM8L15X_LD) || \
    821            defined (STM8L05X_LD_VL) || defined (STM8L05X_MD_VL) || defined (STM8AL31_L_MD)
    822              uint32_t PointerAttr  *pwFlash;
    823            
    824          #elif defined (STM8L15X_HD) || defined (STM8L05X_HD_VL)
    825            uint8_t PointerAttr  *pwFlash;
    826          #endif
    827            
    828            /* Check parameters */
    829            assert_param(IS_FLASH_MEMORY_TYPE(FLASH_MemType));
    830            if(FLASH_MemType == FLASH_MemType_Program)
   \   000007 A1 FD        CP        A, #0xfd
   \   000009 26 0A        JRNE      L:??FLASH_EraseBlock_0
    831            {
    832              assert_param(IS_FLASH_PROGRAM_BLOCK_NUMBER(BlockNum));
    833              startaddress = FLASH_PROGRAM_START_PHYSICAL_ADDRESS;
   \   00000B AE 8000      LDW       X, #0x8000
   \   00000E BF ..        LDW       S:?w3, X
   \   000010 58           SLLW      X
   \   000011 BF ..        LDW       S:?w2, X
   \   000013 20 08        JRA       L:??FLASH_EraseBlock_1
    834            }
    835            else
    836            {
    837              assert_param(IS_FLASH_DATA_EEPROM_BLOCK_NUMBER(BlockNum));
    838              startaddress = FLASH_DATA_EEPROM_START_PHYSICAL_ADDRESS;
   \                     ??FLASH_EraseBlock_0:
   \   000015 AE 1000      LDW       X, #0x1000
   \   000018 BF ..        LDW       S:?w3, X
   \   00001A 5F           CLRW      X
   \   00001B BF ..        LDW       S:?w2, X
    839            }
    840            
    841            /* Point to the first block address */
    842          #if defined (STM8L15X_MD) || defined (STM8L15X_MDP)|| defined (STM8L15X_LD) || \
    843            defined (STM8L05X_LD_VL) || defined (STM8L05X_MD_VL) || defined (STM8AL31_L_MD)
    844              pwFlash = (PointerAttr uint32_t *)(uint16_t)(startaddress + ((uint32_t)BlockNum * FLASH_BLOCK_SIZE));
   \                     ??FLASH_EraseBlock_1:
   \   00001D AE 0080      LDW       X, #0x80
   \   000020 BF ..        LDW       S:?w0, X
   \   000022 93           LDW       X, Y
   \   000023 8D ......    CALLF     L:?mul16_x_x_w0
   \   000027 90BE ..      LDW       Y, S:?w3
   \   00002A BF ..        LDW       S:?w0, X
   \   00002C 72B9 ....    ADDW      Y, S:?w0
    845            
    846          #elif defined (STM8L15X_HD) || defined (STM8L05X_HD_VL)
    847            pwFlash = (PointerAttr uint8_t *)(uint32_t)(startaddress + ((uint32_t)BlockNum * FLASH_BLOCK_SIZE));
    848          #endif
    849            
    850            /* Enable erase block mode */
    851            FLASH->CR2 |= FLASH_CR2_ERASE;
   \   000030 721A 5051    BSET      L:0x5051, #0x5
    852            
    853          #if defined (STM8L15X_MD) || defined (STM8L15X_MDP) || defined (STM8L15X_LD) || \
    854            defined (STM8L05X_LD_VL) || defined (STM8L05X_MD_VL) || defined (STM8AL31_L_MD)
    855              *pwFlash = (uint32_t)0;  
   \   000034 5F           CLRW      X
   \   000035 BF ..        LDW       S:?w1, X
   \   000037 BF ..        LDW       S:?w0, X
   \   000039 93           LDW       X, Y
   \   00003A AC ......    JPF       L:?load32_0x_l0
    856            
    857          #elif defined (STM8L15X_HD) || defined (STM8L05X_HD_VL)
    858            *pwFlash = (uint8_t)0;
    859            *(pwFlash + 1) = (uint8_t)0;
    860            *(pwFlash + 2) = (uint8_t)0;
    861            *(pwFlash + 3) = (uint8_t)0;
    862          #endif
    863          }
    864          
    865          /**
    866            * @brief  Waits for a Flash operation to complete.
    867            * @note   The call and execution of this function must be done from RAM in case
    868            *         of Block operation, otherwise it can be executed from Flash
    869            * @param  FLASH_MemType : Memory type
    870            *          This parameter can be one of the following values:
    871            *            @arg FLASH_MemType_Program: Program memory
    872            *            @arg FLASH_MemType_Data: Data EEPROM memory 
    873            * @retval FLASH status
    874            */

   \                                 In section .far_func.text, align 1
    875          IN_RAM(FLASH_Status_TypeDef FLASH_WaitForLastOperation(FLASH_MemType_TypeDef FLASH_MemType))
    876          {
    877            uint16_t timeout = OPERATION_TIMEOUT;
   \                     FLASH_WaitForLastOperation:
   \   000000 5F           CLRW      X
   \   000001 5A           DECW      X
    878            uint8_t flagstatus = 0x00;
   \   000002 3F ..        CLR       S:?b0
    879            
    880            /* Wait until operation completion or write protected page occurred */
    881            if(FLASH_MemType == FLASH_MemType_Program)
   \   000004 A1 FD        CP        A, #0xfd
   \   000006 26 19        JRNE      L:??FLASH_WaitForLastOperation_0
    882            {
    883              while((flagstatus == 0x00) && (timeout != 0x00))
   \                     ??FLASH_WaitForLastOperation_1:
   \   000008 3D ..        TNZ       S:?b0
   \   00000A 26 1C        JRNE      L:??FLASH_WaitForLastOperation_2
   \   00000C 5D           TNZW      X
   \   00000D 27 19        JREQ      L:??FLASH_WaitForLastOperation_2
    884              {
    885                flagstatus = (uint8_t)(FLASH->IAPSR & (uint8_t)(FLASH_IAPSR_EOP |
    886                                                                FLASH_IAPSR_WR_PG_DIS));
   \   00000F C6 5054      LD        A, L:0x5054
   \   000012 A4 05        AND       A, #0x5
   \   000014 B7 ..        LD        S:?b0, A
    887                timeout--;
   \   000016 5A           DECW      X
   \   000017 20 EF        JRA       L:??FLASH_WaitForLastOperation_1
    888              }
    889            }
    890            else
    891            {
    892              while((flagstatus == 0x00) && (timeout != 0x00))
    893              {
    894                flagstatus = (uint8_t)(FLASH->IAPSR & (uint8_t)(FLASH_IAPSR_HVOFF |
    895                                                                FLASH_IAPSR_WR_PG_DIS));
   \                     ??FLASH_WaitForLastOperation_3:
   \   000019 C6 5054      LD        A, L:0x5054
   \   00001C A4 41        AND       A, #0x41
   \   00001E B7 ..        LD        S:?b0, A
    896                timeout--;
   \   000020 5A           DECW      X
    897              }
   \                     ??FLASH_WaitForLastOperation_0:
   \   000021 3D ..        TNZ       S:?b0
   \   000023 26 03        JRNE      L:??FLASH_WaitForLastOperation_2
   \   000025 5D           TNZW      X
   \   000026 26 F1        JRNE      L:??FLASH_WaitForLastOperation_3
    898            }
    899            
    900            if(timeout == 0x00)
   \                     ??FLASH_WaitForLastOperation_2:
   \   000028 5D           TNZW      X
   \   000029 26 04        JRNE      L:??FLASH_WaitForLastOperation_4
    901            {
    902              flagstatus = FLASH_Status_TimeOut;
   \   00002B 35 02 ....   MOV       S:?b0, #0x2
    903            }
    904            
    905            return((FLASH_Status_TypeDef)flagstatus);
   \                     ??FLASH_WaitForLastOperation_4:
   \   00002F B6 ..        LD        A, S:?b0
   \   000031 87           RETF
    906          }
    907          
    908          #if defined (_COSMIC_) && defined (RAM_EXECUTION)
    909           /* End of FLASH_CODE section */
    910           #pragma section ()
    911          #endif /* _COSMIC_ && RAM_EXECUTION */
    912          
    913          /**
    914            * @}
    915            */
    916          
    917          /**
    918            * @}
    919            */
    920             
    921            /**
    922            * @}
    923            */ 
    924            
    925            /**
    926            * @}
    927            */ 
    928            
    929          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Section sizes:

   Bytes  Function/Label
   -----  --------------
      16  FLASH_DeInit
      62  FLASH_EraseBlock
       5  FLASH_EraseByte
      17  FLASH_EraseOptionByte
      36  FLASH_GetBootSize
      36  FLASH_GetCodeSize
      20  FLASH_GetFlagStatus
       6  FLASH_GetPowerStatus
       6  FLASH_GetProgrammingTime
      20  FLASH_GetReadOutProtectionStatus
      13  FLASH_ITConfig
       7  FLASH_Lock
      14  FLASH_PowerRunModeConfig
      14  FLASH_PowerWaitModeConfig
     141  FLASH_ProgramBlock
       4  FLASH_ProgramByte
      16  FLASH_ProgramOptionByte
      38  FLASH_ProgramWord
       4  FLASH_ReadByte
      11  FLASH_SetProgrammingTime
      25  FLASH_Unlock
      50  FLASH_WaitForLastOperation

 
 561 bytes in section .far_func.text
 
 561 bytes of CODE memory

Errors: none
Warnings: none
