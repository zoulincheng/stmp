###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.42.1.142 for STM8               01/Jul/2016  17:30:49 #
# Copyright 2010-2013 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  E:\hwpro-2016\20160627_L\stm8l15x_lib\src\stm8l15x_pwr.c #
#    Command line =  E:\hwpro-2016\20160627_L\stm8l15x_lib\src\stm8l15x_pwr.c #
#                     -e -Ol --no_cse --no_unroll --no_inline                 #
#                    --no_code_motion --no_tbaa --no_cross_call --debug       #
#                    --code_model medium --data_model medium -o               #
#                    E:\hwpro-2016\20160627_L\iar\Debug\Obj\ --dlib_config    #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.5\stm8\LIB\dlstm8mmn.h" -D STM8L15X_MD -lC             #
#                    E:\hwpro-2016\20160627_L\iar\Debug\List\ -I              #
#                    E:\hwpro-2016\20160627_L\iar\..\stm8l15x_lib\inc\ -I     #
#                    E:\hwpro-2016\20160627_L\iar\..\user\inc\ -I             #
#                    E:\hwpro-2016\20160627_L\iar\..\utils\xprintf\ -I        #
#                    E:\hwpro-2016\20160627_L\iar\..\drivers\ -I              #
#                    E:\hwpro-2016\20160627_L\iar\..\utils\ -I                #
#                    E:\hwpro-2016\20160627_L\iar\..\app\ --vregs 16          #
#    List file    =  E:\hwpro-2016\20160627_L\iar\Debug\List\stm8l15x_pwr.lst #
#    Object file  =  E:\hwpro-2016\20160627_L\iar\Debug\Obj\stm8l15x_pwr.o    #
#                                                                             #
#                                                                             #
###############################################################################

E:\hwpro-2016\20160627_L\stm8l15x_lib\src\stm8l15x_pwr.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm8l15x_pwr.c
      4            * @author  MCD Application Team
      5            * @version V1.6.1
      6            * @date    30-September-2014
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Power Controller (PWR) peripheral:           
      9            *           - PVD configuration
     10            *           - Ultra Low Power mode configuration
     11            *           - Interrupts and flags management
     12            *               
     13            ******************************************************************************
     14            * @attention
     15            *
     16            * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
     17            *
     18            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     19            * You may not use this file except in compliance with the License.
     20            * You may obtain a copy of the License at:
     21            *
     22            *        http://www.st.com/software_license_agreement_liberty_v2
     23            *
     24            * Unless required by applicable law or agreed to in writing, software 
     25            * distributed under the License is distributed on an "AS IS" BASIS, 
     26            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     27            * See the License for the specific language governing permissions and
     28            * limitations under the License.
     29            *
     30            ******************************************************************************
     31            */
     32          
     33          /* Includes ------------------------------------------------------------------*/
     34          #include "stm8l15x_pwr.h"
     35          
     36          /** @addtogroup STM8L15x_StdPeriph_Driver
     37            * @{
     38            */
     39          
     40          /** @defgroup PWR 
     41            * @brief PWR driver modules
     42            * @{
     43            */
     44            
     45          /* Private typedef -----------------------------------------------------------*/
     46          /* Private define ------------------------------------------------------------*/
     47          /* Private macro -------------------------------------------------------------*/
     48          /* Private variables ---------------------------------------------------------*/
     49          /* Private function prototypes -----------------------------------------------*/
     50          /* Private functions ---------------------------------------------------------*/
     51          
     52          /** @defgroup PWR_Private_Functions
     53            * @{
     54            */
     55          
     56          /** @defgroup PWR_Group1 PVD configuration functions
     57           *  @brief   PVD configuration functions 
     58           *
     59          @verbatim   
     60           ===============================================================================
     61                                     PVD configuration functions
     62           ===============================================================================  
     63          
     64           - The PVD is used to monitor the VDD power supply by comparing it to a threshold
     65             selected by the PVD Level (PLS[2:0] bits in the PWR_CSR1).
     66           - The PVD can use an external input analog voltage (PVD_IN) which is compared 
     67             internally to VREFINT. The PVD_IN (PE6) has to be configured in Analog mode 
     68             when PWR_PVDLevel_PVDIn is selected (PLS[2:0] = 111).
     69           - A PVDO flag is available to indicate if VDD/VDDA is higher or lower than the 
     70             PVD threshold. An interrupt is generated in case enabled for PVD. 
     71           - The PVD interrup event has the capability to wake up the CPU from Halt/Active Halt modes.
     72          
     73          @endverbatim
     74            * @{
     75            */
     76              
     77          /**
     78            * @brief  Deinitializes the PWR peripheral registers to their default reset values.
     79            * @param  None
     80            * @retval None
     81            */

   \                                 In section .far_func.text, align 1
     82          void PWR_DeInit(void)
     83          {
     84            PWR->CSR1 = PWR_CSR1_PVDIF;
   \                     PWR_DeInit:
   \   000000 35 20 50B2   MOV       L:0x50b2, #0x20
     85            PWR->CSR2 = PWR_CSR2_RESET_VALUE;
   \   000004 35 00 50B3   MOV       L:0x50b3, #0x0
     86          }
   \   000008 87           RETF
     87          
     88          /**
     89            * @brief  Configures the voltage threshold detected by the Power Voltage Detector(PVD).
     90            * @param  PWR_PVDLevel: specifies the PVD detection level
     91            *          This parameter can be one of the following values:
     92            *            @arg PWR_PVDLevel_1V85: PVD detection level set to 1.85V
     93            *            @arg PWR_PVDLevel_2V05: PVD detection level set to 2.05V
     94            *            @arg PWR_PVDLevel_2V26: PVD detection level set to 2.26V
     95            *            @arg PWR_PVDLevel_2V45: PVD detection level set to 2.45V
     96            *            @arg PWR_PVDLevel_2V65: PVD detection level set to 2.65V
     97            *            @arg PWR_PVDLevel_2V85: PVD detection level set to 2.85V
     98            *            @arg PWR_PVDLevel_3V05: PVD detection level set to 3.05V
     99            *            @arg PWR_PVDLevel_PVDIn: External input analog voltage (Compare internally to VREFINT)
    100            * @retval None
    101            */

   \                                 In section .far_func.text, align 1
    102          void PWR_PVDLevelConfig(PWR_PVDLevel_TypeDef PWR_PVDLevel)
    103          {
   \                     PWR_PVDLevelConfig:
   \   000000 B7 ..        LD        S:?b0, A
    104            /* Check the parameters */
    105            assert_param(IS_PWR_PVD_LEVEL(PWR_PVDLevel));
    106          
    107            /* Clear the PVD level */
    108            PWR->CSR1 &= (uint8_t)(~PWR_CSR1_PLS);
   \   000002 C6 50B2      LD        A, L:0x50b2
   \   000005 A4 F1        AND       A, #0xf1
   \   000007 C7 50B2      LD        L:0x50b2, A
    109          
    110            /* Configure the PVD level */
    111            PWR->CSR1 |= PWR_PVDLevel;
   \   00000A B6 ..        LD        A, S:?b0
   \   00000C CA 50B2      OR        A, L:0x50b2
   \   00000F C7 50B2      LD        L:0x50b2, A
    112          
    113          }
   \   000012 87           RETF
    114          
    115          /**
    116            * @brief  Enables or disables the Power Voltage Detector(PVD).
    117            * @param  NewState: new state of the PVD.
    118            *          This parameter can be: ENABLE or DISABLE.
    119            * @retval None
    120            */

   \                                 In section .far_func.text, align 1
    121          void PWR_PVDCmd(FunctionalState NewState)
    122          {
    123            /* Check the parameters */
    124            assert_param(IS_FUNCTIONAL_STATE(NewState));
    125          
    126            if (NewState != DISABLE)
   \                     PWR_PVDCmd:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??PWR_PVDCmd_0
    127            {
    128              /* Enable the PWR PVD */
    129              PWR->CSR1 |= PWR_CSR1_PVDE;
   \   000003 7210 50B2    BSET      L:0x50b2, #0x0
   \   000007 87           RETF
    130            }
    131            else
    132            {
    133              /* Disable the PWR PVD */
    134              PWR->CSR1 &= (uint8_t)(~PWR_CSR1_PVDE);
   \                     ??PWR_PVDCmd_0:
   \   000008 7211 50B2    BRES      L:0x50b2, #0x0
    135            }
    136          }
   \   00000C 87           RETF
    137          
    138          /**
    139            * @}
    140            */
    141          
    142          /** @defgroup PWR_Group2 Ultra Low Power mode configuration functions
    143           *  @brief   Ultra Low Power mode configuration functions 
    144           *
    145          @verbatim   
    146           ===============================================================================
    147                              Ultra Low Power mode configuration functions
    148           ===============================================================================  
    149          
    150           - The internal voltage reference consumption is not negligible, in particular 
    151             in Halt and Active Halt modes. To reduce power consumption, use the PWR_UltraLowPowerCmd()
    152             function (ULP bit (Ultra low power) in the PWR_CSR2 register) to disable the 
    153             internal voltage reference. However, in this case, when exiting from the 
    154             Halt/Active Halt modes, the functions managed through the internal voltage reference 
    155             are not reliable during the internal voltage reference startup time (up to 3 ms).
    156             To reduce the wakeup time, the device can exit from Halt/Active Halt modes without 
    157             waiting for the internal voltage reference startup time. This is performed 
    158             by using the PWR_FastWakeUpCmd() function (setting the FWU bit (Fast
    159             wakeup) in the PWR_CSR2 register) before entering Halt/Active Halt mode.
    160          
    161          @endverbatim
    162            * @{
    163            */
    164            
    165          /**
    166            * @brief  Enables or disables the Fast WakeUp from Ultra Low Power mode.
    167            * @param  NewState: new state of the Fast WakeUp  functionality.
    168            *          This parameter can be: ENABLE or DISABLE.
    169            * @retval None
    170            */

   \                                 In section .far_func.text, align 1
    171          void PWR_FastWakeUpCmd(FunctionalState NewState)
    172          {
    173            /* Check the parameters */
    174            assert_param(IS_FUNCTIONAL_STATE(NewState));
    175          
    176            if (NewState != DISABLE)
   \                     PWR_FastWakeUpCmd:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??PWR_FastWakeUpCmd_0
    177            {
    178              /* Enable the PWR FWU */
    179              PWR->CSR2 |= PWR_CSR2_FWU;
   \   000003 7214 50B3    BSET      L:0x50b3, #0x2
   \   000007 87           RETF
    180            }
    181            else
    182            {
    183              /* Disable the PWR FWU */
    184              PWR->CSR2 &= (uint8_t)(~PWR_CSR2_FWU);
   \                     ??PWR_FastWakeUpCmd_0:
   \   000008 7215 50B3    BRES      L:0x50b3, #0x2
    185            }
    186          }
   \   00000C 87           RETF
    187          
    188          /**
    189            * @brief  Enables or disables the Ultra Low Power mode.
    190            * @param  NewState: new state of the Ultra Low Power mode.
    191            *          This parameter can be: ENABLE or DISABLE.
    192            * @retval None
    193            */

   \                                 In section .far_func.text, align 1
    194          void PWR_UltraLowPowerCmd(FunctionalState NewState)
    195          {
    196            /* Check the parameters */
    197            assert_param(IS_FUNCTIONAL_STATE(NewState));
    198          
    199            if (NewState != DISABLE)
   \                     PWR_UltraLowPowerCmd:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??PWR_UltraLowPowerCmd_0
    200            {
    201              /* Enable the PWR ULP */
    202              PWR->CSR2 |= PWR_CSR2_ULP;
   \   000003 7212 50B3    BSET      L:0x50b3, #0x1
   \   000007 87           RETF
    203            }
    204            else
    205            {
    206              /* Disable the PWR ULP */
    207              PWR->CSR2 &= (uint8_t)(~PWR_CSR2_ULP);
   \                     ??PWR_UltraLowPowerCmd_0:
   \   000008 7213 50B3    BRES      L:0x50b3, #0x1
    208            }
    209          }
   \   00000C 87           RETF
    210          
    211          /**
    212            * @}
    213            */
    214          
    215          /** @defgroup PWR_Group3 Interrupts and Flags management functions
    216           *  @brief   Interrupts and Flags management functions 
    217           *
    218          @verbatim   
    219           ===============================================================================
    220                           Interrupts and Flags management functions
    221           ===============================================================================  
    222          
    223          @endverbatim
    224            * @{
    225            */
    226          
    227          /**
    228            * @brief  Configures the Programmable Voltage Detector (PVD) Interrupt .
    229            * @param  NewState : Indicates the new state of the PVD interrupt.
    230            * @retval None
    231            */

   \                                 In section .far_func.text, align 1
    232          void PWR_PVDITConfig(FunctionalState NewState)
    233          {
    234            /* Check the parameters */
    235            assert_param(IS_FUNCTIONAL_STATE(NewState));
    236          
    237            if (NewState != DISABLE)
   \                     PWR_PVDITConfig:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??PWR_PVDITConfig_0
    238            {
    239              /* Enable the PVD interrupt */
    240              PWR->CSR1 |= PWR_CSR1_PVDIEN;
   \   000003 7218 50B2    BSET      L:0x50b2, #0x4
   \   000007 87           RETF
    241            }
    242            else
    243            {
    244              /* Disable the PVD interrupt */
    245              PWR->CSR1 &= (uint8_t)(~PWR_CSR1_PVDIEN);
   \                     ??PWR_PVDITConfig_0:
   \   000008 7219 50B2    BRES      L:0x50b2, #0x4
    246            }
    247          }
   \   00000C 87           RETF
    248          
    249          /**
    250            * @brief  Checks whether the specified PWR flag is set or not.
    251            * @param  PWR_FLAG: specifies the flag to check.
    252            *          This parameter can be one of the following values:
    253            *            @arg PWR_FLAG_PVDOF: PVD Output. This flag is valid only if PVD is enabled 
    254            *                                 by the PWR_PVDCmd() function.
    255            *            @arg PWR_FLAG_VREFINTF: Internal Voltage Reference Ready flag. This 
    256            *                                    flag indicates the state of the internal voltage reference, VREFINT.
    257            *            @arg PWR_FLAG_PVDIF: PVD Interrupt Flag, it's set by hardware when a PVD
    258            *       event occurs  
    259            * @retval The new state of PWR_FLAG (SET or RESET).
    260            */

   \                                 In section .far_func.text, align 1
    261          FlagStatus PWR_GetFlagStatus(PWR_FLAG_TypeDef PWR_FLAG)
    262          {
   \                     PWR_GetFlagStatus:
   \   000000 B7 ..        LD        S:?b1, A
    263            FlagStatus bitstatus = RESET;
   \   000002 3F ..        CLR       S:?b0
    264          
    265            /* Check the parameters */
    266            assert_param(IS_PWR_FLAG(PWR_FLAG));
    267          
    268            if ((PWR_FLAG & PWR_FLAG_VREFINTF) != 0)
   \   000004 B6 ..        LD        A, S:?b1
   \   000006 A4 01        AND       A, #0x1
   \   000008 A1 00        CP        A, #0x0
   \   00000A 27 0F        JREQ      L:??PWR_GetFlagStatus_0
    269            {
    270              if ((PWR->CSR2 & PWR_CR2_VREFINTF) != (uint8_t)RESET )
   \   00000C 7201 50B3 06 BTJF      L:0x50b3, #0x0, L:??PWR_GetFlagStatus_1
    271              {
    272                bitstatus = SET;
   \   000011 35 01 ....   MOV       S:?b0, #0x1
   \   000015 20 15        JRA       L:??PWR_GetFlagStatus_2
    273              }
    274              else
    275              {
    276                bitstatus = RESET;
   \                     ??PWR_GetFlagStatus_1:
   \   000017 3F ..        CLR       S:?b0
   \   000019 20 11        JRA       L:??PWR_GetFlagStatus_2
    277              }
    278            }
    279            else
    280            {
    281              if ((PWR->CSR1 & PWR_FLAG) != (uint8_t)RESET )
   \                     ??PWR_GetFlagStatus_0:
   \   00001B B6 ..        LD        A, S:?b1
   \   00001D C4 50B2      AND       A, L:0x50b2
   \   000020 A1 00        CP        A, #0x0
   \   000022 27 06        JREQ      L:??PWR_GetFlagStatus_3
    282              {
    283                bitstatus = SET;
   \   000024 35 01 ....   MOV       S:?b0, #0x1
   \   000028 20 02        JRA       L:??PWR_GetFlagStatus_2
    284              }
    285              else
    286              {
    287                bitstatus = RESET;
   \                     ??PWR_GetFlagStatus_3:
   \   00002A 3F ..        CLR       S:?b0
    288              }
    289            }
    290          
    291            /* Return the flag status */
    292            return((FlagStatus)bitstatus);
   \                     ??PWR_GetFlagStatus_2:
   \   00002C B6 ..        LD        A, S:?b0
   \   00002E 87           RETF
    293          }
    294          
    295          /**
    296            * @brief  Clears the PWR PVDIF Flag.
    297            * @param  None
    298            * @retval None
    299            */

   \                                 In section .far_func.text, align 1
    300          void PWR_PVDClearFlag(void)
    301          {
    302            /* Set the PVDIF to clear it */
    303            PWR->CSR1 |= PWR_CSR1_PVDIF;
   \                     PWR_PVDClearFlag:
   \   000000 721A 50B2    BSET      L:0x50b2, #0x5
    304          }
   \   000004 87           RETF
    305          
    306          /**
    307            * @brief  Checks whether the PVD interrupt has occurred or not.
    308            * @param  None
    309            * @retval The new state of the PVD Interrupt (SET or RESET).
    310            */

   \                                 In section .far_func.text, align 1
    311          ITStatus PWR_PVDGetITStatus(void)
    312          {
    313            ITStatus bitstatus = RESET;
   \                     PWR_PVDGetITStatus:
   \   000000 3F ..        CLR       S:?b0
    314          
    315            uint8_t PVD_itStatus = 0x0, PVD_itEnable = 0x0;
   \   000002 3F ..        CLR       S:?b2
   \   000004 3F ..        CLR       S:?b1
    316          
    317            PVD_itStatus = (uint8_t)(PWR->CSR1 & (uint8_t)PWR_CSR1_PVDIF);
   \   000006 C6 50B2      LD        A, L:0x50b2
   \   000009 A4 20        AND       A, #0x20
   \   00000B B7 ..        LD        S:?b2, A
    318            PVD_itEnable = (uint8_t)(PWR->CSR1 & (uint8_t)PWR_CSR1_PVDIEN);
   \   00000D C6 50B2      LD        A, L:0x50b2
   \   000010 A4 10        AND       A, #0x10
   \   000012 B7 ..        LD        S:?b1, A
    319          
    320            if ((PVD_itStatus != (uint8_t)RESET ) && (PVD_itEnable != (uint8_t)RESET))
   \   000014 3D ..        TNZ       S:?b2
   \   000016 27 0A        JREQ      L:??PWR_PVDGetITStatus_0
   \   000018 3D ..        TNZ       S:?b1
   \   00001A 27 06        JREQ      L:??PWR_PVDGetITStatus_0
    321            {
    322              bitstatus = (ITStatus)SET;
   \   00001C 35 01 ....   MOV       S:?b0, #0x1
   \   000020 20 02        JRA       L:??PWR_PVDGetITStatus_1
    323            }
    324            else
    325            {
    326              bitstatus = (ITStatus)RESET;
   \                     ??PWR_PVDGetITStatus_0:
   \   000022 3F ..        CLR       S:?b0
    327            }
    328            return ((ITStatus)bitstatus);
   \                     ??PWR_PVDGetITStatus_1:
   \   000024 B6 ..        LD        A, S:?b0
   \   000026 87           RETF
    329          }
    330          
    331          /**
    332            * @brief  Clears the PWR interrupt pending bit.
    333            * @param  None
    334            * @retval None
    335            */

   \                                 In section .far_func.text, align 1
    336          void PWR_PVDClearITPendingBit(void)
    337          {
    338            /* Set the PVDIF to clear it */
    339            PWR->CSR1 |= PWR_CSR1_PVDIF;
   \                     PWR_PVDClearITPendingBit:
   \   000000 721A 50B2    BSET      L:0x50b2, #0x5
    340          }
   \   000004 87           RETF
    341          
    342          /**
    343            * @}
    344            */
    345          
    346          /**
    347            * @}
    348            */
    349            
    350          /**
    351            * @}
    352            */
    353          
    354          /**
    355            * @}
    356            */
    357          
    358          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Section sizes:

   Bytes  Function/Label
   -----  --------------
       9  PWR_DeInit
      13  PWR_FastWakeUpCmd
      47  PWR_GetFlagStatus
       5  PWR_PVDClearFlag
       5  PWR_PVDClearITPendingBit
      13  PWR_PVDCmd
      39  PWR_PVDGetITStatus
      13  PWR_PVDITConfig
      19  PWR_PVDLevelConfig
      13  PWR_UltraLowPowerCmd

 
 176 bytes in section .far_func.text
 
 176 bytes of CODE memory

Errors: none
Warnings: none
