###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.42.1.142 for STM8               01/Jul/2016  17:30:48 #
# Copyright 2010-2013 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  E:\hwpro-2016\20160627_L\stm8l15x_lib\src\stm8l15x_i2c.c #
#    Command line =  E:\hwpro-2016\20160627_L\stm8l15x_lib\src\stm8l15x_i2c.c #
#                     -e -Ol --no_cse --no_unroll --no_inline                 #
#                    --no_code_motion --no_tbaa --no_cross_call --debug       #
#                    --code_model medium --data_model medium -o               #
#                    E:\hwpro-2016\20160627_L\iar\Debug\Obj\ --dlib_config    #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.5\stm8\LIB\dlstm8mmn.h" -D STM8L15X_MD -lC             #
#                    E:\hwpro-2016\20160627_L\iar\Debug\List\ -I              #
#                    E:\hwpro-2016\20160627_L\iar\..\stm8l15x_lib\inc\ -I     #
#                    E:\hwpro-2016\20160627_L\iar\..\user\inc\ -I             #
#                    E:\hwpro-2016\20160627_L\iar\..\utils\xprintf\ -I        #
#                    E:\hwpro-2016\20160627_L\iar\..\drivers\ -I              #
#                    E:\hwpro-2016\20160627_L\iar\..\utils\ -I                #
#                    E:\hwpro-2016\20160627_L\iar\..\app\ --vregs 16          #
#    List file    =  E:\hwpro-2016\20160627_L\iar\Debug\List\stm8l15x_i2c.lst #
#    Object file  =  E:\hwpro-2016\20160627_L\iar\Debug\Obj\stm8l15x_i2c.o    #
#                                                                             #
#                                                                             #
###############################################################################

E:\hwpro-2016\20160627_L\stm8l15x_lib\src\stm8l15x_i2c.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm8l15x_i2c.c
      4            * @author  MCD Application Team
      5            * @version V1.6.1
      6            * @date    30-September-2014
      7            * @brief   This file provides firmware functions to manage the following
      8            *          functionalities of the Inter-integrated circuit (I2C)
      9            *           - Initialization and Configuration
     10            *           - Data transfers
     11            *           - PEC management
     12            *           - DMA transfers management
     13            *           - Interrupts, events and flags management
     14            *
     15            *  @verbatim
     16            *
     17            *          ===================================================================
     18            *                                 How to use this driver
     19            *          ===================================================================
     20            *          1. Enable peripheral clock using CLK_PeripheralClockConfig(CLK_Peripheral_I2Cx,
     21            *             ENABLE) function (Refer to the product datasheet for the available I2C
     22            *           	peripherals)
     23            *
     24            *
     25            *          2. Program the Mode, duty cycle , Own address, Ack, Speed and Acknowledged
     26            *             Address using the I2C_Init() function.
     27            *
     28            *          3. Optionally you can enable/configure the following parameters without
     29            *             re-initialization (i.e there is no need to call again I2C_Init() function):
     30            *              - Enable the acknowledge feature using I2C_AcknowledgeConfig() function
     31            *              - Enable the dual addressing mode using I2C_DualAddressCmd() function
     32            *              - Enable the general call using the I2C_GeneralCallCmd() function
     33            *              - Enable the clock stretching using I2C_StretchClockCmd() function
     34            *              - Enable the fast mode duty cycle using the I2C_FastModeDutyCycleConfig()
     35            *                function
     36            *              - Enable the PEC Calculation using I2C_CalculatePEC() function
     37            *              - For SMBus Mode:
     38            *                   - Enable the Address Resolution Protocol (ARP) using I2C_ARPCmd() function
     39            *                   - Configure the SMBusAlert pin using I2C_SMBusAlertConfig() function
     40            *
     41            *          4. Enable the interrupt using the function I2C_ITConfig() if you need
     42            *             to use interrupt mode.
     43            *
     44            *          5. When using the DMA mode
     45            *                   - Configure the DMA using DMA_Init() function
     46            *                   - Active the needed channel Request using I2C_DMACmd() or
     47            *                     I2C_DMALastTransferCmd() function
     48            *              Note: When using DMA mode, I2C interrupts may be used at the same time to
     49            *                    control the communication flow (Start/Stop/Ack... events and errors).
     50            *
     51            *          6. Enable the I2C using the I2C_Cmd() function.
     52            *
     53            *          7. Enable the DMA using the DMA_Cmd() function when using DMA mode in the
     54            *             transfers.
     55            *
     56            *         Note: The external Pull-up resistors must be connected on SDA and SCL.
     57            *
     58            *  @endverbatim
     59            *
     60            ******************************************************************************
     61            * @attention
     62            *
     63            * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
     64            *
     65            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     66            * You may not use this file except in compliance with the License.
     67            * You may obtain a copy of the License at:
     68            *
     69            *        http://www.st.com/software_license_agreement_liberty_v2
     70            *
     71            * Unless required by applicable law or agreed to in writing, software 
     72            * distributed under the License is distributed on an "AS IS" BASIS, 
     73            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     74            * See the License for the specific language governing permissions and
     75            * limitations under the License.
     76            *
     77            ******************************************************************************
     78            */
     79          
     80          /* Includes ------------------------------------------------------------------*/
     81          #include "stm8l15x_i2c.h"
     82          #include "stm8l15x_clk.h"
     83          
     84          /** @addtogroup STM8L15x_StdPeriph_Driver
     85            * @{
     86            */
     87          
     88          /** @defgroup I2C
     89            * @brief I2C driver modules
     90            * @{
     91            */
     92          
     93          /* Private typedef -----------------------------------------------------------*/
     94          /* Private define ------------------------------------------------------------*/
     95          /** @defgroup I2C_Private_Define
     96            * @{
     97            */
     98          
     99          /* I2C register mask */
    100          #define REGISTER_Mask               ((uint16_t)0x3000)
    101          #define REGISTER_SR1_Index          ((uint16_t)0x0100)
    102          #define REGISTER_SR2_Index          ((uint16_t)0x0200)
    103          /* I2C Interrupt Enable mask */
    104          #define ITEN_Mask                   ((uint16_t)0x0700)
    105          /* I2C FLAG mask */
    106          #define FLAG_Mask                   ((uint16_t)0x00FF)
    107          /* I2C ADD0 mask */
    108          #define OAR1_ADD0_Set               ((uint8_t)0x01)
    109          #define OAR1_ADD0_Reset             ((uint8_t)0xFE)
    110          
    111          /**
    112            * @}
    113            */
    114          
    115          /* Private macro -------------------------------------------------------------*/
    116          /* Private variables ---------------------------------------------------------*/
    117          /* Private function prototypes -----------------------------------------------*/
    118          /* Private functions ---------------------------------------------------------*/
    119          
    120          /** @defgroup I2C_Private_Functions
    121            * @{
    122            */
    123          
    124          /** @defgroup I2C_Group1 Initialization and Configuration functions
    125           *  @brief   Initialization and Configuration functions
    126           *
    127          @verbatim
    128           ===============================================================================
    129                             Initialization and Configuration functions
    130           ===============================================================================
    131          
    132          @endverbatim
    133            * @{
    134            */
    135          
    136          /**
    137            * @brief  Deinitializes the I2C peripheral registers to their default reset values.
    138            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
    139            * @retval None
    140            */

   \                                 In section .far_func.text, align 1
    141          void I2C_DeInit(I2C_TypeDef* I2Cx)
    142          {
    143            I2Cx->CR1 = I2C_CR1_RESET_VALUE;
   \                     I2C_DeInit:
   \   000000 4F           CLR       A
   \   000001 F7           LD        (X), A
    144            I2Cx->CR2 = I2C_CR2_RESET_VALUE;
   \   000002 9093         LDW       Y, X
   \   000004 905C         INCW      Y
   \   000006 4F           CLR       A
   \   000007 90F7         LD        (Y), A
    145            I2Cx->FREQR = I2C_FREQR_RESET_VALUE;
   \   000009 9093         LDW       Y, X
   \   00000B 72A9 0002    ADDW      Y, #0x2
   \   00000F 4F           CLR       A
   \   000010 90F7         LD        (Y), A
    146            I2Cx->OARL = I2C_OARL_RESET_VALUE;
   \   000012 9093         LDW       Y, X
   \   000014 72A9 0003    ADDW      Y, #0x3
   \   000018 4F           CLR       A
   \   000019 90F7         LD        (Y), A
    147            I2Cx->OARH = I2C_OARH_RESET_VALUE;
   \   00001B 9093         LDW       Y, X
   \   00001D 72A9 0004    ADDW      Y, #0x4
   \   000021 4F           CLR       A
   \   000022 90F7         LD        (Y), A
    148            I2Cx->OAR2 = I2C_OAR2_RESET_VALUE;
   \   000024 9093         LDW       Y, X
   \   000026 72A9 0005    ADDW      Y, #0x5
   \   00002A 4F           CLR       A
   \   00002B 90F7         LD        (Y), A
    149            I2Cx->ITR = I2C_ITR_RESET_VALUE;
   \   00002D 9093         LDW       Y, X
   \   00002F 72A9 000A    ADDW      Y, #0xa
   \   000033 4F           CLR       A
   \   000034 90F7         LD        (Y), A
    150            I2Cx->CCRL = I2C_CCRL_RESET_VALUE;
   \   000036 9093         LDW       Y, X
   \   000038 72A9 000B    ADDW      Y, #0xb
   \   00003C 4F           CLR       A
   \   00003D 90F7         LD        (Y), A
    151            I2Cx->CCRH = I2C_CCRH_RESET_VALUE;
   \   00003F 9093         LDW       Y, X
   \   000041 72A9 000C    ADDW      Y, #0xc
   \   000045 4F           CLR       A
   \   000046 90F7         LD        (Y), A
    152            I2Cx->TRISER = I2C_TRISER_RESET_VALUE;
   \   000048 1C 000D      ADDW      X, #0xd
   \   00004B A6 02        LD        A, #0x2
   \   00004D F7           LD        (X), A
    153          }
   \   00004E 87           RETF
    154          
    155          /**
    156            * @brief  Initializes the I2C according to the specified parameters in standard
    157            *         or fast mode.
    158            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
    159            * @param  OutputClockFrequency: Specifies the output clock frequency in Hz.
    160            * @param  OwnAddress: Specifies the own address.
    161            * @param  I2C_Mode: Specifies the addressing mode to apply.
    162            *          This parameter can be one of the following values:
    163            *            @arg I2C_Mode_I2C: I2C mode
    164            *            @arg I2C_Mode_SMBusDevice: SMBus Device mode
    165            *            @arg I2C_Mode_SMBusHost: SMBus Host mode
    166            * @param  I2C_DutyCycle: Specifies the duty cycle to apply in fast mode.
    167            *          This parameter can be one of the following values:
    168            *            @arg I2C_DutyCycle_2: I2C fast mode Tlow/Thigh = 2
    169            *            @arg I2C_DutyCycle_16_9: I2C fast mode Tlow/Thigh = 16/9
    170            * @note   The I2C_DutyCycle parameter doesn't have impact when the OutputClockFrequency
    171            *         is lower than 100KHz.
    172            * @param  I2C_Ack: Specifies the acknowledge mode to apply.
    173            *          This parameter can be one of the following values:
    174            *            @arg I2C_Ack_Disable: No acknowledge
    175            *            @arg I2C_Ack_Enable: Acknowledge Enabled
    176            * @param  I2C_AcknowledgedAddress: Specifies the acknowledge address to apply.
    177            *          This parameter can be one of the following values:
    178            *            @arg I2C_AcknowledgedAddress_7bit: 7-bit slave address
    179            *            @arg I2C_AcknowledgedAddress_10bit: 10-bit slave address
    180            * @note   To use the I2C at 400 KHz (in fast mode), the PCLK frequency
    181            *         (I2C peripheral input clock) must be a multiple of 10 MHz.
    182            * @retval None
    183            */

   \                                 In section .far_func.text, align 1
    184          void I2C_Init(I2C_TypeDef* I2Cx, uint32_t OutputClockFrequency, uint16_t OwnAddress,
    185                        I2C_Mode_TypeDef I2C_Mode, I2C_DutyCycle_TypeDef I2C_DutyCycle,
    186                        I2C_Ack_TypeDef I2C_Ack, I2C_AcknowledgedAddress_TypeDef I2C_AcknowledgedAddress)
    187          {
   \                     I2C_Init:
   \   000000 8D ......    CALLF     L:?push_l2
   \   000004 8D ......    CALLF     L:?push_l3
   \   000008 89           PUSHW     X
   \   000009 9089         PUSHW     Y
   \   00000B 88           PUSH      A
   \   00000C 3B ....      PUSH      S:?b4
   \   00000F 3B ....      PUSH      S:?b5
   \   000012 3B ....      PUSH      S:?b6
   \   000015 52 04        SUB       SP, #0x4
   \   000017 8D ......    CALLF     L:?mov_l3_l0
    188            uint32_t result = 0x0004;
   \   00001B AE 0004      LDW       X, #0x4
   \   00001E BF ..        LDW       S:?w5, X
   \   000020 5F           CLRW      X
   \   000021 BF ..        LDW       S:?w4, X
    189            uint16_t tmpval = 0;
   \   000023 5F           CLRW      X
   \   000024 1F 03        LDW       (0x3,SP), X
    190            uint8_t tmpccrh = 0;
   \   000026 4F           CLR       A
   \   000027 6B 02        LD        (0x2,SP), A
    191            uint8_t input_clock = 0;
   \   000029 4F           CLR       A
   \   00002A 6B 01        LD        (0x1,SP), A
    192          
    193            /* Check the parameters */
    194            assert_param(IS_I2C_MODE(I2C_Mode));
    195            assert_param(IS_I2C_ACK_STATE(I2C_Ack));
    196            assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_AcknowledgedAddress));
    197            assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
    198            assert_param(IS_I2C_OWN_ADDRESS(OwnAddress));
    199            assert_param(IS_I2C_OUTPUT_CLOCK_FREQ(OutputClockFrequency));
    200          
    201          
    202            /* Get system clock frequency */
    203            input_clock = (uint8_t) (CLK_GetClockFreq() / 1000000);
   \   00002C 8D ......    CALLF     CLK_GetClockFreq
   \   000030 8D ......    CALLF     L:?udiv32_l0_l0_dl
   \   000034 000F4240     DC32      0xf4240
   \   000038 B6 ..        LD        A, S:?b3
   \   00003A 6B 01        LD        (0x1,SP), A
    204          
    205            /*------------------------- I2C FREQ Configuration ------------------------*/
    206            /* Clear frequency bits */
    207            I2Cx->FREQR &= (uint8_t)(~I2C_FREQR_FREQ);
   \   00003C 1E 0B        LDW       X, (0xb,SP)
   \   00003E 5C           INCW      X
   \   00003F 5C           INCW      X
   \   000040 F6           LD        A, (X)
   \   000041 A4 C0        AND       A, #0xc0
   \   000043 1E 0B        LDW       X, (0xb,SP)
   \   000045 5C           INCW      X
   \   000046 5C           INCW      X
   \   000047 F7           LD        (X), A
    208            /* Write new value */
    209            I2Cx->FREQR |= input_clock;
   \   000048 1E 0B        LDW       X, (0xb,SP)
   \   00004A 5C           INCW      X
   \   00004B 5C           INCW      X
   \   00004C 7B 01        LD        A, (0x1,SP)
   \   00004E FA           OR        A, (X)
   \   00004F 1E 0B        LDW       X, (0xb,SP)
   \   000051 5C           INCW      X
   \   000052 5C           INCW      X
   \   000053 F7           LD        (X), A
    210          
    211            /*--------------------------- I2C CCR Configuration ------------------------*/
    212            /* Disable I2C to configure TRISER */
    213            I2Cx->CR1 &= (uint8_t)(~I2C_CR1_PE);
   \   000054 1E 0B        LDW       X, (0xb,SP)
   \   000056 F6           LD        A, (X)
   \   000057 A4 FE        AND       A, #0xfe
   \   000059 1E 0B        LDW       X, (0xb,SP)
   \   00005B F7           LD        (X), A
    214          
    215            /* Clear CCRH & CCRL */
    216            I2Cx->CCRH &= (uint8_t)(~(I2C_CCRH_FS | I2C_CCRH_DUTY | I2C_CCRH_CCR));
   \   00005C 1E 0B        LDW       X, (0xb,SP)
   \   00005E 1C 000C      ADDW      X, #0xc
   \   000061 F6           LD        A, (X)
   \   000062 A4 30        AND       A, #0x30
   \   000064 1E 0B        LDW       X, (0xb,SP)
   \   000066 1C 000C      ADDW      X, #0xc
   \   000069 F7           LD        (X), A
    217            I2Cx->CCRL &= (uint8_t)(~I2C_CCRL_CCR);
   \   00006A 1E 0B        LDW       X, (0xb,SP)
   \   00006C 1C 000B      ADDW      X, #0xb
   \   00006F F6           LD        A, (X)
   \   000070 B7 ..        LD        S:?b0, A
   \   000072 1E 0B        LDW       X, (0xb,SP)
   \   000074 1C 000B      ADDW      X, #0xb
   \   000077 4F           CLR       A
   \   000078 F7           LD        (X), A
    218          
    219            /* Detect Fast or Standard mode depending on the Output clock frequency selected */
    220            if (OutputClockFrequency > I2C_MAX_STANDARD_FREQ) /* FAST MODE */
   \   000079 BE ..        LDW       X, S:?w6
   \   00007B A3 0001      CPW       X, #0x1
   \   00007E 26 05        JRNE      L:??I2C_Init_0
   \   000080 BE ..        LDW       X, S:?w7
   \   000082 A3 86A1      CPW       X, #0x86a1
   \                     ??I2C_Init_0:
   \   000085 24 03        JRNC      ??lb_0
   \   000087 CC ....      JP        L:??I2C_Init_1
    221            {
    222              /* Set F/S bit for fast mode */
    223              tmpccrh = I2C_CCRH_FS;
   \                     ??lb_0:
   \   00008A A6 80        LD        A, #0x80
   \   00008C 6B 02        LD        (0x2,SP), A
    224          
    225              if (I2C_DutyCycle == I2C_DutyCycle_2)
   \   00008E 0D 07        TNZ       (0x7,SP)
   \   000090 26 39        JRNE      L:??I2C_Init_2
    226              {
    227                /* Fast mode speed calculate: Tlow/Thigh = 2 */
    228                result = (uint32_t) ((input_clock * 1000000) / (OutputClockFrequency * 3));
   \   000092 AE 0003      LDW       X, #0x3
   \   000095 BF ..        LDW       S:?w3, X
   \   000097 5F           CLRW      X
   \   000098 BF ..        LDW       S:?w2, X
   \   00009A 8D ......    CALLF     L:?mov_l0_l3
   \   00009E 8D ......    CALLF     L:?mul32_l0_l0_l1
   \   0000A2 8D ......    CALLF     L:?mov_l2_l0
   \   0000A6 7B 01        LD        A, (0x1,SP)
   \   0000A8 5F           CLRW      X
   \   0000A9 97           LD        XL, A
   \   0000AA BF ..        LDW       S:?w1, X
   \   0000AC 5F           CLRW      X
   \   0000AD BF ..        LDW       S:?w0, X
   \   0000AF AE 4240      LDW       X, #0x4240
   \   0000B2 BF ..        LDW       S:?w3, X
   \   0000B4 AE 000F      LDW       X, #0xf
   \   0000B7 BF ..        LDW       S:?w2, X
   \   0000B9 8D ......    CALLF     L:?mul32_l0_l0_l1
   \   0000BD 8D ......    CALLF     L:?mov_l1_l2
   \   0000C1 8D ......    CALLF     L:?udiv32_l0_l0_l1
   \   0000C5 8D ......    CALLF     L:?mov_l2_l0
   \   0000C9 20 3D        JRA       L:??I2C_Init_3
    229              }
    230              else /* I2C_DUTYCYCLE_16_9 */
    231              {
    232                /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
    233                result = (uint32_t) ((input_clock * 1000000) / (OutputClockFrequency * 25));
   \                     ??I2C_Init_2:
   \   0000CB AE 0019      LDW       X, #0x19
   \   0000CE BF ..        LDW       S:?w3, X
   \   0000D0 5F           CLRW      X
   \   0000D1 BF ..        LDW       S:?w2, X
   \   0000D3 8D ......    CALLF     L:?mov_l0_l3
   \   0000D7 8D ......    CALLF     L:?mul32_l0_l0_l1
   \   0000DB 8D ......    CALLF     L:?mov_l2_l0
   \   0000DF 7B 01        LD        A, (0x1,SP)
   \   0000E1 5F           CLRW      X
   \   0000E2 97           LD        XL, A
   \   0000E3 BF ..        LDW       S:?w1, X
   \   0000E5 5F           CLRW      X
   \   0000E6 BF ..        LDW       S:?w0, X
   \   0000E8 AE 4240      LDW       X, #0x4240
   \   0000EB BF ..        LDW       S:?w3, X
   \   0000ED AE 000F      LDW       X, #0xf
   \   0000F0 BF ..        LDW       S:?w2, X
   \   0000F2 8D ......    CALLF     L:?mul32_l0_l0_l1
   \   0000F6 8D ......    CALLF     L:?mov_l1_l2
   \   0000FA 8D ......    CALLF     L:?udiv32_l0_l0_l1
   \   0000FE 8D ......    CALLF     L:?mov_l2_l0
    234                /* Set DUTY bit */
    235                tmpccrh |= I2C_CCRH_DUTY;
   \   000102 7B 02        LD        A, (0x2,SP)
   \   000104 AA 40        OR        A, #0x40
   \   000106 6B 02        LD        (0x2,SP), A
    236              }
    237          
    238              /* Verify and correct CCR value if below minimum value */
    239              if (result < (uint16_t)0x01)
   \                     ??I2C_Init_3:
   \   000108 BE ..        LDW       X, S:?w4
   \   00010A A3 0000      CPW       X, #0x0
   \   00010D 26 05        JRNE      L:??I2C_Init_4
   \   00010F BE ..        LDW       X, S:?w5
   \   000111 A3 0000      CPW       X, #0x0
   \                     ??I2C_Init_4:
   \   000114 26 06        JRNE      L:??I2C_Init_5
    240              {
    241                /* Set the minimum allowed value */
    242                result = (uint16_t)0x0001;
   \   000116 5F           CLRW      X
   \   000117 BF ..        LDW       S:?w4, X
   \   000119 5C           INCW      X
   \   00011A BF ..        LDW       S:?w5, X
    243              }
    244          
    245              /* Set Maximum Rise Time: 300ns max in Fast Mode
    246              = [300ns/(1/input_clock.10e6)]+1
    247              = [(input_clock * 3)/10]+1 */
    248              tmpval = ((input_clock * 3) / 10) + 1;
   \                     ??I2C_Init_5:
   \   00011C 7B 01        LD        A, (0x1,SP)
   \   00011E 905F         CLRW      Y
   \   000120 9097         LD        YL, A
   \   000122 AE 0003      LDW       X, #0x3
   \   000125 BF ..        LDW       S:?w0, X
   \   000127 93           LDW       X, Y
   \   000128 8D ......    CALLF     L:?mul16_x_x_w0
   \   00012C 90AE 000A    LDW       Y, #0xa
   \   000130 8D ......    CALLF     L:?sdiv16_x_x_y
   \   000134 5C           INCW      X
   \   000135 1F 03        LDW       (0x3,SP), X
    249              I2Cx->TRISER = (uint8_t)tmpval;
   \   000137 1E 0B        LDW       X, (0xb,SP)
   \   000139 1C 000D      ADDW      X, #0xd
   \   00013C 7B 04        LD        A, (0x4,SP)
   \   00013E F7           LD        (X), A
   \   00013F 20 54        JRA       L:??I2C_Init_6
    250          
    251            }
    252            else /* STANDARD MODE */
    253            {
    254          
    255              /* Calculate standard mode speed */
    256              result = (uint16_t)((input_clock * 1000000) / (OutputClockFrequency << (uint8_t)1));
   \                     ??I2C_Init_1:
   \   000141 8D ......    CALLF     L:?mov_l0_l3
   \   000145 A6 01        LD        A, #0x1
   \   000147 8D ......    CALLF     L:?sll32_l0_l0_a
   \   00014B 8D ......    CALLF     L:?mov_l2_l0
   \   00014F 7B 01        LD        A, (0x1,SP)
   \   000151 5F           CLRW      X
   \   000152 97           LD        XL, A
   \   000153 BF ..        LDW       S:?w1, X
   \   000155 5F           CLRW      X
   \   000156 BF ..        LDW       S:?w0, X
   \   000158 AE 4240      LDW       X, #0x4240
   \   00015B BF ..        LDW       S:?w3, X
   \   00015D AE 000F      LDW       X, #0xf
   \   000160 BF ..        LDW       S:?w2, X
   \   000162 8D ......    CALLF     L:?mul32_l0_l0_l1
   \   000166 8D ......    CALLF     L:?mov_l1_l2
   \   00016A 8D ......    CALLF     L:?udiv32_l0_l0_l1
   \   00016E BE ..        LDW       X, S:?w1
   \   000170 BF ..        LDW       S:?w5, X
   \   000172 5F           CLRW      X
   \   000173 BF ..        LDW       S:?w4, X
    257          
    258              /* Verify and correct CCR value if below minimum value */
    259              if (result < (uint16_t)0x0004)
   \   000175 BE ..        LDW       X, S:?w4
   \   000177 A3 0000      CPW       X, #0x0
   \   00017A 26 05        JRNE      L:??I2C_Init_7
   \   00017C BE ..        LDW       X, S:?w5
   \   00017E A3 0004      CPW       X, #0x4
   \                     ??I2C_Init_7:
   \   000181 24 08        JRNC      L:??I2C_Init_8
    260              {
    261                /* Set the minimum allowed value */
    262                result = (uint16_t)0x0004;
   \   000183 AE 0004      LDW       X, #0x4
   \   000186 BF ..        LDW       S:?w5, X
   \   000188 5F           CLRW      X
   \   000189 BF ..        LDW       S:?w4, X
    263              }
    264          
    265              /* Set Maximum Rise Time: 1000ns max in Standard Mode
    266              = [1000ns/(1/input_clock.10e6)]+1
    267              = input_clock+1 */
    268              I2Cx->TRISER = (uint8_t)((uint8_t)input_clock + (uint8_t)1);
   \                     ??I2C_Init_8:
   \   00018B 7B 01        LD        A, (0x1,SP)
   \   00018D AB 01        ADD       A, #0x1
   \   00018F 1E 0B        LDW       X, (0xb,SP)
   \   000191 1C 000D      ADDW      X, #0xd
   \   000194 F7           LD        (X), A
    269          
    270            }
    271          
    272            /* Write CCR with new calculated value */
    273            I2Cx->CCRL = (uint8_t)result;
   \                     ??I2C_Init_6:
   \   000195 B6 ..        LD        A, S:?b11
   \   000197 1E 0B        LDW       X, (0xb,SP)
   \   000199 1C 000B      ADDW      X, #0xb
   \   00019C F7           LD        (X), A
    274            I2Cx->CCRH = (uint8_t)((uint8_t)((uint8_t)((uint8_t)result >> 8) & I2C_CCRH_CCR) | tmpccrh);
   \   00019D 1E 0B        LDW       X, (0xb,SP)
   \   00019F 1C 000C      ADDW      X, #0xc
   \   0001A2 7B 02        LD        A, (0x2,SP)
   \   0001A4 F7           LD        (X), A
    275          
    276            /* Enable I2C and  Configure its mode*/
    277            I2Cx->CR1 |= (uint8_t)(I2C_CR1_PE | I2C_Mode);
   \   0001A5 7B 08        LD        A, (0x8,SP)
   \   0001A7 AA 01        OR        A, #0x1
   \   0001A9 1E 0B        LDW       X, (0xb,SP)
   \   0001AB FA           OR        A, (X)
   \   0001AC 1E 0B        LDW       X, (0xb,SP)
   \   0001AE F7           LD        (X), A
    278          
    279            /* Configure I2C acknowledgement */
    280            I2Cx->CR2 |= (uint8_t)I2C_Ack;
   \   0001AF 1E 0B        LDW       X, (0xb,SP)
   \   0001B1 5C           INCW      X
   \   0001B2 7B 06        LD        A, (0x6,SP)
   \   0001B4 FA           OR        A, (X)
   \   0001B5 1E 0B        LDW       X, (0xb,SP)
   \   0001B7 5C           INCW      X
   \   0001B8 F7           LD        (X), A
    281          
    282            /*--------------------------- I2C OAR Configuration ------------------------*/
    283            I2Cx->OARL = (uint8_t)(OwnAddress);
   \   0001B9 1E 0B        LDW       X, (0xb,SP)
   \   0001BB 1C 0003      ADDW      X, #0x3
   \   0001BE 7B 0A        LD        A, (0xa,SP)
   \   0001C0 F7           LD        (X), A
    284            I2Cx->OARH = (uint8_t)((uint8_t)(I2C_AcknowledgedAddress | I2C_OARH_ADDCONF ) | \
    285                                   (uint8_t)((uint16_t)( (uint16_t)OwnAddress &  (uint16_t)0x0300) >> 7));
   \   0001C1 1E 09        LDW       X, (0x9,SP)
   \   0001C3 58           SLLW      X
   \   0001C4 4F           CLR       A
   \   0001C5 49           RLC       A
   \   0001C6 01           RRWA      X, A
   \   0001C7 9F           LD        A, XL
   \   0001C8 A4 06        AND       A, #0x6
   \   0001CA 88           PUSH      A
   \   0001CB 7B 06        LD        A, (0x6,SP)
   \   0001CD AA 40        OR        A, #0x40
   \   0001CF B7 ..        LD        S:?b1, A
   \   0001D1 84           POP       A
   \   0001D2 BA ..        OR        A, S:?b1
   \   0001D4 1E 0B        LDW       X, (0xb,SP)
   \   0001D6 1C 0004      ADDW      X, #0x4
   \   0001D9 F7           LD        (X), A
    286          }
   \   0001DA 5B 0C        ADD       SP, #0xc
   \   0001DC AC ......    JPF       L:?epilogue_l2_l3
    287          
    288          /**
    289            * @brief  Enables or disables the I2C peripheral.
    290            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
    291            * @param  NewState: Indicate the new I2C peripheral state.
    292            *         This parameter can be: ENABLE or DISABLE.
    293            * @retval None
    294            */

   \                                 In section .far_func.text, align 1
    295          void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    296          {
    297          
    298            /* Check function parameters */
    299            assert_param(IS_FUNCTIONAL_STATE(NewState));
    300          
    301            if (NewState != DISABLE)
   \                     I2C_Cmd:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??I2C_Cmd_0
    302            {
    303              /* Enable I2C peripheral */
    304              I2Cx->CR1 |= I2C_CR1_PE;
   \   000003 F6           LD        A, (X)
   \   000004 AA 01        OR        A, #0x1
   \   000006 F7           LD        (X), A
   \   000007 87           RETF
    305            }
    306            else /* NewState == DISABLE */
    307            {
    308              /* Disable I2C peripheral */
    309              I2Cx->CR1 &= (uint8_t)(~I2C_CR1_PE);
   \                     ??I2C_Cmd_0:
   \   000008 F6           LD        A, (X)
   \   000009 A4 FE        AND       A, #0xfe
   \   00000B F7           LD        (X), A
    310            }
    311          }
   \   00000C 87           RETF
    312          
    313          /**
    314            * @brief  Enables or disables the I2C General Call feature.
    315            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
    316            * @param  NewState: State of the General Call feature.
    317            *         This parameter can be: ENABLE or DISABLE.
    318            * @retval None
    319            */

   \                                 In section .far_func.text, align 1
    320          void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    321          {
    322          
    323            /* Check function parameters */
    324            assert_param(IS_FUNCTIONAL_STATE(NewState));
    325          
    326            if (NewState != DISABLE)
   \                     I2C_GeneralCallCmd:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??I2C_GeneralCallCmd_0
    327            {
    328              /* Enable General Call */
    329              I2Cx->CR1 |= I2C_CR1_ENGC;
   \   000003 F6           LD        A, (X)
   \   000004 AA 40        OR        A, #0x40
   \   000006 F7           LD        (X), A
   \   000007 87           RETF
    330            }
    331            else /* NewState == DISABLE */
    332            {
    333              /* Disable General Call */
    334              I2Cx->CR1 &= (uint8_t)(~I2C_CR1_ENGC);
   \                     ??I2C_GeneralCallCmd_0:
   \   000008 F6           LD        A, (X)
   \   000009 A4 BF        AND       A, #0xbf
   \   00000B F7           LD        (X), A
    335            }
    336          }
   \   00000C 87           RETF
    337          
    338          /**
    339            * @brief  Generates I2C communication START condition.
    340            * @note   CCR must be programmed, i.e. I2C_Init function must have been called
    341            *         with a valid I2C_ClockSpeed
    342            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
    343            * @param  NewState: Enable or disable the start condition.
    344            *         This parameter can be: ENABLE or DISABLE.
    345            * @retval None
    346            */

   \                                 In section .far_func.text, align 1
    347          void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
    348          {
    349          
    350            /* Check function parameters */
    351            assert_param(IS_FUNCTIONAL_STATE(NewState));
    352          
    353            if (NewState != DISABLE)
   \                     I2C_GenerateSTART:
   \   000000 4D           TNZ       A
   \   000001 27 0B        JREQ      L:??I2C_GenerateSTART_0
    354            {
    355              /* Generate a START condition */
    356              I2Cx->CR2 |= I2C_CR2_START;
   \   000003 9093         LDW       Y, X
   \   000005 905C         INCW      Y
   \   000007 90F6         LD        A, (Y)
   \   000009 AA 01        OR        A, #0x1
   \   00000B 5C           INCW      X
   \   00000C F7           LD        (X), A
   \   00000D 87           RETF
    357            }
    358            else /* NewState == DISABLE */
    359            {
    360              /* Disable the START condition generation */
    361              I2Cx->CR2 &= (uint8_t)(~I2C_CR2_START);
   \                     ??I2C_GenerateSTART_0:
   \   00000E 9093         LDW       Y, X
   \   000010 905C         INCW      Y
   \   000012 90F6         LD        A, (Y)
   \   000014 A4 FE        AND       A, #0xfe
   \   000016 5C           INCW      X
   \   000017 F7           LD        (X), A
    362            }
    363          }
   \   000018 87           RETF
    364          
    365          /**
    366            * @brief  Generates I2C communication STOP condition.
    367            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
    368            * @param  NewState: Enable or disable the stop condition.
    369            *         This parameter can be: ENABLE or DISABLE.
    370            * @retval None
    371            */

   \                                 In section .far_func.text, align 1
    372          void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
    373          {
    374          
    375            /* Check function parameters */
    376            assert_param(IS_FUNCTIONAL_STATE(NewState));
    377          
    378            if (NewState != DISABLE)
   \                     I2C_GenerateSTOP:
   \   000000 4D           TNZ       A
   \   000001 27 0B        JREQ      L:??I2C_GenerateSTOP_0
    379            {
    380              /* Generate a STOP condition */
    381              I2Cx->CR2 |= I2C_CR2_STOP;
   \   000003 9093         LDW       Y, X
   \   000005 905C         INCW      Y
   \   000007 90F6         LD        A, (Y)
   \   000009 AA 02        OR        A, #0x2
   \   00000B 5C           INCW      X
   \   00000C F7           LD        (X), A
   \   00000D 87           RETF
    382            }
    383            else /* NewState == DISABLE */
    384            {
    385              /* Disable the STOP condition generation */
    386              I2Cx->CR2 &= (uint8_t)(~I2C_CR2_STOP);
   \                     ??I2C_GenerateSTOP_0:
   \   00000E 9093         LDW       Y, X
   \   000010 905C         INCW      Y
   \   000012 90F6         LD        A, (Y)
   \   000014 A4 FD        AND       A, #0xfd
   \   000016 5C           INCW      X
   \   000017 F7           LD        (X), A
    387            }
    388          }
   \   000018 87           RETF
    389          
    390          /**
    391            * @brief  Enables or disables I2C software reset.
    392            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
    393            * @param  NewState: Specifies the new state of the I2C software reset.
    394            *         This parameter can be: ENABLE or DISABLE.
    395            * @retval None
    396            */

   \                                 In section .far_func.text, align 1
    397          void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    398          {
    399            /* Check function parameters */
    400            assert_param(IS_FUNCTIONAL_STATE(NewState));
    401          
    402            if (NewState != DISABLE)
   \                     I2C_SoftwareResetCmd:
   \   000000 4D           TNZ       A
   \   000001 27 0B        JREQ      L:??I2C_SoftwareResetCmd_0
    403            {
    404              /* Peripheral under reset */
    405              I2Cx->CR2 |= I2C_CR2_SWRST;
   \   000003 9093         LDW       Y, X
   \   000005 905C         INCW      Y
   \   000007 90F6         LD        A, (Y)
   \   000009 AA 80        OR        A, #0x80
   \   00000B 5C           INCW      X
   \   00000C F7           LD        (X), A
   \   00000D 87           RETF
    406            }
    407            else /* NewState == DISABLE */
    408            {
    409              /* Peripheral not under reset */
    410              I2Cx->CR2 &= (uint8_t)(~I2C_CR2_SWRST);
   \                     ??I2C_SoftwareResetCmd_0:
   \   00000E 9093         LDW       Y, X
   \   000010 905C         INCW      Y
   \   000012 90F6         LD        A, (Y)
   \   000014 A4 7F        AND       A, #0x7f
   \   000016 5C           INCW      X
   \   000017 F7           LD        (X), A
    411            }
    412          }
   \   000018 87           RETF
    413          
    414          /**
    415            * @brief  Enables or disables the I2C clock stretching.
    416            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
    417            * @param  NewState: Specifies the new state of the I2C Clock stretching.
    418            *         This parameter can be: ENABLE or DISABLE.
    419            * @retval None
    420            */

   \                                 In section .far_func.text, align 1
    421          void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    422          {
    423            /* Check function parameters */
    424            assert_param(IS_FUNCTIONAL_STATE(NewState));
    425          
    426            if (NewState != DISABLE)
   \                     I2C_StretchClockCmd:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??I2C_StretchClockCmd_0
    427            {
    428              /* Clock Stretching Enable */
    429              I2Cx->CR1 &= (uint8_t)(~I2C_CR1_NOSTRETCH);
   \   000003 F6           LD        A, (X)
   \   000004 A4 7F        AND       A, #0x7f
   \   000006 F7           LD        (X), A
   \   000007 87           RETF
    430          
    431            }
    432            else /* NewState == DISABLE */
    433            {
    434              /* Clock Stretching Disable (Slave mode) */
    435              I2Cx->CR1 |= I2C_CR1_NOSTRETCH;
   \                     ??I2C_StretchClockCmd_0:
   \   000008 F6           LD        A, (X)
   \   000009 AA 80        OR        A, #0x80
   \   00000B F7           LD        (X), A
    436            }
    437          }
   \   00000C 87           RETF
    438          
    439          /**
    440            * @brief  Enables or disables the I2C ARP.
    441            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
    442            * @param  NewState: Specifies the new state of the I2C ARP
    443            *         This parameter can be: ENABLE or DISABLE.
    444            * @retval None
    445            */

   \                                 In section .far_func.text, align 1
    446          void I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    447          {
    448            /* Check function parameters */
    449            assert_param(IS_FUNCTIONAL_STATE(NewState));
    450          
    451            if (NewState != DISABLE)
   \                     I2C_ARPCmd:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??I2C_ARPCmd_0
    452            {
    453              /* ARP Enable */
    454              I2Cx->CR1 |= I2C_CR1_ARP;
   \   000003 F6           LD        A, (X)
   \   000004 AA 10        OR        A, #0x10
   \   000006 F7           LD        (X), A
   \   000007 87           RETF
    455          
    456            }
    457            else /* NewState == DISABLE */
    458            {
    459              /* ARP Disable  */
    460              I2Cx->CR1 &= (uint8_t)(~I2C_CR1_ARP);
   \                     ??I2C_ARPCmd_0:
   \   000008 F6           LD        A, (X)
   \   000009 A4 EF        AND       A, #0xef
   \   00000B F7           LD        (X), A
    461            }
    462          }
   \   00000C 87           RETF
    463          
    464          /**
    465            * @brief  Enable or Disable the I2C acknowledge feature.
    466            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
    467            * @param  NewState: Specifies the new state of the I2C acknowledge.
    468            *         This parameter can be: ENABLE or DISABLE.
    469            * @retval None
    470            */

   \                                 In section .far_func.text, align 1
    471          void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
    472          {
    473            /* Check function parameters */
    474            assert_param(IS_FUNCTIONAL_STATE(NewState));
    475          
    476            if (NewState != DISABLE)
   \                     I2C_AcknowledgeConfig:
   \   000000 4D           TNZ       A
   \   000001 27 0B        JREQ      L:??I2C_AcknowledgeConfig_0
    477            {
    478              /* Enable the acknowledgement */
    479              I2Cx->CR2 |= I2C_CR2_ACK;
   \   000003 9093         LDW       Y, X
   \   000005 905C         INCW      Y
   \   000007 90F6         LD        A, (Y)
   \   000009 AA 04        OR        A, #0x4
   \   00000B 5C           INCW      X
   \   00000C F7           LD        (X), A
   \   00000D 87           RETF
    480            }
    481            else
    482            {
    483              /* Disable the acknowledgement */
    484              I2Cx->CR2 &= (uint8_t)(~I2C_CR2_ACK);
   \                     ??I2C_AcknowledgeConfig_0:
   \   00000E 9093         LDW       Y, X
   \   000010 905C         INCW      Y
   \   000012 90F6         LD        A, (Y)
   \   000014 A4 FB        AND       A, #0xfb
   \   000016 5C           INCW      X
   \   000017 F7           LD        (X), A
    485            }
    486          }
   \   000018 87           RETF
    487          
    488          /**
    489            * @brief  Configures the specified I2C own address2.
    490            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
    491            * @param  Address: specifies the 7bit I2C own address2.
    492            * @retval None.
    493            */

   \                                 In section .far_func.text, align 1
    494          void I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, uint8_t Address)
    495          {
   \                     I2C_OwnAddress2Config:
   \   000000 B7 ..        LD        S:?b0, A
    496            uint8_t tmpreg = 0;
   \   000002 3F ..        CLR       S:?b1
    497          
    498            /* Get the old register value */
    499            tmpreg = I2Cx->OAR2;
   \   000004 9093         LDW       Y, X
   \   000006 72A9 0005    ADDW      Y, #0x5
   \   00000A 90F6         LD        A, (Y)
   \   00000C B7 ..        LD        S:?b1, A
    500          
    501            /* Reset I2Cx Own address2 bit [7:1] */
    502            tmpreg &= (uint8_t)(~I2C_OAR2_ADD2);
   \   00000E B6 ..        LD        A, S:?b1
   \   000010 A4 01        AND       A, #0x1
   \   000012 B7 ..        LD        S:?b1, A
    503          
    504            /* Set I2Cx Own address2 */
    505            tmpreg |= (uint8_t) ((uint8_t)Address & (uint8_t)0xFE);
   \   000014 B6 ..        LD        A, S:?b0
   \   000016 A4 FE        AND       A, #0xfe
   \   000018 BA ..        OR        A, S:?b1
   \   00001A B7 ..        LD        S:?b1, A
    506          
    507            /* Store the new register value */
    508            I2Cx->OAR2 = tmpreg;
   \   00001C 1C 0005      ADDW      X, #0x5
   \   00001F B6 ..        LD        A, S:?b1
   \   000021 F7           LD        (X), A
    509          }
   \   000022 87           RETF
    510          
    511          /**
    512            * @brief  Enables or disables the specified I2C dual addressing mode.
    513            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    514            * @param  NewState: new state of the I2C dual addressing mode.
    515              *         This parameter can be: ENABLE or DISABLE.
    516            * @retval None
    517            */

   \                                 In section .far_func.text, align 1
    518          void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    519          {
    520            /* Check the parameters */
    521            assert_param(IS_FUNCTIONAL_STATE(NewState));
    522          
    523            if (NewState != DISABLE)
   \                     I2C_DualAddressCmd:
   \   000000 4D           TNZ       A
   \   000001 27 0F        JREQ      L:??I2C_DualAddressCmd_0
    524            {
    525              /* Enable dual addressing mode */
    526              I2Cx->OAR2 |= I2C_OAR2_ENDUAL;
   \   000003 9093         LDW       Y, X
   \   000005 72A9 0005    ADDW      Y, #0x5
   \   000009 90F6         LD        A, (Y)
   \   00000B AA 01        OR        A, #0x1
   \   00000D 1C 0005      ADDW      X, #0x5
   \   000010 F7           LD        (X), A
   \   000011 87           RETF
    527            }
    528            else
    529            {
    530              /* Disable dual addressing mode */
    531              I2Cx->OAR2 &= (uint8_t)(~I2C_OAR2_ENDUAL);
   \                     ??I2C_DualAddressCmd_0:
   \   000012 9093         LDW       Y, X
   \   000014 72A9 0005    ADDW      Y, #0x5
   \   000018 90F6         LD        A, (Y)
   \   00001A A4 FE        AND       A, #0xfe
   \   00001C 1C 0005      ADDW      X, #0x5
   \   00001F F7           LD        (X), A
    532            }
    533          }
   \   000020 87           RETF
    534          
    535          /**
    536            * @brief  Selects the specified I2C Ack position.
    537            * @note   This function must be called before data reception starts.
    538            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
    539            * @param  I2C_AckPosition: specifies the Ack position.
    540            *          This parameter can be one of the following values:
    541            *            @arg I2C_AckPosition_Current: Acknowledge on the current byte
    542            *            @arg I2C_AckPosition_Next: Acknowledge on the next byte
    543            * @retval None
    544            */

   \                                 In section .far_func.text, align 1
    545          void I2C_AckPositionConfig(I2C_TypeDef* I2Cx, I2C_AckPosition_TypeDef I2C_AckPosition)
    546          {
   \                     I2C_AckPositionConfig:
   \   000000 B7 ..        LD        S:?b0, A
    547            /* Check function parameters */
    548            assert_param(IS_I2C_ACK_POSITION(I2C_AckPosition));
    549          
    550            /* Clear the I2C Ack position */
    551            I2Cx->CR2 &= (uint8_t)(~I2C_CR2_POS);
   \   000002 9093         LDW       Y, X
   \   000004 905C         INCW      Y
   \   000006 90F6         LD        A, (Y)
   \   000008 A4 F7        AND       A, #0xf7
   \   00000A 9093         LDW       Y, X
   \   00000C 905C         INCW      Y
   \   00000E 90F7         LD        (Y), A
    552            /* Configure the specified I2C Ack position*/
    553            I2Cx->CR2 |= (uint8_t)I2C_AckPosition;
   \   000010 9093         LDW       Y, X
   \   000012 905C         INCW      Y
   \   000014 B6 ..        LD        A, S:?b0
   \   000016 90FA         OR        A, (Y)
   \   000018 5C           INCW      X
   \   000019 F7           LD        (X), A
    554          }
   \   00001A 87           RETF
    555          
    556          /**
    557            * @brief  Drives the SMBusAlert pin high or low.
    558            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
    559            * @param  I2C_SMBusAlert: SMBusAlert pin state.
    560            *          This parameter can be one of the following values:
    561            *            @arg I2C_SMBusAlert_High: SMBAlert pin high
    562            *            @arg I2C_SMBusAlert_Low: SMBAlert pin Low
    563            * @retval None
    564            */

   \                                 In section .far_func.text, align 1
    565          void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, I2C_SMBusAlert_TypeDef I2C_SMBusAlert)
    566          {
    567          
    568            /* Check functions parameters */
    569            assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));
    570          
    571            if (I2C_SMBusAlert != I2C_SMBusAlert_High)
   \                     I2C_SMBusAlertConfig:
   \   000000 4D           TNZ       A
   \   000001 27 0B        JREQ      L:??I2C_SMBusAlertConfig_0
    572            {
    573              /* SMBus Alert pin low */
    574              I2Cx->CR2 |= (uint8_t)I2C_CR2_ALERT;
   \   000003 9093         LDW       Y, X
   \   000005 905C         INCW      Y
   \   000007 90F6         LD        A, (Y)
   \   000009 AA 20        OR        A, #0x20
   \   00000B 5C           INCW      X
   \   00000C F7           LD        (X), A
   \   00000D 87           RETF
    575            }
    576            else /*I2C_SMBusAlert = I2C_SMBusAlert_High */
    577            {
    578              /* SMBus Alert pin high */
    579              I2Cx->CR2 &= (uint8_t)(~I2C_CR2_ALERT);
   \                     ??I2C_SMBusAlertConfig_0:
   \   00000E 9093         LDW       Y, X
   \   000010 905C         INCW      Y
   \   000012 90F6         LD        A, (Y)
   \   000014 A4 DF        AND       A, #0xdf
   \   000016 5C           INCW      X
   \   000017 F7           LD        (X), A
    580            }
    581          }
   \   000018 87           RETF
    582          
    583          /**
    584            * @brief  Selects I2C fast mode duty cycle.
    585            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
    586            * @param  I2C_DutyCycle: specifies the fast mode duty cycle.
    587            *          This parameter can be one of the following values:
    588            *            @arg I2C_DutyCycle_2: I2C fast mode Tlow/Thigh = 2
    589            *            @arg I2C_DutyCycle_16_9: I2C fast mode Tlow/Thigh = 16/9
    590            * @retval None
    591            */

   \                                 In section .far_func.text, align 1
    592          void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, I2C_DutyCycle_TypeDef I2C_DutyCycle)
    593          {
    594          
    595            /* Check function parameters */
    596            assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
    597          
    598            if (I2C_DutyCycle == I2C_DutyCycle_16_9)
   \                     I2C_FastModeDutyCycleConfig:
   \   000000 A1 40        CP        A, #0x40
   \   000002 26 0F        JRNE      L:??I2C_FastModeDutyCycleConfig_0
    599            {
    600              /* I2C fast mode Tlow/Thigh = 16/9 */
    601              I2Cx->CCRH |= I2C_CCRH_DUTY;
   \   000004 9093         LDW       Y, X
   \   000006 72A9 000C    ADDW      Y, #0xc
   \   00000A 90F6         LD        A, (Y)
   \   00000C AA 40        OR        A, #0x40
   \   00000E 1C 000C      ADDW      X, #0xc
   \   000011 F7           LD        (X), A
   \   000012 87           RETF
    602            }
    603            else /* I2C_DUTYCYCLE_2 */
    604            {
    605              /* I2C fast mode Tlow/Thigh = 2 */
    606              I2Cx->CCRH &= (uint8_t)(~I2C_CCRH_DUTY);
   \                     ??I2C_FastModeDutyCycleConfig_0:
   \   000013 9093         LDW       Y, X
   \   000015 72A9 000C    ADDW      Y, #0xc
   \   000019 90F6         LD        A, (Y)
   \   00001B A4 BF        AND       A, #0xbf
   \   00001D 1C 000C      ADDW      X, #0xc
   \   000020 F7           LD        (X), A
    607            }
    608          }
   \   000021 87           RETF
    609          
    610          /**
    611            * @brief  Transmits the 7-bit address (to select the) slave device.
    612            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
    613            * @param  Address: Specifies the slave address which will be transmitted.
    614            * @param  I2C_Direction: specifies whether the I2C device will be a Transmitter
    615            *         or a Receiver.
    616            *          This parameter can be one of the following values
    617            *            @arg I2C_Direction_Transmitter: Transmitter mode
    618            *            @arg I2C_Direction_Receiver: Receiver mode
    619            * @retval None
    620            */

   \                                 In section .far_func.text, align 1
    621          void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, I2C_Direction_TypeDef I2C_Direction)
    622          {
    623            /* Check function parameters */
    624            assert_param(IS_I2C_ADDRESS(Address));
    625            assert_param(IS_I2C_DIRECTION(I2C_Direction));
    626          
    627            /* Test on the direction to set/reset the read/write bit */
    628            if (I2C_Direction != I2C_Direction_Transmitter)
   \                     I2C_Send7bitAddress:
   \   000000 3D ..        TNZ       S:?b0
   \   000002 27 04        JREQ      L:??I2C_Send7bitAddress_0
    629            {
    630              /* Set the address bit0 for read */
    631              Address |= OAR1_ADD0_Set;
   \   000004 AA 01        OR        A, #0x1
   \   000006 20 02        JRA       L:??I2C_Send7bitAddress_1
    632            }
    633            else
    634            {
    635              /* Reset the address bit0 for write */
    636              Address &= OAR1_ADD0_Reset;
   \                     ??I2C_Send7bitAddress_0:
   \   000008 A4 FE        AND       A, #0xfe
    637            }
    638            /* Send the address */
    639            I2Cx->DR = Address;
   \                     ??I2C_Send7bitAddress_1:
   \   00000A 1C 0006      ADDW      X, #0x6
   \   00000D F7           LD        (X), A
    640          }
   \   00000E 87           RETF
    641          
    642          /**
    643            * @}
    644            */
    645          
    646          /** @defgroup I2C_Group2 Data transfers functions
    647           *  @brief   Data transfers functions
    648           *
    649          @verbatim
    650           ===============================================================================
    651                                  Data transfers functions
    652           ===============================================================================
    653          
    654          @endverbatim
    655            * @{
    656            */
    657          
    658          /**
    659            * @brief  Send a byte by writing in the DR register.
    660            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
    661            * @param  Data: Byte to be sent.
    662            * @retval None
    663            */

   \                                 In section .far_func.text, align 1
    664          void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)
    665          {
    666            /* Write in the DR register the data to be sent */
    667            I2Cx->DR = Data;
   \                     I2C_SendData:
   \   000000 1C 0006      ADDW      X, #0x6
   \   000003 F7           LD        (X), A
    668          }
   \   000004 87           RETF
    669          
    670          /**
    671            * @brief  Returns the most recent received data.
    672            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
    673            * @param  None
    674            * @retval The value of the received byte data.
    675            */

   \                                 In section .far_func.text, align 1
    676          uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)
    677          {
    678            /* Return the data present in the DR register */
    679            return ((uint8_t)I2Cx->DR);
   \                     I2C_ReceiveData:
   \   000000 1C 0006      ADDW      X, #0x6
   \   000003 F6           LD        A, (X)
   \   000004 87           RETF
    680          }
    681          
    682          /**
    683            * @}
    684            */
    685          
    686          /** @defgroup I2C_Group3 PEC management functions
    687           *  @brief   PEC management functions
    688           *
    689          @verbatim
    690           ===============================================================================
    691                                   PEC management functions
    692           ===============================================================================
    693          
    694          @endverbatim
    695            * @{
    696            */
    697          
    698          /**
    699            * @brief  Enables or disables PEC transfer.
    700            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
    701            * @param  NewState: indicates the PEC  transfer state.
    702            *         This parameter can be: ENABLE or DISABLE.
    703            * @retval None
    704            */

   \                                 In section .far_func.text, align 1
    705          void I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
    706          {
    707            /* Check the parameters */
    708            assert_param(IS_FUNCTIONAL_STATE(NewState));
    709          
    710            if (NewState != DISABLE)
   \                     I2C_TransmitPEC:
   \   000000 4D           TNZ       A
   \   000001 27 0B        JREQ      L:??I2C_TransmitPEC_0
    711            {
    712              /* Enable the PEC transmission */
    713              I2Cx->CR2 |= I2C_CR2_PEC;
   \   000003 9093         LDW       Y, X
   \   000005 905C         INCW      Y
   \   000007 90F6         LD        A, (Y)
   \   000009 AA 10        OR        A, #0x10
   \   00000B 5C           INCW      X
   \   00000C F7           LD        (X), A
   \   00000D 87           RETF
    714            }
    715            else
    716            {
    717              /* Disable the PEC transmission */
    718              I2Cx->CR2 &= (uint8_t)(~I2C_CR2_PEC);
   \                     ??I2C_TransmitPEC_0:
   \   00000E 9093         LDW       Y, X
   \   000010 905C         INCW      Y
   \   000012 90F6         LD        A, (Y)
   \   000014 A4 EF        AND       A, #0xef
   \   000016 5C           INCW      X
   \   000017 F7           LD        (X), A
    719            }
    720          }
   \   000018 87           RETF
    721          
    722          /**
    723            * @brief  Enables or disables PEC calculation.
    724            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
    725            * @param  NewState: indicates the PEC  calculation state.
    726            *         This parameter can be: ENABLE or DISABLE.
    727            * @retval None
    728            */

   \                                 In section .far_func.text, align 1
    729          void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
    730          {
    731            /* Check the parameters */
    732            assert_param(IS_FUNCTIONAL_STATE(NewState));
    733          
    734            if (NewState != DISABLE)
   \                     I2C_CalculatePEC:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??I2C_CalculatePEC_0
    735            {
    736              /* Enable PEC calculation */
    737              I2Cx->CR1 |= I2C_CR1_ENPEC;
   \   000003 F6           LD        A, (X)
   \   000004 AA 20        OR        A, #0x20
   \   000006 F7           LD        (X), A
   \   000007 87           RETF
    738            }
    739            else
    740            {
    741              /* Disable PEC calculation */
    742              I2Cx->CR1 &= (uint8_t)(~I2C_CR1_ENPEC);
   \                     ??I2C_CalculatePEC_0:
   \   000008 F6           LD        A, (X)
   \   000009 A4 DF        AND       A, #0xdf
   \   00000B F7           LD        (X), A
    743            }
    744          }
   \   00000C 87           RETF
    745          
    746          /**
    747            * @brief  Selects I2C PEC position..
    748            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
    749            * @param  I2C_PECPosition:PEC position.
    750            *          This parameter can be one of the following values:
    751            *            @arg I2C_PECPosition_Current: Current byte in shift register is PEC
    752            *            @arg I2C_PECPosition_Next: Next  byte in shift register is PEC
    753            * @retval None
    754            */

   \                                 In section .far_func.text, align 1
    755          void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, I2C_PECPosition_TypeDef I2C_PECPosition)
    756          {
   \                     I2C_PECPositionConfig:
   \   000000 B7 ..        LD        S:?b0, A
    757            /* Check the parameters */
    758            assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));
    759          
    760            /* Clear the I2C PEC position */
    761            I2Cx->CR2 &= (uint8_t)(~I2C_CR2_POS);
   \   000002 9093         LDW       Y, X
   \   000004 905C         INCW      Y
   \   000006 90F6         LD        A, (Y)
   \   000008 A4 F7        AND       A, #0xf7
   \   00000A 9093         LDW       Y, X
   \   00000C 905C         INCW      Y
   \   00000E 90F7         LD        (Y), A
    762            /* Configure the specified I2C PEC position*/
    763            I2Cx->CR2 |= (uint8_t)I2C_PECPosition;
   \   000010 9093         LDW       Y, X
   \   000012 905C         INCW      Y
   \   000014 B6 ..        LD        A, S:?b0
   \   000016 90FA         OR        A, (Y)
   \   000018 5C           INCW      X
   \   000019 F7           LD        (X), A
    764          }
   \   00001A 87           RETF
    765          
    766          /**
    767            * @brief  Returns PEC value.
    768            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
    769            * @param  None
    770            * @retval The value of the PEC.
    771            */

   \                                 In section .far_func.text, align 1
    772          uint8_t I2C_GetPEC(I2C_TypeDef* I2Cx)
    773          {
    774            /* Return the PEC value */
    775            return (I2Cx->PECR);
   \                     I2C_GetPEC:
   \   000000 1C 000E      ADDW      X, #0xe
   \   000003 F6           LD        A, (X)
   \   000004 87           RETF
    776          }
    777          
    778          /**
    779            * @}
    780            */
    781          
    782          /** @defgroup I2C_Group4 DMA transfers management functions
    783           *  @brief   DMA transfers management functions
    784           *
    785          @verbatim
    786           ===============================================================================
    787                                   DMA transfers management functions
    788           ===============================================================================
    789            This section provides functions allowing to configure the I2C DMA channels
    790            requests.
    791          
    792          @endverbatim
    793            * @{
    794            */
    795          
    796          /**
    797            * @brief  Enables or disables the I2C DMA requests .
    798            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
    799            * @param  NewState: Indicate the new I2C DMA state.
    800            *         This parameter can be: ENABLE or DISABLE.
    801            * @retval None
    802            */

   \                                 In section .far_func.text, align 1
    803          void I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    804          {
    805            /* Check the parameters */
    806            assert_param(IS_FUNCTIONAL_STATE(NewState));
    807          
    808            if (NewState != DISABLE)
   \                     I2C_DMACmd:
   \   000000 4D           TNZ       A
   \   000001 27 0F        JREQ      L:??I2C_DMACmd_0
    809            {
    810              /* Enable I2C DMA requests */
    811              I2Cx->ITR |= I2C_ITR_DMAEN;
   \   000003 9093         LDW       Y, X
   \   000005 72A9 000A    ADDW      Y, #0xa
   \   000009 90F6         LD        A, (Y)
   \   00000B AA 08        OR        A, #0x8
   \   00000D 1C 000A      ADDW      X, #0xa
   \   000010 F7           LD        (X), A
   \   000011 87           RETF
    812            }
    813            else
    814            {
    815              /* Disable I2C DMA requests */
    816              I2Cx->ITR &= (uint8_t)(~I2C_ITR_DMAEN);
   \                     ??I2C_DMACmd_0:
   \   000012 9093         LDW       Y, X
   \   000014 72A9 000A    ADDW      Y, #0xa
   \   000018 90F6         LD        A, (Y)
   \   00001A A4 F7        AND       A, #0xf7
   \   00001C 1C 000A      ADDW      X, #0xa
   \   00001F F7           LD        (X), A
    817            }
    818          }
   \   000020 87           RETF
    819          
    820          /**
    821            * @brief  Specifies that the next DMA transfer is the last one .
    822            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
    823            * @param  NewState: Indicate the new I2C DMA state.
    824            *         This parameter can be: ENABLE or DISABLE.
    825            * @retval None
    826            */

   \                                 In section .far_func.text, align 1
    827          void I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    828          {
    829            /* Check the parameters */
    830            assert_param(IS_FUNCTIONAL_STATE(NewState));
    831          
    832            if (NewState != DISABLE)
   \                     I2C_DMALastTransferCmd:
   \   000000 4D           TNZ       A
   \   000001 27 0F        JREQ      L:??I2C_DMALastTransferCmd_0
    833            {
    834              /* Enable I2C DMA requests */
    835              I2Cx->ITR |= I2C_ITR_LAST;
   \   000003 9093         LDW       Y, X
   \   000005 72A9 000A    ADDW      Y, #0xa
   \   000009 90F6         LD        A, (Y)
   \   00000B AA 10        OR        A, #0x10
   \   00000D 1C 000A      ADDW      X, #0xa
   \   000010 F7           LD        (X), A
   \   000011 87           RETF
    836            }
    837            else
    838            {
    839              /* Disable I2C DMA requests */
    840              I2Cx->ITR &= (uint8_t)(~I2C_ITR_LAST);
   \                     ??I2C_DMALastTransferCmd_0:
   \   000012 9093         LDW       Y, X
   \   000014 72A9 000A    ADDW      Y, #0xa
   \   000018 90F6         LD        A, (Y)
   \   00001A A4 EF        AND       A, #0xef
   \   00001C 1C 000A      ADDW      X, #0xa
   \   00001F F7           LD        (X), A
    841            }
    842          }
   \   000020 87           RETF
    843          
    844          /**
    845            * @}
    846            */
    847          
    848          /** @defgroup I2C_Group5 Interrupts events and flags management functions
    849           *  @brief   Interrupts, events and flags management functions
    850           *
    851          @verbatim
    852           ===============================================================================
    853                          Interrupts, events and flags management functions
    854           ===============================================================================
    855            This section provides functions allowing to configure the I2C Interrupts
    856            sources and check or clear the flags or pending bits status.
    857            The user should identify which mode will be used in his application to manage
    858            the communication: Polling mode, Interrupt mode or DMA mode.
    859          
    860           ===============================================================================
    861                                    I2C State Monitoring Functions
    862           ===============================================================================
    863           This I2C driver provides three different ways for I2C state monitoring
    864            depending on the application requirements and constraints:
    865          
    866          
    867               1. Basic state monitoring (Using I2C_CheckEvent() function)
    868               -----------------------------------------------------------
    869              It compares the status registers (SR1, SR2 and SR3) content to a given event
    870              (can be the combination of one or more flags).
    871              It returns SUCCESS if the current status includes the given flags
    872              and returns ERROR if one or more flags are missing in the current status.
    873              - When to use:
    874                - This function is suitable for most applications as well as for startup
    875                activity since the events are fully described in the product reference manual
    876                (RM0031).
    877                - It is also suitable for users who need to define their own events.
    878              - Limitations:
    879                - If an error occurs (ie. error flags are set besides to the monitored flags),
    880                  the I2C_CheckEvent() function may return SUCCESS despite the communication
    881                  hold or corrupted real state.
    882                  In this case, it is advised to use error interrupts to monitor the error
    883                  events and handle them in the interrupt IRQ handler.
    884          
    885                  @note
    886                  For error management, it is advised to use the following functions:
    887                    - I2C_ITConfig() to configure and enable the error interrupts (I2C_IT_ERR).
    888                    - I2Cx_IRQHandler() which is called when the I2C interrupts occur.
    889                      Where x is the peripheral instance (I2C1,...)
    890                   - I2C_GetFlagStatus() or I2C_GetITStatus() to be called into the
    891                     I2Cx_IRQHandler() function in order to determine which error occurred.
    892                    - I2C_ClearFlag() or I2C_ClearITPendingBit() and/or I2C_SoftwareResetCmd()
    893                      and/or I2C_GenerateStop() in order to clear the error flag and
    894                      source and return to correct communication status.
    895          
    896          
    897               2. Advanced state monitoring (Using the function I2C_GetLastEvent())
    898               --------------------------------------------------------------------
    899               Using the function I2C_GetLastEvent() which returns the image of both SR1
    900               & SR3 status registers in a single word (uint16_t) (Status Register 3 value
    901               is shifted left by 8 bits and concatenated to Status Register 1).
    902               - When to use:
    903                 - This function is suitable for the same applications above but it allows to
    904                   overcome the limitations of I2C_GetFlagStatus() function (see below).
    905                   The returned value could be compared to events already defined in the
    906                   library (stm8l15x_i2c.h) or to custom values defined by user.
    907                 - This function is suitable when multiple flags are monitored at the same time.
    908                 - At the opposite of I2C_CheckEvent() function, this function allows user to
    909                   choose when an event is accepted (when all events flags are set and no
    910                   other flags are set or just when the needed flags are set like
    911                   I2C_CheckEvent() function).
    912               - Limitations:
    913                 - User may need to define his own events.
    914                 - Same remark concerning the error management is applicable for this
    915                   function if user decides to check only regular communication flags (and
    916                   ignores error flags).
    917          
    918          
    919               3. Flag-based state monitoring (Using the function I2C_GetFlagStatus())
    920               -----------------------------------------------------------------------
    921               Using the function I2C_GetFlagStatus() which simply returns the status of
    922               one single flag (ie. I2C_FLAG_RXNE ...).
    923               - When to use:
    924                  - This function could be used for specific applications or in debug phase.
    925                  - It is suitable when only one flag checking is needed (most I2C events
    926                    are monitored through multiple flags).
    927               - Limitations:
    928                  - When calling this function, the Status register is accessed. Some flags are
    929                    cleared when the status register is accessed. So checking the status
    930                    of one Flag, may clear other ones.
    931                  - Function may need to be called twice or more in order to monitor one
    932                    single event.
    933          
    934            For detailed description of Events, please refer to section I2C_Events in
    935            stm8l15x_i2c.h file.
    936          
    937          
    938          @endverbatim
    939            * @{
    940            */
    941          
    942          /**
    943            * @brief  Enables or disables the specified I2C interrupt.
    944            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
    945            * @param  I2C_IT: specifies the I2C interrupts sources to be enabled or disabled.
    946            *          This parameter can be any combination of the following values:
    947            *            @arg I2C_IT_BUF: Buffer interrupt mask
    948            *            @arg I2C_IT_EVT: Event interrupt mask
    949            *            @arg I2C_IT_ERR: Error interrupt mask
    950            * @param  NewState: State of the interrupt.
    951            *         This parameter can be: ENABLE or DISABLE.
    952            * @retval None
    953            */

   \                                 In section .far_func.text, align 1
    954          void I2C_ITConfig(I2C_TypeDef* I2Cx, I2C_IT_TypeDef I2C_IT, FunctionalState NewState)
    955          {
   \                     I2C_ITConfig:
   \   000000 BF ..        LDW       S:?w0, X
   \   000002 93           LDW       X, Y
    956            /* Check functions parameters */
    957            assert_param(IS_I2C_CONFIG_IT(I2C_IT));
    958            assert_param(IS_FUNCTIONAL_STATE(NewState));
    959          
    960            if (NewState != DISABLE)
   \   000003 4D           TNZ       A
   \   000004 27 11        JREQ      L:??I2C_ITConfig_0
    961            {
    962              /* Enable the selected I2C interrupts */
    963              I2Cx->ITR |= (uint8_t)I2C_IT;
   \   000006 90BE ..      LDW       Y, S:?w0
   \   000009 72A9 000A    ADDW      Y, #0xa
   \   00000D 9F           LD        A, XL
   \   00000E 90FA         OR        A, (Y)
   \   000010 BE ..        LDW       X, S:?w0
   \   000012 1C 000A      ADDW      X, #0xa
   \   000015 F7           LD        (X), A
   \   000016 87           RETF
    964            }
    965            else /* NewState == DISABLE */
    966            {
    967              /* Disable the selected I2C interrupts */
    968              I2Cx->ITR &= (uint8_t)(~(uint8_t)I2C_IT);
   \                     ??I2C_ITConfig_0:
   \   000017 90BE ..      LDW       Y, S:?w0
   \   00001A 72A9 000A    ADDW      Y, #0xa
   \   00001E 9F           LD        A, XL
   \   00001F 43           CPL       A
   \   000020 90F4         AND       A, (Y)
   \   000022 BE ..        LDW       X, S:?w0
   \   000024 1C 000A      ADDW      X, #0xa
   \   000027 F7           LD        (X), A
    969            }
    970          }
   \   000028 87           RETF
    971          
    972          /**
    973            * @brief  Reads the specified I2C register and returns its value.
    974            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
    975            * @param  I2C_Register: specifies the register to read.
    976            *          This parameter can be one of the following values:
    977            *            @arg I2C_Register_CR1: CR1 register.
    978            *            @arg I2C_Register_CR2: CR2 register.
    979            *            @arg I2C_Register_FREQR: Frequency register.
    980            *            @arg I2C_Register_OARL: Own address register LSB.
    981            *            @arg I2C_Register_OARH: Own address register MSB
    982            *            @arg I2C_Register_DR: DR register.
    983            *            @arg I2C_Register_SR1: SR1 register.
    984            *            @arg I2C_Register_SR2: SR2 register.
    985            *            @arg I2C_Register_SR3: SR3 register.
    986            *            @arg I2C_Register_ITR: Interrupt and DMA register.
    987            *            @arg I2C_Register_CCRL: Clock control register low.
    988            *            @arg I2C_Register_CCRH: Clock control register high.
    989            *            @arg I2C_Register_TRISER: TRISE register.
    990            *            @arg I2C_Register_PECR: PEC register.
    991            * @retval The value of the read register.
    992            */
    993          

   \                                 In section .far_func.text, align 1
    994          uint8_t I2C_ReadRegister(I2C_TypeDef* I2Cx, I2C_Register_TypeDef I2C_Register)
    995          {
   \                     I2C_ReadRegister:
   \   000000 52 02        SUB       SP, #0x2
    996            __IO uint16_t tmp = 0;
   \   000002 905F         CLRW      Y
   \   000004 17 01        LDW       (0x1,SP), Y
    997            /* Check the parameters */
    998            assert_param(IS_I2C_REGISTER(I2C_Register));
    999          
   1000            tmp = (uint16_t) I2Cx;
   \   000006 1F 01        LDW       (0x1,SP), X
   1001            tmp += I2C_Register;
   \   000008 5F           CLRW      X
   \   000009 97           LD        XL, A
   \   00000A 72FB 01      ADDW      X, (0x1,SP)
   \   00000D 1F 01        LDW       (0x1,SP), X
   1002          
   1003            /* Return the selected register value */
   1004            return (*(__IO uint8_t *) tmp);
   \   00000F 1E 01        LDW       X, (0x1,SP)
   \   000011 F6           LD        A, (X)
   \   000012 5B 02        ADD       SP, #0x2
   \   000014 87           RETF
   1005          }
   1006          
   1007          
   1008          /**
   1009           ===============================================================================
   1010                                    1. Basic state monitoring
   1011           ===============================================================================
   1012           */
   1013          
   1014          /**
   1015            * @brief  Checks whether the last I2Cx Event is equal to the one passed
   1016            *   as parameter.
   1017            * @param  I2Cx: where x can be 1 to select the I2C peripheral.
   1018            * @param  I2C_EVENT: specifies the event to be checked.
   1019            *          This parameter can be one of the following values:
   1020            *            @arg I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED: EV1
   1021            *            @arg I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED: EV1
   1022            *            @arg I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED: EV1
   1023            *            @arg I2C_EVENT_SLAVE_BYTE_RECEIVED: EV2
   1024            *            @arg (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_GENCALL): EV2
   1025            *            @arg I2C_EVENT_SLAVE_BYTE_TRANSMITTED: EV3
   1026            *            @arg (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_GENCALL): EV3
   1027            *            @arg I2C_EVENT_SLAVE_ACK_FAILURE: EV3_2
   1028            *            @arg I2C_EVENT_SLAVE_STOP_DETECTED: EV4
   1029            *            @arg I2C_EVENT_MASTER_MODE_SELECT: EV5
   1030            *            @arg I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED: EV6
   1031            *            @arg I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED: EV6
   1032            *            @arg I2C_EVENT_MASTER_BYTE_RECEIVED: EV7
   1033            *            @arg I2C_EVENT_MASTER_BYTE_TRANSMITTING: EV8
   1034            *            @arg I2C_EVENT_MASTER_BYTE_TRANSMITTED: EV8_2
   1035            *            @arg I2C_EVENT_MASTER_MODE_ADDRESS10: EV9
   1036            *
   1037            * @note: For detailed description of Events, please refer to section
   1038            *    I2C_Events in stm8l15x_i2c.h file.
   1039            *
   1040            * @retval An ErrorStatus enumeration value:
   1041            *         - SUCCESS: Last event is equal to the I2C_EVENT
   1042            *         - ERROR: Last event is different from the I2C_EVENT
   1043            */

   \                                 In section .far_func.text, align 1
   1044          ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, I2C_Event_TypeDef I2C_Event)
   1045          {
   \                     I2C_CheckEvent:
   \   000000 52 02        SUB       SP, #0x2
   \   000002 BF ..        LDW       S:?w0, X
   \   000004 90BF ..      LDW       S:?w2, Y
   1046            __IO uint16_t lastevent = 0x00;
   \   000007 5F           CLRW      X
   \   000008 1F 01        LDW       (0x1,SP), X
   1047            uint8_t flag1 = 0x00 ;
   \   00000A 3F ..        CLR       S:?b3
   1048            uint8_t flag2 = 0x00;
   \   00000C 4F           CLR       A
   1049            ErrorStatus status = ERROR;
   \   00000D 3F ..        CLR       S:?b2
   1050          
   1051            /* Check the parameters */
   1052            assert_param(IS_I2C_EVENT(I2C_Event));
   1053          
   1054            if (I2C_Event == I2C_EVENT_SLAVE_ACK_FAILURE)
   \   00000F BE ..        LDW       X, S:?w2
   \   000011 A3 0004      CPW       X, #0x4
   \   000014 26 13        JRNE      L:??I2C_CheckEvent_0
   1055            {
   1056              lastevent = I2Cx->SR2 & I2C_SR2_AF;
   \   000016 BE ..        LDW       X, S:?w0
   \   000018 1C 0008      ADDW      X, #0x8
   \   00001B F6           LD        A, (X)
   \   00001C 5F           CLRW      X
   \   00001D 97           LD        XL, A
   \   00001E 02           RLWA      X, A
   \   00001F A4 00        AND       A, #0x0
   \   000021 02           RLWA      X, A
   \   000022 A4 04        AND       A, #0x4
   \   000024 02           RLWA      X, A
   \   000025 1F 01        LDW       (0x1,SP), X
   \   000027 20 25        JRA       L:??I2C_CheckEvent_1
   1057            }
   1058            else
   1059            {
   1060              flag1 = I2Cx->SR1;
   \                     ??I2C_CheckEvent_0:
   \   000029 BE ..        LDW       X, S:?w0
   \   00002B 1C 0007      ADDW      X, #0x7
   \   00002E F6           LD        A, (X)
   \   00002F B7 ..        LD        S:?b3, A
   1061              flag2 = I2Cx->SR3;
   \   000031 BE ..        LDW       X, S:?w0
   \   000033 1C 0009      ADDW      X, #0x9
   \   000036 F6           LD        A, (X)
   1062              lastevent = ((uint16_t)((uint16_t)flag2 << (uint16_t)8) | (uint16_t)flag1);
   \   000037 5F           CLRW      X
   \   000038 97           LD        XL, A
   \   000039 4F           CLR       A
   \   00003A 02           RLWA      X, A
   \   00003B 9093         LDW       Y, X
   \   00003D 5F           CLRW      X
   \   00003E 41           EXG       A, XL
   \   00003F B6 ..        LD        A, S:?b3
   \   000041 41           EXG       A, XL
   \   000042 BF ..        LDW       S:?w0, X
   \   000044 93           LDW       X, Y
   \   000045 01           RRWA      X, A
   \   000046 BA ..        OR        A, S:?b1
   \   000048 01           RRWA      X, A
   \   000049 BA ..        OR        A, S:?b0
   \   00004B 01           RRWA      X, A
   \   00004C 1F 01        LDW       (0x1,SP), X
   1063            }
   1064            /* Check whether the last event is equal to I2C_EVENT */
   1065            if (((uint16_t)lastevent & (uint16_t)I2C_Event) == (uint16_t)I2C_Event)
   \                     ??I2C_CheckEvent_1:
   \   00004E 1E 01        LDW       X, (0x1,SP)
   \   000050 01           RRWA      X, A
   \   000051 B4 ..        AND       A, S:?b5
   \   000053 01           RRWA      X, A
   \   000054 B4 ..        AND       A, S:?b4
   \   000056 01           RRWA      X, A
   \   000057 B3 ..        CPW       X, S:?w2
   \   000059 26 06        JRNE      L:??I2C_CheckEvent_2
   1066            {
   1067              /* SUCCESS: last event is equal to I2C_EVENT */
   1068              status = SUCCESS;
   \   00005B 35 01 ....   MOV       S:?b2, #0x1
   \   00005F 20 02        JRA       L:??I2C_CheckEvent_3
   1069            }
   1070            else
   1071            {
   1072              /* ERROR: last event is different from I2C_EVENT */
   1073              status = ERROR;
   \                     ??I2C_CheckEvent_2:
   \   000061 3F ..        CLR       S:?b2
   1074            }
   1075          
   1076            /* Return status */
   1077            return status;
   \                     ??I2C_CheckEvent_3:
   \   000063 B6 ..        LD        A, S:?b2
   \   000065 5B 02        ADD       SP, #0x2
   \   000067 87           RETF
   1078          }
   1079          
   1080          /**
   1081           ===============================================================================
   1082                                    2. Advanced state monitoring
   1083           ===============================================================================
   1084           */
   1085          
   1086          /**
   1087            * @brief  Returns the last I2C Event.
   1088            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
   1089            *
   1090            * @note: For detailed description of Events, please refer to section
   1091            *    I2C_Events in stm8l15xx_i2c.h file.
   1092            *
   1093            * @retval The last event
   1094            */

   \                                 In section .far_func.text, align 1
   1095          I2C_Event_TypeDef I2C_GetLastEvent(I2C_TypeDef* I2Cx)
   1096          {
   \                     I2C_GetLastEvent:
   \   000000 52 02        SUB       SP, #0x2
   1097            __IO uint16_t lastevent = 0;
   \   000002 905F         CLRW      Y
   \   000004 17 01        LDW       (0x1,SP), Y
   1098            uint16_t flag1 = 0;
   \   000006 3F ..        CLR       S:?b3
   \   000008 3F ..        CLR       S:?b2
   1099            uint16_t flag2 = 0;
   \   00000A 3F ..        CLR       S:?b1
   \   00000C 3F ..        CLR       S:?b0
   1100          
   1101            if ((I2Cx->SR2 & I2C_SR2_AF) != 0x00)
   \   00000E 9093         LDW       Y, X
   \   000010 72A9 0008    ADDW      Y, #0x8
   \   000014 90F6         LD        A, (Y)
   \   000016 A4 04        AND       A, #0x4
   \   000018 A1 00        CP        A, #0x0
   \   00001A 27 07        JREQ      L:??I2C_GetLastEvent_0
   1102            {
   1103              lastevent = I2C_EVENT_SLAVE_ACK_FAILURE;
   \   00001C AE 0004      LDW       X, #0x4
   \   00001F 1F 01        LDW       (0x1,SP), X
   \   000021 20 24        JRA       L:??I2C_GetLastEvent_1
   1104            }
   1105            else
   1106            {
   1107              /* Read the I2C status register */
   1108              flag1 = I2Cx->SR1;
   \                     ??I2C_GetLastEvent_0:
   \   000023 9093         LDW       Y, X
   \   000025 72A9 0007    ADDW      Y, #0x7
   \   000029 90F6         LD        A, (Y)
   \   00002B 905F         CLRW      Y
   \   00002D 9097         LD        YL, A
   \   00002F 90BF ..      LDW       S:?w1, Y
   1109              flag2 = I2Cx->SR3;
   \   000032 1C 0009      ADDW      X, #0x9
   \   000035 F6           LD        A, (X)
   \   000036 5F           CLRW      X
   \   000037 97           LD        XL, A
   \   000038 BF ..        LDW       S:?w0, X
   1110          
   1111              /* Get the last event value from I2C status register */
   1112              lastevent = ((uint16_t)((uint16_t)flag2 << 8) | (uint16_t)flag1);
   \   00003A BE ..        LDW       X, S:?w0
   \   00003C 4F           CLR       A
   \   00003D 02           RLWA      X, A
   \   00003E 01           RRWA      X, A
   \   00003F BA ..        OR        A, S:?b3
   \   000041 01           RRWA      X, A
   \   000042 BA ..        OR        A, S:?b2
   \   000044 01           RRWA      X, A
   \   000045 1F 01        LDW       (0x1,SP), X
   1113            }
   1114            /* Return status */
   1115            return (I2C_Event_TypeDef)lastevent;
   \                     ??I2C_GetLastEvent_1:
   \   000047 1E 01        LDW       X, (0x1,SP)
   \   000049 5B 02        ADD       SP, #0x2
   \   00004B 87           RETF
   1116          }
   1117          
   1118          /**
   1119           ===============================================================================
   1120                                    3. Flag-based state monitoring
   1121           ===============================================================================
   1122           */
   1123          
   1124          /**
   1125            * @brief  Checks whether the specified I2C flag is set or not.
   1126            * @param  I2Cx: where x can be 1 select the I2C peripheral.
   1127            * @param  I2C_FLAG: specifies the flag to check.
   1128            *          This parameter can be one of the following values:
   1129            *            @arg I2C_FLAG_SMBHOST: SMBus host header (Slave mode)
   1130            *            @arg I2C_FLAG_SMBDEFAULT: SMBus default header (Slave mode)
   1131            *            @arg I2C_FLAG_GENCALL: General call header flag (Slave mode)
   1132            *            @arg I2C_FLAG_TRA: Transmitter/Receiver flag
   1133            *            @arg I2C_FLAG_BUSY: Bus busy flag
   1134            *            @arg I2C_FLAG_MSL: Master/Slave flag
   1135            *            @arg I2C_FLAG_SMBALERT: SMBus Alert flag
   1136            *            @arg I2C_FLAG_TIMEOUT: Timeout or Tlow error flag
   1137            *            @arg I2C_FLAG_PECERR: PEC error in reception flag
   1138            *            @arg I2C_FLAG_OVR: Overrun/Underrun flag (Slave mode)
   1139            *            @arg I2C_FLAG_AF: Acknowledge failure flag
   1140            *            @arg I2C_FLAG_ARLO: Arbitration lost flag (Master mode)
   1141            *            @arg I2C_FLAG_BERR: Bus error flag
   1142            *            @arg I2C_FLAG_TXE: Data register empty flag (Transmitter)
   1143            *            @arg I2C_FLAG_RXNE: Data register not empty (Receiver) flag
   1144            *            @arg I2C_FLAG_STOPF: Stop detection flag (Slave mode)
   1145            *            @arg I2C_FLAG_ADD10: 10-bit header sent flag (Master mode)
   1146            *            @arg I2C_FLAG_BTF: Byte transfer finished flag
   1147            *            @arg I2C_FLAG_ADDR: Address sent flag (Master mode) ADSL
   1148            *   Address matched flag (Slave mode)ENDAD
   1149            *            @arg I2C_FLAG_SB: Start bit flag (Master mode)
   1150            * @retval The new state of I2C_FLAG (SET or RESET).
   1151            */

   \                                 In section .far_func.text, align 1
   1152          FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, I2C_FLAG_TypeDef I2C_FLAG)
   1153          {
   \                     I2C_GetFlagStatus:
   \   000000 BF ..        LDW       S:?w0, X
   1154            uint8_t tempreg = 0;
   \   000002 3F ..        CLR       S:?b4
   1155            uint8_t regindex = 0;
   \   000004 3F ..        CLR       S:?b3
   1156            FlagStatus bitstatus = RESET;
   \   000006 3F ..        CLR       S:?b2
   1157          
   1158            /* Check the parameters */
   1159            assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
   1160          
   1161            /* Read flag register index */
   1162            regindex = (uint8_t)((uint16_t)I2C_FLAG >> 8);
   \   000008 93           LDW       X, Y
   \   000009 4F           CLR       A
   \   00000A 01           RRWA      X, A
   \   00000B 9F           LD        A, XL
   \   00000C B7 ..        LD        S:?b3, A
   1163            /* Check SRx index */
   1164            switch (regindex)
   \   00000E B6 ..        LD        A, S:?b3
   \   000010 4A           DEC       A
   \   000011 27 08        JREQ      L:??I2C_GetFlagStatus_0
   \   000013 4A           DEC       A
   \   000014 27 0F        JREQ      L:??I2C_GetFlagStatus_1
   \   000016 4A           DEC       A
   \   000017 27 16        JREQ      L:??I2C_GetFlagStatus_2
   \   000019 20 1C        JRA       L:??I2C_GetFlagStatus_3
   1165            {
   1166                /* Returns whether the status register to check is SR1 */
   1167              case 0x01:
   1168                tempreg = (uint8_t)I2Cx->SR1;
   \                     ??I2C_GetFlagStatus_0:
   \   00001B BE ..        LDW       X, S:?w0
   \   00001D 1C 0007      ADDW      X, #0x7
   \   000020 F6           LD        A, (X)
   \   000021 B7 ..        LD        S:?b4, A
   1169                break;
   \   000023 20 12        JRA       L:??I2C_GetFlagStatus_3
   1170          
   1171                /* Returns whether the status register to check is SR2 */
   1172              case 0x02:
   1173                tempreg = (uint8_t)I2Cx->SR2;
   \                     ??I2C_GetFlagStatus_1:
   \   000025 BE ..        LDW       X, S:?w0
   \   000027 1C 0008      ADDW      X, #0x8
   \   00002A F6           LD        A, (X)
   \   00002B B7 ..        LD        S:?b4, A
   1174                break;
   \   00002D 20 08        JRA       L:??I2C_GetFlagStatus_3
   1175          
   1176                /* Returns whether the status register to check is SR3 */
   1177              case 0x03:
   1178                tempreg = (uint8_t)I2Cx->SR3;
   \                     ??I2C_GetFlagStatus_2:
   \   00002F BE ..        LDW       X, S:?w0
   \   000031 1C 0009      ADDW      X, #0x9
   \   000034 F6           LD        A, (X)
   \   000035 B7 ..        LD        S:?b4, A
   1179                break;
   1180          
   1181              default:
   1182                break;
   1183            }
   1184          
   1185            /* Check the status of the specified I2C flag */
   1186            if ((tempreg & (uint8_t)I2C_FLAG ) != 0)
   \                     ??I2C_GetFlagStatus_3:
   \   000037 909F         LD        A, YL
   \   000039 B4 ..        AND       A, S:?b4
   \   00003B A1 00        CP        A, #0x0
   \   00003D 27 06        JREQ      L:??I2C_GetFlagStatus_4
   1187            {
   1188              /* Flag is set */
   1189              bitstatus = SET;
   \   00003F 35 01 ....   MOV       S:?b2, #0x1
   \   000043 20 02        JRA       L:??I2C_GetFlagStatus_5
   1190            }
   1191            else
   1192            {
   1193              /* Flag is reset */
   1194              bitstatus = RESET;
   \                     ??I2C_GetFlagStatus_4:
   \   000045 3F ..        CLR       S:?b2
   1195            }
   1196            /* Return the flag status */
   1197            return bitstatus;
   \                     ??I2C_GetFlagStatus_5:
   \   000047 B6 ..        LD        A, S:?b2
   \   000049 87           RETF
   1198          }
   1199          /**
   1200            * @brief  Clear flags
   1201            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
   1202            * @param  I2C_Flag: Specifies the flag to clear
   1203            *          This parameter can be any combination of the following values:
   1204            *            @arg I2C_FLAG_SMBALERT: SMBus Alert flag
   1205            *            @arg I2C_FLAG_TIMEOUT: Timeout or Tlow error flag
   1206            *            @arg I2C_FLAG_PECERR: PEC error in reception flag
   1207            *            @arg I2C_FLAG_WUFH: Wakeup from Halt
   1208            *            @arg I2C_FLAG_OVR: Overrun/Underrun flag (Slave mode)
   1209            *            @arg I2C_FLAG_AF: Acknowledge failure flag
   1210            *            @arg I2C_FLAG_ARLO: Arbitration lost flag (Master mode)
   1211            *            @arg I2C_FLAG_BERR: Bus error flag.
   1212            * @note   STOPF (STOP detection) is cleared by software sequence: a read operation
   1213            *          to I2C_SR1 register (I2C_GetFlagStatus()) followed by a write operation
   1214            *          to I2C_CR2 register.
   1215            * @note   ADD10 (10-bit header sent) is cleared by software sequence: a read
   1216            *          operation to I2C_SR1 (I2C_GetFlagStatus()) followed by writing the
   1217            *          second byte of the address in DR register.
   1218            * @note   BTF (Byte Transfer Finished) is cleared by software sequence: a read
   1219            *         operation to I2C_SR1 register (I2C_GetFlagStatus()) followed by a
   1220            *         read/write to I2C_DR register (I2C_SendData()).
   1221            * @note   ADDR (Address sent) is cleared by software sequence: a read operation
   1222            *         to I2C_SR1 register(I2C_GetFlagStatus()) followed by a read operation
   1223            *         to I2C_SR3 register ((void)(I2Cx->SR3)).
   1224            * @note   SB (Start Bit) is cleared software sequence: a read operation to
   1225            *         I2C_SR1 register (I2C_GetFlagStatus()) followed by a write operation
   1226            *         to I2C_DR register (I2C_SendData()).
   1227            * @retval None
   1228            */

   \                                 In section .far_func.text, align 1
   1229          void I2C_ClearFlag(I2C_TypeDef* I2Cx, I2C_FLAG_TypeDef I2C_FLAG)
   1230          {
   1231            uint16_t flagpos = 0;
   \                     I2C_ClearFlag:
   \   000000 3F ..        CLR       S:?b1
   \   000002 3F ..        CLR       S:?b0
   1232            /* Check the parameters */
   1233            assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
   1234          
   1235            /* Get the I2C flag position */
   1236            flagpos = (uint16_t)I2C_FLAG & FLAG_Mask;
   \   000004 51           EXGW      X, Y
   \   000005 02           RLWA      X, A
   \   000006 A4 00        AND       A, #0x0
   \   000008 02           RLWA      X, A
   \   000009 A4 FF        AND       A, #0xff
   \   00000B 02           RLWA      X, A
   \   00000C 51           EXGW      X, Y
   \   00000D 90BF ..      LDW       S:?w0, Y
   1237            /* Clear the selected I2C flag */
   1238            I2Cx->SR2 = (uint8_t)((uint16_t)(~flagpos));
   \   000010 B6 ..        LD        A, S:?b1
   \   000012 43           CPL       A
   \   000013 1C 0008      ADDW      X, #0x8
   \   000016 F7           LD        (X), A
   1239          }
   \   000017 87           RETF
   1240          
   1241          /**
   1242            * @brief  Checks whether the specified I2C interrupt has occurred or not.
   1243            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
   1244            * @param  I2C_IT: specifies the interrupt source to check.
   1245            *            This parameter can be one of the following values:
   1246            *            @arg I2C_IT_SMBALERT: SMBus Alert interrupt
   1247            *            @arg I2C_IT_TIMEOUT: Timeout or Tlow error interrupt
   1248            *            @arg I2C_IT_PECERR: PEC error in reception  interrupt
   1249            *            @arg I2C_IT_WUFH: Wakeup from Halt
   1250            *            @arg I2C_IT_OVR: Overrun/Underrun flag (Slave mode)
   1251            *            @arg I2C_IT_AF: Acknowledge failure flag
   1252            *            @arg I2C_IT_ARLO: Arbitration lost flag (Master mode)
   1253            *            @arg I2C_IT_BERR: Bus error flag
   1254            *            @arg I2C_IT_TXE: Data register empty flag (Transmitter)
   1255            *            @arg I2C_IT_RXNE: Data register not empty (Receiver) flag
   1256            *            @arg I2C_IT_STOPF: Stop detection flag (Slave mode)
   1257            *            @arg I2C_IT_ADD10: 10-bit header sent flag (Master mode)
   1258            *            @arg I2C_IT_BTF: Byte transfer finished flag
   1259            *            @arg I2C_IT_ADDR: Address sent flag (Master mode) ADSL
   1260            *                              Address matched flag (Slave mode)ENDAD
   1261            *            @arg I2C_IT_SB: Start bit flag (Master mode)
   1262            * @retval The new state of I2C_IT
   1263            */

   \                                 In section .far_func.text, align 1
   1264          ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, I2C_IT_TypeDef I2C_IT)
   1265          {
   \                     I2C_GetITStatus:
   \   000000 52 01        SUB       SP, #0x1
   \   000002 BF ..        LDW       S:?w2, X
   \   000004 90BF ..      LDW       S:?w0, Y
   1266            ITStatus bitstatus = RESET;
   \   000007 3F ..        CLR       S:?b2
   1267            __IO uint8_t enablestatus = 0;
   \   000009 4F           CLR       A
   \   00000A 6B 01        LD        (0x1,SP), A
   1268            uint16_t tempregister = 0;
   \   00000C 905F         CLRW      Y
   1269          
   1270            /* Check the parameters */
   1271            assert_param(IS_I2C_GET_IT(I2C_IT));
   1272          
   1273            tempregister = (uint8_t)( ((uint16_t)((uint16_t)I2C_IT & ITEN_Mask)) >> 8);
   \   00000E BE ..        LDW       X, S:?w0
   \   000010 4F           CLR       A
   \   000011 01           RRWA      X, A
   \   000012 9F           LD        A, XL
   \   000013 A4 07        AND       A, #0x7
   \   000015 5F           CLRW      X
   \   000016 97           LD        XL, A
   \   000017 9093         LDW       Y, X
   1274          
   1275            /* Check if the interrupt source is enabled or not */
   1276            enablestatus = (uint8_t)(I2Cx->ITR & ( uint8_t)tempregister);
   \   000019 BE ..        LDW       X, S:?w2
   \   00001B 1C 000A      ADDW      X, #0xa
   \   00001E 909F         LD        A, YL
   \   000020 F4           AND       A, (X)
   \   000021 6B 01        LD        (0x1,SP), A
   1277          
   1278            if ((uint16_t)((uint16_t)I2C_IT & REGISTER_Mask) == REGISTER_SR1_Index)
   1279            {
   1280              /* Check the status of the specified I2C flag */
   1281              if (((I2Cx->SR1 & (uint8_t)I2C_IT) != RESET) && enablestatus)
   1282              {
   1283                /* I2C_IT is set */
   1284                bitstatus = SET;
   1285              }
   1286              else
   1287              {
   1288                /* I2C_IT is reset */
   1289                bitstatus = RESET;
   1290              }
   1291            }
   1292            else
   1293            {
   1294              /* Check the status of the specified I2C flag */
   1295              if (((I2Cx->SR2 & (uint8_t)I2C_IT) != RESET) && enablestatus)
   \   000023 BE ..        LDW       X, S:?w2
   \   000025 1C 0008      ADDW      X, #0x8
   \   000028 B6 ..        LD        A, S:?b1
   \   00002A F4           AND       A, (X)
   \   00002B A1 00        CP        A, #0x0
   \   00002D 27 0A        JREQ      L:??I2C_GetITStatus_0
   \   00002F 0D 01        TNZ       (0x1,SP)
   \   000031 27 06        JREQ      L:??I2C_GetITStatus_0
   1296              {
   1297                /* I2C_IT is set */
   1298                bitstatus = SET;
   \   000033 35 01 ....   MOV       S:?b2, #0x1
   \   000037 20 02        JRA       L:??I2C_GetITStatus_1
   1299              }
   1300              else
   1301              {
   1302                /* I2C_IT is reset */
   1303                bitstatus = RESET;
   \                     ??I2C_GetITStatus_0:
   \   000039 3F ..        CLR       S:?b2
   1304              }
   1305            }
   1306            /* Return the I2C_IT status */
   1307            return  bitstatus;
   \                     ??I2C_GetITStatus_1:
   \   00003B B6 ..        LD        A, S:?b2
   \   00003D 5B 01        ADD       SP, #0x1
   \   00003F 87           RETF
   1308          }
   1309          /**
   1310            * @brief  Clear IT pending bit
   1311            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
   1312            * @param  I2C_IT: specifies the interrupt pending bit to clear.
   1313            *            This parameter can be any combination of the following values:
   1314            *            @arg I2C_IT_SMBALERT: SMBus Alert interrupt
   1315            *            @arg I2C_IT_TIMEOUT: Timeout or Tlow error interrupt
   1316            *            @arg I2C_IT_PECERR: PEC error in reception  interrupt
   1317            *            @arg I2C_IT_WUFH: Wakeup from Halt
   1318            *            @arg I2C_IT_OVR: Overrun/Underrun interrupt (Slave mode)
   1319            *            @arg I2C_IT_AF: Acknowledge failure interrupt
   1320            *            @arg I2C_IT_ARLO: Arbitration lost interrupt (Master mode)
   1321            *            @arg I2C_IT_BERR: Bus error interrupt
   1322            *
   1323            * @note   STOPF (STOP detection) is cleared by software sequence: a read operation
   1324            *         to I2C_SR1 register (I2C_GetITStatus()) followed by a write operation to
   1325            *         I2C_CR2 register (I2C_AcknowledgeConfig() to configure the I2C peripheral Acknowledge).
   1326            * @note   ADD10 (10-bit header sent) is cleared by software sequence: a read
   1327            *         operation to I2C_SR1 (I2C_GetITStatus()) followed by writing the second
   1328            *         byte of the address in I2C_DR register.
   1329            * @note   BTF (Byte Transfer Finished) is cleared by software sequence: a read
   1330            *         operation to I2C_SR1 register (I2C_GetITStatus()) followed by a read/write to
   1331            *         I2C_DR register (I2C_SendData()).
   1332            * @note   ADDR (Address sent) is cleared by software sequence: a read operation
   1333            *         to I2C_SR1 register (I2C_GetITStatus()) followed by a read operation
   1334            *         to I2C_SR3 register ((void)(I2Cx->SR3)).
   1335            * @note   SB (Start Bit) is cleared by software sequence: a read operation to
   1336            *         I2C_SR1 register (I2C_GetITStatus()) followed by a write operation to
   1337            *         I2C_DR register (I2C_SendData()).
   1338            * @retval None
   1339            */

   \                                 In section .far_func.text, align 1
   1340          void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, I2C_IT_TypeDef I2C_IT)
   1341          {
   1342            uint16_t flagpos = 0;
   \                     I2C_ClearITPendingBit:
   \   000000 3F ..        CLR       S:?b1
   \   000002 3F ..        CLR       S:?b0
   1343          
   1344            /* Check the parameters */
   1345            assert_param(IS_I2C_CLEAR_IT(I2C_IT));
   1346          
   1347            /* Get the I2C flag position */
   1348            flagpos = (uint16_t)I2C_IT & FLAG_Mask;
   \   000004 51           EXGW      X, Y
   \   000005 02           RLWA      X, A
   \   000006 A4 00        AND       A, #0x0
   \   000008 02           RLWA      X, A
   \   000009 A4 FF        AND       A, #0xff
   \   00000B 02           RLWA      X, A
   \   00000C 51           EXGW      X, Y
   \   00000D 90BF ..      LDW       S:?w0, Y
   1349          
   1350            /* Clear the selected I2C flag */
   1351            I2Cx->SR2 = (uint8_t)((uint16_t)~flagpos);
   \   000010 B6 ..        LD        A, S:?b1
   \   000012 43           CPL       A
   \   000013 1C 0008      ADDW      X, #0x8
   \   000016 F7           LD        (X), A
   1352          }
   \   000017 87           RETF
   1353          /**
   1354            * @}
   1355            */
   1356          
   1357          /**
   1358            * @}
   1359            */
   1360          
   1361          /**
   1362            * @}
   1363            */
   1364          
   1365          /**
   1366            * @}
   1367            */
   1368          
   1369          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Section sizes:

   Bytes  Function/Label
   -----  --------------
      13  I2C_ARPCmd
      27  I2C_AckPositionConfig
      25  I2C_AcknowledgeConfig
      13  I2C_CalculatePEC
     104  I2C_CheckEvent
      24  I2C_ClearFlag
      24  I2C_ClearITPendingBit
      13  I2C_Cmd
      33  I2C_DMACmd
      33  I2C_DMALastTransferCmd
      79  I2C_DeInit
      33  I2C_DualAddressCmd
      34  I2C_FastModeDutyCycleConfig
      13  I2C_GeneralCallCmd
      25  I2C_GenerateSTART
      25  I2C_GenerateSTOP
      74  I2C_GetFlagStatus
      64  I2C_GetITStatus
      76  I2C_GetLastEvent
       5  I2C_GetPEC
      41  I2C_ITConfig
     480  I2C_Init
      35  I2C_OwnAddress2Config
      27  I2C_PECPositionConfig
      21  I2C_ReadRegister
       5  I2C_ReceiveData
      25  I2C_SMBusAlertConfig
      15  I2C_Send7bitAddress
       5  I2C_SendData
      25  I2C_SoftwareResetCmd
      13  I2C_StretchClockCmd
      25  I2C_TransmitPEC

 
 1 454 bytes in section .far_func.text
 
 1 454 bytes of CODE memory

Errors: none
Warnings: none
