###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.42.1.142 for STM8               01/Jul/2016  17:30:48 #
# Copyright 2010-2013 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  E:\hwpro-2016\20160627_L\stm8l15x_lib\src\stm8l15x_lcd.c #
#    Command line =  E:\hwpro-2016\20160627_L\stm8l15x_lib\src\stm8l15x_lcd.c #
#                     -e -Ol --no_cse --no_unroll --no_inline                 #
#                    --no_code_motion --no_tbaa --no_cross_call --debug       #
#                    --code_model medium --data_model medium -o               #
#                    E:\hwpro-2016\20160627_L\iar\Debug\Obj\ --dlib_config    #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.5\stm8\LIB\dlstm8mmn.h" -D STM8L15X_MD -lC             #
#                    E:\hwpro-2016\20160627_L\iar\Debug\List\ -I              #
#                    E:\hwpro-2016\20160627_L\iar\..\stm8l15x_lib\inc\ -I     #
#                    E:\hwpro-2016\20160627_L\iar\..\user\inc\ -I             #
#                    E:\hwpro-2016\20160627_L\iar\..\utils\xprintf\ -I        #
#                    E:\hwpro-2016\20160627_L\iar\..\drivers\ -I              #
#                    E:\hwpro-2016\20160627_L\iar\..\utils\ -I                #
#                    E:\hwpro-2016\20160627_L\iar\..\app\ --vregs 16          #
#    List file    =  E:\hwpro-2016\20160627_L\iar\Debug\List\stm8l15x_lcd.lst #
#    Object file  =  E:\hwpro-2016\20160627_L\iar\Debug\Obj\stm8l15x_lcd.o    #
#                                                                             #
#                                                                             #
###############################################################################

E:\hwpro-2016\20160627_L\stm8l15x_lib\src\stm8l15x_lcd.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm8l15x_lcd.c
      4            * @author  MCD Application Team
      5            * @version V1.6.1
      6            * @date    30-September-2014
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the LCD controller (LCD) peripheral:           
      9            *           - Initialization and configuration
     10            *           - LCD RAM memory write
     11            *           - Interrupts and flags management   
     12            *           
     13            *  @verbatim
     14            *      
     15            *          ===================================================================      
     16            *                                    LCD Clock
     17            *          ===================================================================    
     18            *          LCD has tow clock sources:
     19            *            - RTCCLK divided by 2 used to generate LCD frame rate
     20            *            - LCDCLK to used for LCD registers read/write access
     21            *                   
     22            *          To configure the RTCCLK/LCDCLK, proceed as follows:
     23            *            - Enable RTC clock using CLK_PeripheralClockConfig(CLK_Peripheral_RTC, ENABLE)
     24            *              function
     25            *            - Enable LCD clock using CLK_PeripheralClockConfig(CLK_Peripheral_LCD, ENABLE)
     26            *              function  
     27            *            - Select the RTC clock source using the CLK_RTCClockConfig() function.    
     28            *            
     29            *          ===================================================================      
     30            *                                  LCD and low power modes
     31            *          =================================================================== 
     32            *          The LCD remains active during Active-halt, Wait, Low power run and 
     33            *          Low power wait modes unless disabled
     34            *              
     35            *          ===================================================================
     36            *                                 How to use this driver
     37            *          =================================================================== 
     38            *          1. Enable RTC clock using CLK_PeripheralClockConfig(CLK_Peripheral_RTC, ENABLE) function 
     39            *            
     40            *          2. Enable LCD clock using CLK_PeripheralClockConfig(CLK_Peripheral_LCD, ENABLE) function
     41            *            
     42            *          3. Select the RTC clock source using the CLK_RTCClockConfig() function. 
     43            *          
     44            *          4. Configure the LCD prescaler, divider, duty, bias and voltage source
     45            *             using LCD_Init() function     
     46            *            
     47            *          5. Call the LCD_PortMaskConfig() function to assign the unused SEGx
     48            *             (segment) and COMx (common) pins as standard general purpose IOs
     49            *
     50            *          6. Optionally you can enable/configure:
     51            *              -  LCD High Drive using the LCD_HighDriveCmd() function
     52            *              -  LCD Pulse ON Duration using the LCD_PulseOnDurationConfig() function
     53            *              -  LCD Dead Time using the LCD_DeadTimeConfig() function  
     54            *              -  The LCD Blink mode and frequency using the LCD_BlinkConfig() function
     55            *              -  The LCD Contrast using the LCD_ContrastConfig() function  
     56            *
     57            *          7. Call the LCD_Cmd() to enable the LCD controller
     58            *          
     59            *          8. Write to the LCD RAM memory using the LCD_WriteRAM() function.
     60            *          
     61            *  @endverbatim
     62            *           
     63            ******************************************************************************
     64            * @attention
     65            *
     66            * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
     67            *
     68            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     69            * You may not use this file except in compliance with the License.
     70            * You may obtain a copy of the License at:
     71            *
     72            *        http://www.st.com/software_license_agreement_liberty_v2
     73            *
     74            * Unless required by applicable law or agreed to in writing, software 
     75            * distributed under the License is distributed on an "AS IS" BASIS, 
     76            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     77            * See the License for the specific language governing permissions and
     78            * limitations under the License.
     79            *
     80            ******************************************************************************
     81            */
     82          
     83          /* Includes ------------------------------------------------------------------*/
     84          #include "stm8l15x_lcd.h"
     85          
     86          /** @addtogroup STM8L15x_StdPeriph_Driver
     87            * @{
     88            */
     89            
     90          /** @defgroup LCD 
     91            * @brief LCD driver modules
     92            * @{
     93            */
     94          /* Private typedef -----------------------------------------------------------*/
     95          /* Private define ------------------------------------------------------------*/
     96          /* Private macro -------------------------------------------------------------*/
     97          /* Private function prototypes -----------------------------------------------*/
     98          /* Private functions ---------------------------------------------------------*/
     99          
    100          /** @defgroup LCD_Private_Functions
    101            * @{
    102            */
    103          
    104          /** @defgroup LCD_Group1 Initialization and Configuration functions
    105           *  @brief   Initialization and Configuration functions 
    106           *
    107          @verbatim   
    108           ===============================================================================
    109                              Initialization and Configuration functions
    110           ===============================================================================  
    111          
    112          @endverbatim
    113            * @{
    114            */
    115            
    116          /**
    117            * @brief  Deinitializes the LCD Controller registers to their default reset values.
    118            * @param  None
    119            * @retval None
    120            */

   \                                 In section .far_func.text, align 1
    121          void LCD_DeInit(void)
    122          {
    123            uint8_t counter = 0;
   \                     LCD_DeInit:
   \   000000 3F ..        CLR       S:?b0
    124          
    125            LCD->CR1 = LCD_CR1_RESET_VALUE;
   \   000002 35 00 5400   MOV       L:0x5400, #0x0
    126            LCD->CR2 = LCD_CR2_RESET_VALUE;
   \   000006 35 00 5401   MOV       L:0x5401, #0x0
    127            LCD->CR3 = LCD_CR3_RESET_VALUE;
   \   00000A 35 00 5402   MOV       L:0x5402, #0x0
    128            LCD->FRQ = LCD_FRQ_RESET_VALUE;
   \   00000E 35 00 5403   MOV       L:0x5403, #0x0
    129          
    130            for (counter = 0;counter < 0x05; counter++)
   \   000012 4F           CLR       A
   \   000013 B7 ..        LD        S:?b0, A
   \   000015 20 10        JRA       L:??LCD_DeInit_0
    131            {
    132              LCD->PM[counter] = LCD_PM_RESET_VALUE;
   \                     ??LCD_DeInit_1:
   \   000017 5F           CLRW      X
   \   000018 41           EXG       A, XL
   \   000019 B6 ..        LD        A, S:?b0
   \   00001B 41           EXG       A, XL
   \   00001C 1C 5404      ADDW      X, #0x5404
   \   00001F 4F           CLR       A
   \   000020 F7           LD        (X), A
    133            }
   \   000021 B6 ..        LD        A, S:?b0
   \   000023 AB 01        ADD       A, #0x1
   \   000025 B7 ..        LD        S:?b0, A
   \                     ??LCD_DeInit_0:
   \   000027 B6 ..        LD        A, S:?b0
   \   000029 A1 05        CP        A, #0x5
   \   00002B 25 EA        JRC       L:??LCD_DeInit_1
    134          
    135            for (counter = 0;counter < 0x16; counter++)
   \   00002D 3F ..        CLR       S:?b0
   \   00002F 20 10        JRA       L:??LCD_DeInit_2
    136            {
    137              LCD->RAM[counter] =  LCD_RAM_RESET_VALUE;
   \                     ??LCD_DeInit_3:
   \   000031 5F           CLRW      X
   \   000032 41           EXG       A, XL
   \   000033 B6 ..        LD        A, S:?b0
   \   000035 41           EXG       A, XL
   \   000036 1C 540C      ADDW      X, #0x540c
   \   000039 4F           CLR       A
   \   00003A F7           LD        (X), A
    138            }
   \   00003B B6 ..        LD        A, S:?b0
   \   00003D AB 01        ADD       A, #0x1
   \   00003F B7 ..        LD        S:?b0, A
   \                     ??LCD_DeInit_2:
   \   000041 B6 ..        LD        A, S:?b0
   \   000043 A1 16        CP        A, #0x16
   \   000045 25 EA        JRC       L:??LCD_DeInit_3
    139          
    140            LCD->CR4 = LCD_CR4_RESET_VALUE;
   \   000047 35 00 542F   MOV       L:0x542f, #0x0
    141          
    142          }
   \   00004B 87           RETF
    143          
    144          /**
    145            * @brief  Initializes the LCD according to the specified parameters.
    146            * @param  LCD_CLKPrescalerDiv : LCD clock prescaler 
    147            *          This parameter can be one of the following values:
    148            *            @arg LCD_Prescaler_1: CLKprescaler = ClKinput 
    149            *            @arg LCD_Prescaler_2: CLKprescaler = ClKinput/2 
    150            *            @arg LCD_Prescaler_4: CLKprescaler = ClKinput/4
    151            *            @arg LCD_Prescaler_8: CLKprescaler = ClKinput/8 
    152            *            @arg LCD_Prescaler_16: CLKprescaler = ClKinput/16
    153            *            @arg LCD_Prescaler_32: CLKprescaler = ClKinput/32
    154            *            @arg LCD_Prescaler_64: CLKprescaler = ClKinput/64 
    155            *            @arg LCD_Prescaler_128: CLKprescaler = ClKinput/128 
    156            *            @arg LCD_Prescaler_256: CLKprescaler = ClKinput/256 
    157            *            @arg LCD_Prescaler_512: CLKprescaler = ClKinput/512 
    158            *            @arg LCD_Prescaler_1024: CLKprescaler = ClKinput/1024 
    159            *            @arg LCD_Prescaler_2048: CLKprescaler = ClKinput/2048 
    160            *            @arg LCD_Prescaler_4096: CLKprescaler = ClKinput/4096 
    161            *            @arg LCD_Prescaler_8192: CLKprescaler = ClKinput/8192 
    162            *            @arg LCD_Prescaler_16384: CLKprescaler = ClKinput/16384 
    163            *            @arg LCD_Prescaler_32768: CLKprescaler = ClKinput/32768              
    164            * @param  LCD_Divider : LCD clock divider
    165            *          This parameter can be one of the following values:
    166            *            @arg LCD_Divider_16: LCD frequency = CLKprescaler/16 
    167            *            @arg LCD_Divider_17: LCD frequency = CLKprescaler/17
    168            *            @arg LCD_Divider_18: LCD frequency = CLKprescaler/18
    169            *            @arg LCD_Divider_19: LCD frequency = CLKprescaler/19
    170            *            @arg LCD_Divider_20: LCD frequency = CLKprescaler/20
    171            *            @arg LCD_Divider_21: LCD frequency = CLKprescaler/21
    172            *            @arg LCD_Divider_22: LCD frequency = CLKprescaler/22
    173            *            @arg LCD_Divider_23: LCD frequency = CLKprescaler/23
    174            *            @arg LCD_Divider_24: LCD frequency = CLKprescaler/24
    175            *            @arg LCD_Divider_25: LCD frequency = CLKprescaler/25
    176            *            @arg LCD_Divider_26: LCD frequency = CLKprescaler/26
    177            *            @arg LCD_Divider_27: LCD frequency = CLKprescaler/27
    178            *            @arg LCD_Divider_28: LCD frequency = CLKprescaler/28
    179            *            @arg LCD_Divider_29: LCD frequency = CLKprescaler/29
    180            *            @arg LCD_Divider_30: LCD frequency = CLKprescaler/30
    181            *            @arg LCD_Divider_31: LCD frequency = CLKprescaler/31
    182            * @param  LCD_Duty : LCD duty
    183            *          This parameter can be one of the following values:
    184            *            @arg LCD_Duty_Static: Static duty 
    185            *            @arg LCD_Duty_1_2: 1/2 duty
    186            *            @arg LCD_Duty_1_3: 1/3 duty
    187            *            @arg LCD_Duty_1_4: 1/4 duty
    188            *            @arg LCD_Duty_1_8: 1/8 duty   
    189            * @param  LCD_Bias : LCD bias
    190            *          This parameter can be one of the following values:
    191            *            @arg LCD_Bias_1_4: 1/4 bias
    192            *            @arg LCD_Bias_1_3: 1/3 bias
    193            *            @arg LCD_Bias_1_2: 1/2 bias
    194            * @param  LCD_VoltageSource : LCD voltage source
    195            *          This parameter can be one of the following values:
    196            *            @arg LCD_VoltageSource_Internal: Internal voltage source
    197            *            @arg LCD_VoltageSource_External: External voltage source
    198            * @retval None
    199            */

   \                                 In section .far_func.text, align 1
    200          void LCD_Init(LCD_Prescaler_TypeDef LCD_Prescaler, LCD_Divider_TypeDef LCD_Divider,
    201                        LCD_Duty_TypeDef LCD_Duty, LCD_Bias_TypeDef LCD_Bias,
    202                        LCD_VoltageSource_TypeDef LCD_VoltageSource)
    203          {
   \                     LCD_Init:
   \   000000 B7 ..        LD        S:?b4, A
    204            /* Check function parameters */
    205            assert_param(IS_LCD_CLOCK_PRESCALER(LCD_Prescaler));
    206            assert_param(IS_LCD_CLOCK_DIVIDER(LCD_Divider));
    207            assert_param(IS_LCD_DUTY(LCD_Duty));
    208            assert_param(IS_LCD_BIAS(LCD_Bias));
    209            assert_param(IS_LCD_VOLTAGE_SOURCE(LCD_VoltageSource));
    210          
    211            LCD->FRQ &= (uint8_t)(~LCD_FRQ_PS);     /* Clear the prescaler bits */
   \   000002 C6 5403      LD        A, L:0x5403
   \   000005 A4 0F        AND       A, #0xf
   \   000007 C7 5403      LD        L:0x5403, A
    212            LCD->FRQ |= LCD_Prescaler;
   \   00000A B6 ..        LD        A, S:?b4
   \   00000C CA 5403      OR        A, L:0x5403
   \   00000F C7 5403      LD        L:0x5403, A
    213          
    214            LCD->FRQ &= (uint8_t)(~LCD_FRQ_DIV);     /* Clear the divider bits */
   \   000012 C6 5403      LD        A, L:0x5403
   \   000015 A4 F0        AND       A, #0xf0
   \   000017 C7 5403      LD        L:0x5403, A
    215            LCD->FRQ |= LCD_Divider;
   \   00001A B6 ..        LD        A, S:?b0
   \   00001C CA 5403      OR        A, L:0x5403
   \   00001F C7 5403      LD        L:0x5403, A
    216          
    217            /* Configure the Duty cycle */
    218            LCD->CR1 &= (uint8_t)(~LCD_CR1_DUTY);    /* Clear the duty bits */
   \   000022 C6 5400      LD        A, L:0x5400
   \   000025 A4 F9        AND       A, #0xf9
   \   000027 C7 5400      LD        L:0x5400, A
    219            LCD->CR4 &= (uint8_t)(~LCD_CR4_DUTY8);   /* Clear the DUTY8 bit */
   \   00002A 7213 542F    BRES      L:0x542f, #0x1
    220          
    221            if (LCD_Duty == LCD_Duty_1_8)
   \   00002E B6 ..        LD        A, S:?b1
   \   000030 A1 20        CP        A, #0x20
   \   000032 26 0D        JRNE      L:??LCD_Init_0
    222            {
    223              LCD->CR4 |= (uint8_t)((uint8_t)((uint8_t)LCD_Duty & (uint8_t)0xF0) >> 4);
   \   000034 B6 ..        LD        A, S:?b1
   \   000036 4E           SWAP      A
   \   000037 A4 0F        AND       A, #0xf
   \   000039 CA 542F      OR        A, L:0x542f
   \   00003C C7 542F      LD        L:0x542f, A
   \   00003F 20 0A        JRA       L:??LCD_Init_1
    224            }
    225            else
    226            {
    227              LCD->CR1 |= (uint8_t)((uint8_t)LCD_Duty & (uint8_t)0x0F);
   \                     ??LCD_Init_0:
   \   000041 B6 ..        LD        A, S:?b1
   \   000043 A4 0F        AND       A, #0xf
   \   000045 CA 5400      OR        A, L:0x5400
   \   000048 C7 5400      LD        L:0x5400, A
    228            }
    229          
    230            /* Configure the Bias */
    231            LCD->CR1 &= (uint8_t)(~LCD_CR1_B2);      /* Clear the B2 bit */
   \                     ??LCD_Init_1:
   \   00004B 7211 5400    BRES      L:0x5400, #0x0
    232            LCD->CR4 &= (uint8_t)(~LCD_CR4_B4);      /* Clear the B4 bit */
   \   00004F 7211 542F    BRES      L:0x542f, #0x0
    233          
    234            if (LCD_Bias == LCD_Bias_1_4)
   \   000053 B6 ..        LD        A, S:?b2
   \   000055 A1 10        CP        A, #0x10
   \   000057 26 17        JRNE      L:??LCD_Init_2
    235            {
    236              LCD->CR1 |= (uint8_t)((uint8_t)LCD_Bias & (uint8_t)0x0F);
   \   000059 B6 ..        LD        A, S:?b2
   \   00005B A4 0F        AND       A, #0xf
   \   00005D CA 5400      OR        A, L:0x5400
   \   000060 C7 5400      LD        L:0x5400, A
    237              LCD->CR4 |= (uint8_t)((uint8_t)((uint8_t)LCD_Bias & (uint8_t)0xF0) >> 4);
   \   000063 B6 ..        LD        A, S:?b2
   \   000065 4E           SWAP      A
   \   000066 A4 0F        AND       A, #0xf
   \   000068 CA 542F      OR        A, L:0x542f
   \   00006B C7 542F      LD        L:0x542f, A
   \   00006E 20 0A        JRA       L:??LCD_Init_3
    238            }
    239            else
    240            {
    241              LCD->CR1 |= (uint8_t)((uint8_t)LCD_Bias & (uint8_t)0x0F);
   \                     ??LCD_Init_2:
   \   000070 B6 ..        LD        A, S:?b2
   \   000072 A4 0F        AND       A, #0xf
   \   000074 CA 5400      OR        A, L:0x5400
   \   000077 C7 5400      LD        L:0x5400, A
    242            }
    243          
    244            LCD->CR2 &= (uint8_t)(~LCD_CR2_VSEL);    /* Clear the voltage source bit */
   \                     ??LCD_Init_3:
   \   00007A 7211 5401    BRES      L:0x5401, #0x0
    245            LCD->CR2 |= LCD_VoltageSource;
   \   00007E B6 ..        LD        A, S:?b3
   \   000080 CA 5401      OR        A, L:0x5401
   \   000083 C7 5401      LD        L:0x5401, A
    246          
    247          }
   \   000086 87           RETF
    248          
    249          /**
    250            * @brief  Configures the LCD Port Mask.
    251            * @param  LCD_PortMaskRegister: The LCD register index in the port mask matrix.
    252            *          This parameter can be one of the following values:
    253            *            @arg LCD_PortMaskRegister_0: PortMask Register 0  
    254            *            @arg LCD_PortMaskRegister_1: PortMask Register 1
    255            *            @arg LCD_PortMaskRegister_2: PortMask Register 2
    256            *            @arg LCD_PortMaskRegister_3: PortMask Register 3
    257            *            @arg LCD_PortMaskRegister_4: PortMask Register 4
    258            *            @arg LCD_PortMaskRegister_5: PortMask Register 5        
    259            * @param  LCD_Mask : Value to be written
    260            * @retval None
    261            */

   \                                 In section .far_func.text, align 1
    262          void LCD_PortMaskConfig(LCD_PortMaskRegister_TypeDef LCD_PortMaskRegister, uint8_t LCD_Mask)
    263          {
    264            /* Check function parameters */
    265            assert_param(IS_LCD_PORT_MASK(LCD_PortMaskRegister));
    266          
    267            /* Copy data bytes to Port mask register */
    268            LCD->PM[LCD_PortMaskRegister] =  LCD_Mask;
   \                     LCD_PortMaskConfig:
   \   000000 5F           CLRW      X
   \   000001 97           LD        XL, A
   \   000002 1C 5404      ADDW      X, #0x5404
   \   000005 B6 ..        LD        A, S:?b0
   \   000007 F7           LD        (X), A
    269          
    270          }
   \   000008 87           RETF
    271          
    272          /**
    273            * @brief  Enables or disables the LCD Controller.
    274            * @param  NewState: new state of the LCD peripheral.
    275            *          This parameter can be: ENABLE or DISABLE.
    276            * @retval None
    277            * @retval None
    278            */

   \                                 In section .far_func.text, align 1
    279          void LCD_Cmd(FunctionalState NewState)
    280          {
    281            /* Check function parameters */
    282            assert_param(IS_FUNCTIONAL_STATE(NewState));
    283          
    284            if (NewState != DISABLE)
   \                     LCD_Cmd:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??LCD_Cmd_0
    285            {
    286              LCD->CR3 |= LCD_CR3_LCDEN; /* Enable the LCD peripheral*/
   \   000003 721C 5402    BSET      L:0x5402, #0x6
   \   000007 87           RETF
    287            }
    288            else
    289            {
    290              LCD->CR3 &= (uint8_t)(~LCD_CR3_LCDEN); /* Disable the LCD peripheral*/
   \                     ??LCD_Cmd_0:
   \   000008 721D 5402    BRES      L:0x5402, #0x6
    291            }
    292          }
   \   00000C 87           RETF
    293          
    294          /**
    295            * @brief  Enables or disables the low resistance divider. Displays with high 
    296            *         internal resistance may need a longer drive time to achieve 
    297            *         satisfactory contrast. This function is useful in this case if some 
    298            *         additional power consumption can be tolerated.
    299            * @note   When this mode is enabled, the PulseOn Duration (PON) have to be 
    300            *         programmed to 1/CK_PS (LCD_PulseOnDuration_1).    
    301            * @param  NewState: new state of the low resistance divider.
    302            *          This parameter can be: ENABLE or DISABLE.
    303            * @retval None
    304            */

   \                                 In section .far_func.text, align 1
    305          void LCD_HighDriveCmd(FunctionalState NewState)
    306          {
    307            /* Check function parameters */
    308            assert_param(IS_FUNCTIONAL_STATE(NewState));
    309          
    310            if (NewState != DISABLE)
   \                     LCD_HighDriveCmd:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??LCD_HighDriveCmd_0
    311            {
    312              LCD->CR2 |= LCD_CR2_HD; /* Permanently enable low resistance divider */
   \   000003 7218 5401    BSET      L:0x5401, #0x4
   \   000007 87           RETF
    313            }
    314            else
    315            {
    316              LCD->CR2 &= (uint8_t)(~LCD_CR2_HD); /* Permanently disable low resistance divider */
   \                     ??LCD_HighDriveCmd_0:
   \   000008 7219 5401    BRES      L:0x5401, #0x4
    317            }
    318          }
   \   00000C 87           RETF
    319          
    320          /**
    321            * @brief  Configures the LCD pulses on duration.
    322            * @param  LCD_PulseOnDuration: specifies the LCD pulse on duration in terms of 
    323            *         CLKprescaler (prescaled LCD clock period) pulses.
    324            *          This parameter can be one of the following values:
    325            *            @arg LCD_PulseOnDuration_0: 0 pulse
    326            *            @arg LCD_PulseOnDuration_1: Pulse ON duration = 1/CLKprescaler
    327            *            @arg LCD_PulseOnDuration_2: Pulse ON duration = 2/CLKprescaler
    328            *            @arg LCD_PulseOnDuration_3: Pulse ON duration = 3/CLKprescaler
    329            *            @arg LCD_PulseOnDuration_4: Pulse ON duration = 4/CLKprescaler
    330            *            @arg LCD_PulseOnDuration_5: Pulse ON duration = 5/CLKprescaler
    331            *            @arg LCD_PulseOnDuration_6: Pulse ON duration = 6/CLKprescaler
    332            *            @arg LCD_PulseOnDuration_7: Pulse ON duration = 7/CLKprescaler
    333            * @retval None
    334            */

   \                                 In section .far_func.text, align 1
    335          void LCD_PulseOnDurationConfig(LCD_PulseOnDuration_TypeDef LCD_PulseOnDuration)
    336          {
   \                     LCD_PulseOnDurationConfig:
   \   000000 B7 ..        LD        S:?b0, A
    337            /* Check function parameters */
    338            assert_param(IS_LCD_PULSE_DURATION(LCD_PulseOnDuration));
    339          
    340            LCD->CR2 &= (uint8_t)(~LCD_CR2_PON); /* Clear the pulses on duration bits */
   \   000002 C6 5401      LD        A, L:0x5401
   \   000005 A4 1F        AND       A, #0x1f
   \   000007 C7 5401      LD        L:0x5401, A
    341            LCD->CR2 |= LCD_PulseOnDuration;
   \   00000A B6 ..        LD        A, S:?b0
   \   00000C CA 5401      OR        A, L:0x5401
   \   00000F C7 5401      LD        L:0x5401, A
    342          }
   \   000012 87           RETF
    343          
    344          /**
    345            * @brief  Configures the LCD dead time.
    346            * @param  LCD_DeadTime: specifies the LCD dead time.
    347            *          This parameter can be one of the following values:
    348            *            @arg LCD_DeadTime_0: No dead Time
    349            *            @arg LCD_DeadTime_1: One Phase between different couple of Frame
    350            *            @arg LCD_DeadTime_2: Two Phase between different couple of Frame
    351            *            @arg LCD_DeadTime_3: Three Phase between different couple of Frame
    352            *            @arg LCD_DeadTime_4: Four Phase between different couple of Frame
    353            *            @arg LCD_DeadTime_5: Five Phase between different couple of Frame
    354            *            @arg LCD_DeadTime_6: Six Phase between different couple of Frame 
    355            *            @arg LCD_DeadTime_7: Seven Phase between different couple of Frame
    356            * @retval None
    357            */

   \                                 In section .far_func.text, align 1
    358          void LCD_DeadTimeConfig(LCD_DeadTime_TypeDef LCD_DeadTime)
    359          {
   \                     LCD_DeadTimeConfig:
   \   000000 B7 ..        LD        S:?b0, A
    360            /* Check function parameters */
    361            assert_param(IS_LCD_DEAD_TIME(LCD_DeadTime));
    362          
    363            LCD->CR3 &= (uint8_t)(~LCD_CR3_DEAD);  /* Clear the dead time bits  */
   \   000002 C6 5402      LD        A, L:0x5402
   \   000005 A4 F8        AND       A, #0xf8
   \   000007 C7 5402      LD        L:0x5402, A
    364          
    365            LCD->CR3 |= LCD_DeadTime;
   \   00000A B6 ..        LD        A, S:?b0
   \   00000C CA 5402      OR        A, L:0x5402
   \   00000F C7 5402      LD        L:0x5402, A
    366          
    367          }
   \   000012 87           RETF
    368          
    369          /**
    370            * @brief  Configures the LCD Blink mode and Blink frequency.
    371            * @param  LCD_BlinkMode: specifies the LCD blink mode.
    372            *          This parameter can be one of the following values:
    373            *            @arg LCD_BlinkMode_Off:           Blink disabled
    374            *            @arg LCD_BlinkMode_SEG0_COM0:     Blink enabled on SEG[0], COM[0] (1 pixel)
    375            *            @arg LCD_BlinkMode_SEG0_AllCOM:   Blink enabled on SEG[0], all COM (up to 8 
    376            *                                       pixels according to the programmed duty)
    377            *            @arg LCD_BlinkMode_AllSEG_AllCOM: Blink enabled on all SEG and all COM 
    378            *                                       (all pixels)
    379            * @param  LCD_BlinkFrequency: specifies the LCD blink frequency.
    380            *          This parameter can be one of the following values:
    381            *            @arg LCD_BlinkFrequency_Div8:    The Blink frequency = fLcd/8
    382            *            @arg LCD_BlinkFrequency_Div16:   The Blink frequency = fLcd/16
    383            *            @arg LCD_BlinkFrequency_Div32:   The Blink frequency = fLcd/32
    384            *            @arg LCD_BlinkFrequency_Div64:   The Blink frequency = fLcd/64 
    385            *            @arg LCD_BlinkFrequency_Div128:  The Blink frequency = fLcd/128
    386            *            @arg LCD_BlinkFrequency_Div256:  The Blink frequency = fLcd/256
    387            *            @arg LCD_BlinkFrequency_Div512:  The Blink frequency = fLcd/512
    388            *            @arg LCD_BlinkFrequency_Div1024: The Blink frequency = fLcd/1024
    389            * @retval None
    390            */

   \                                 In section .far_func.text, align 1
    391          void LCD_BlinkConfig(LCD_BlinkMode_TypeDef LCD_BlinkMode, LCD_BlinkFrequency_TypeDef LCD_BlinkFrequency)
    392          {
   \                     LCD_BlinkConfig:
   \   000000 B7 ..        LD        S:?b1, A
    393            /* Check function parameters */
    394            assert_param(IS_LCD_BLINK_MODE(LCD_BlinkMode));
    395            assert_param(IS_LCD_BLINK_FREQUENCY(LCD_BlinkFrequency));
    396          
    397            LCD->CR1 &= (uint8_t)(~LCD_CR1_BLINK); /* Clear the blink mode bits */
   \   000002 C6 5400      LD        A, L:0x5400
   \   000005 A4 3F        AND       A, #0x3f
   \   000007 C7 5400      LD        L:0x5400, A
    398            LCD->CR1 |= LCD_BlinkMode; /* Config the LCD Blink Mode */
   \   00000A B6 ..        LD        A, S:?b1
   \   00000C CA 5400      OR        A, L:0x5400
   \   00000F C7 5400      LD        L:0x5400, A
    399          
    400            LCD->CR1 &= (uint8_t)(~LCD_CR1_BLINKF); /* Clear the blink frequency bits */
   \   000012 C6 5400      LD        A, L:0x5400
   \   000015 A4 C7        AND       A, #0xc7
   \   000017 C7 5400      LD        L:0x5400, A
    401            LCD->CR1 |= LCD_BlinkFrequency; /* Config the LCD Blink Frequency */
   \   00001A B6 ..        LD        A, S:?b0
   \   00001C CA 5400      OR        A, L:0x5400
   \   00001F C7 5400      LD        L:0x5400, A
    402          
    403          }
   \   000022 87           RETF
    404          
    405          /**
    406            * @brief  Configures the LCD Contrast.
    407            * @param  LCD_Contrast: specifies the LCD Contrast.
    408            *          This parameter can be one of the following values:
    409            *            @arg LCD_Contrast_Level_0: Medium Density / High Density Maximum Voltage = 2.60V / 2.60V 
    410            *            @arg LCD_Contrast_Level_1: Medium Density / High Density Maximum Voltage = 2.70V / 2.73V
    411            *            @arg LCD_Contrast_Level_2: Medium Density / High Density Maximum Voltage = 2.80V / 2.86V
    412            *            @arg LCD_Contrast_Level_3: Medium Density / High Density Maximum Voltage = 2.90V / 2.99V
    413            *            @arg LCD_Contrast_Level_4: Medium Density / High Density Maximum Voltage = 3.00V / 3.12V
    414            *            @arg LCD_Contrast_Level_5: Medium Density / High Density Maximum Voltage = 3.10V / 3.25V
    415            *            @arg LCD_Contrast_Level_6: Medium Density / High Density Maximum Voltage = 3.20V / 3.38V
    416            *            @arg LCD_Contrast_Level_7: Medium Density / High Density Maximum Voltage = 3.30V / 3.51V
    417            * @retval None
    418            */

   \                                 In section .far_func.text, align 1
    419          void LCD_ContrastConfig(LCD_Contrast_TypeDef LCD_Contrast)
    420          {
   \                     LCD_ContrastConfig:
   \   000000 B7 ..        LD        S:?b0, A
    421            /* Check function parameters */
    422            assert_param(IS_LCD_CONTRAST(LCD_Contrast));
    423          
    424            LCD->CR2 &= (uint8_t)(~LCD_CR2_CC); /* Clear the contrast bits  */
   \   000002 C6 5401      LD        A, L:0x5401
   \   000005 A4 F1        AND       A, #0xf1
   \   000007 C7 5401      LD        L:0x5401, A
    425            LCD->CR2 |= LCD_Contrast; /* Select the maximum voltage value Vlcd */
   \   00000A B6 ..        LD        A, S:?b0
   \   00000C CA 5401      OR        A, L:0x5401
   \   00000F C7 5401      LD        L:0x5401, A
    426          
    427          }
   \   000012 87           RETF
    428          
    429          /**
    430            * @}
    431            */
    432          
    433          /** @defgroup LCD_Group2  LCD RAM memory write functions
    434           *  @brief    LCD RAM memory write functions 
    435           *
    436          @verbatim   
    437           ===============================================================================
    438                                     LCD RAM memory write functions
    439           ===============================================================================  
    440          
    441          @endverbatim
    442            * @{
    443            */
    444          
    445          /**
    446            * @brief  Writes a word in the specific LCD RAM.
    447            * @param  LCD_RAMRegister: specifies the LCD Contrast.
    448            *          This parameter can be one of the following values:
    449            *            @arg LCD_RAMRegister_0: LCD RAM Register 0
    450            *            @arg LCD_RAMRegister_1: LCD RAM Register 1
    451            *            @arg LCD_RAMRegister_2: LCD RAM Register 2
    452            *            @arg LCD_RAMRegister_3: LCD RAM Register 3
    453            *            @arg LCD_RAMRegister_4: LCD RAM Register 4
    454            *            @arg LCD_RAMRegister_5: LCD RAM Register 5
    455            *            @arg LCD_RAMRegister_6: LCD RAM Register 6 
    456            *            @arg LCD_RAMRegister_7: LCD RAM Register 7  
    457            *            @arg LCD_RAMRegister_8: LCD RAM Register 8
    458            *            @arg LCD_RAMRegister_9: LCD RAM Register 9
    459            *            @arg LCD_RAMRegister_10: LCD RAM Register 10
    460            *            @arg LCD_RAMRegister_11: LCD RAM Register 11
    461            *            @arg LCD_RAMRegister_12: LCD RAM Register 12 
    462            *            @arg LCD_RAMRegister_13: LCD RAM Register 13 
    463            *            @arg LCD_RAMRegister_14: LCD RAM Register 14 
    464            *            @arg LCD_RAMRegister_15: LCD RAM Register 15
    465            *            @arg LCD_RAMRegister_15: LCD RAM Register 16 
    466            *            @arg LCD_RAMRegister_15: LCD RAM Register 17 
    467            *            @arg LCD_RAMRegister_15: LCD RAM Register 18 
    468            *            @arg LCD_RAMRegister_15: LCD RAM Register 19 
    469            *            @arg LCD_RAMRegister_15: LCD RAM Register 20 
    470            *            @arg LCD_RAMRegister_15: LCD RAM Register 21             
    471            * @param  LCD_Data: specifies LCD Data Value to be written.
    472            * @retval None
    473            */

   \                                 In section .far_func.text, align 1
    474          void LCD_WriteRAM(LCD_RAMRegister_TypeDef LCD_RAMRegister, uint8_t LCD_Data)
    475          {
    476            /* Check function parameters */
    477            assert_param(IS_LCD_RAM_REGISTER(LCD_RAMRegister));
    478          
    479            /* Copy data bytes to RAM register */
    480            LCD->RAM[LCD_RAMRegister] =  LCD_Data;
   \                     LCD_WriteRAM:
   \   000000 5F           CLRW      X
   \   000001 97           LD        XL, A
   \   000002 1C 540C      ADDW      X, #0x540c
   \   000005 B6 ..        LD        A, S:?b0
   \   000007 F7           LD        (X), A
    481          
    482          }
   \   000008 87           RETF
    483          
    484          /**
    485            * @brief  Select the LCD page where the data will be written.
    486            * @param  LCD_Page: The accessed LCD page.
    487            *          This parameter can be one of the following values:
    488            *            @arg LCD_PageSelection_FirstPage: The LCD RAM is selected as the first page
    489            *            @arg LCD_PageSelection_SecondPage: The LCD RAM is selected as the second page  
    490            * @retval None
    491            */

   \                                 In section .far_func.text, align 1
    492          void LCD_PageSelect(LCD_PageSelection_TypeDef LCD_PageSelection)
    493          {
    494            /* Check function parameters */
    495            assert_param(IS_LCD_PAGE_SELECT(LCD_PageSelection));
    496          
    497            LCD->CR4 &= (uint8_t)(~LCD_CR4_PAGECOM); /* Clear the PAGE COM bit */
   \                     LCD_PageSelect:
   \   000000 7215 542F    BRES      L:0x542f, #0x2
    498            LCD->CR4 |= LCD_PageSelection; /* Select the LCD page */
   \   000004 CA 542F      OR        A, L:0x542f
   \   000007 C7 542F      LD        L:0x542f, A
    499          
    500          }
   \   00000A 87           RETF
    501          
    502          /**
    503            * @}
    504            */
    505          
    506          /** @defgroup LCD_Group3 Interrupts and flags management functions
    507           *  @brief   Interrupts and flags management functions 
    508           *
    509          @verbatim   
    510           ===============================================================================
    511                             Interrupts and flags management functions
    512           ===============================================================================  
    513          
    514          @endverbatim
    515            * @{
    516            */
    517            
    518            
    519          /**
    520            * @brief  Enables or disables the start of frame interrupt.
    521            * @param NewState: new state of the specified LCD interrupts.
    522            *          This parameter can be: ENABLE or DISABLE.
    523            * @retval None
    524            */

   \                                 In section .far_func.text, align 1
    525          void LCD_ITConfig(FunctionalState NewState)
    526          {
    527            /* Check function parameters */
    528            assert_param(IS_FUNCTIONAL_STATE(NewState));
    529          
    530            if (NewState != DISABLE)
   \                     LCD_ITConfig:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??LCD_ITConfig_0
    531            {
    532              LCD->CR3 |= LCD_CR3_SOFIE; /* Enable interrupt*/
   \   000003 721A 5402    BSET      L:0x5402, #0x5
   \   000007 87           RETF
    533            }
    534            else
    535            {
    536              LCD->CR3 &= (uint8_t)(~LCD_CR3_SOFIE); /* Disable interrupt*/
   \                     ??LCD_ITConfig_0:
   \   000008 721B 5402    BRES      L:0x5402, #0x5
    537            }
    538          
    539          }
   \   00000C 87           RETF
    540          
    541          /**
    542            * @brief  Checks whether the LCD start of new frame flag is set or not.
    543            * @retval The new state of the start of new frame flag.
    544            *   This returned value can be: SET or RESET.   
    545            */

   \                                 In section .far_func.text, align 1
    546          FlagStatus LCD_GetFlagStatus(void)
    547          {
    548            FlagStatus status = RESET;
   \                     LCD_GetFlagStatus:
   \   000000 4F           CLR       A
    549          
    550            /* Check the status of the start of new frame LCD flag */
    551            if ((LCD->CR3 & (uint8_t)LCD_CR3_SOF) != (uint8_t)RESET)
   \   000001 7209 5402 03 BTJF      L:0x5402, #0x4, L:??LCD_GetFlagStatus_0
    552            {
    553              status = SET; /* Flag is set */
   \   000006 A6 01        LD        A, #0x1
   \   000008 87           RETF
    554            }
    555            else
    556            {
    557              status = RESET; /* Flag is reset*/
   \                     ??LCD_GetFlagStatus_0:
   \   000009 4F           CLR       A
    558            }
    559            /* Return the FLAG status */
    560            return status;
   \   00000A 87           RETF
    561          
    562          }
    563          
    564          /**
    565            * @brief  Clears the start of frame LCD flag.
    566            * @param  None
    567            * @retval None
    568            */

   \                                 In section .far_func.text, align 1
    569          void LCD_ClearFlag(void)
    570          {
    571            /* Clear the flag bit */
    572            LCD->CR3 |= (uint8_t)(LCD_CR3_SOFC);
   \                     LCD_ClearFlag:
   \   000000 7216 5402    BSET      L:0x5402, #0x3
    573          
    574          }
   \   000004 87           RETF
    575          
    576          /**
    577            * @brief  Checks whether the start of frame interrupt has occurred or not.
    578            * @param  None
    579            * @retval The new state of the start of new frame interrupt.
    580            *   This returned value can be: SET or RESET.   
    581            */

   \                                 In section .far_func.text, align 1
    582          ITStatus LCD_GetITStatus(void)
    583          {
    584            ITStatus pendingbitstatus = RESET;
   \                     LCD_GetITStatus:
   \   000000 3F ..        CLR       S:?b0
    585            uint8_t enablestatus = 0;
   \   000002 3F ..        CLR       S:?b1
    586          
    587            enablestatus = (uint8_t)((uint8_t)LCD->CR3 & LCD_CR3_SOFIE);
   \   000004 C6 5402      LD        A, L:0x5402
   \   000007 A4 20        AND       A, #0x20
   \   000009 B7 ..        LD        S:?b1, A
    588            /* Check the status of the start of frame interrupt */
    589            if (((LCD->CR3 & LCD_CR3_SOF) != RESET) && enablestatus)
   \   00000B 7209 5402 0A BTJF      L:0x5402, #0x4, L:??LCD_GetITStatus_0
   \   000010 3D ..        TNZ       S:?b1
   \   000012 27 06        JREQ      L:??LCD_GetITStatus_0
    590            {
    591              /* ITPENDINGBIT is set */
    592              pendingbitstatus = SET;
   \   000014 35 01 ....   MOV       S:?b0, #0x1
   \   000018 20 02        JRA       L:??LCD_GetITStatus_1
    593            }
    594            else
    595            {
    596              /* ITPENDINGBIT is reset */
    597              pendingbitstatus = RESET;
   \                     ??LCD_GetITStatus_0:
   \   00001A 3F ..        CLR       S:?b0
    598            }
    599            /* Return the ITPENDINGBIT status */
    600            return  pendingbitstatus;
   \                     ??LCD_GetITStatus_1:
   \   00001C B6 ..        LD        A, S:?b0
   \   00001E 87           RETF
    601          
    602          }
    603          
    604          /**
    605            * @brief  Clears the start of frame interrupt pending bits.
    606            * @param  None
    607            * @retval None
    608            */

   \                                 In section .far_func.text, align 1
    609          void LCD_ClearITPendingBit(void)
    610          {
    611            /* Clear the flag bit */
    612            LCD->CR3 |= (uint8_t)(LCD_CR3_SOFC);
   \                     LCD_ClearITPendingBit:
   \   000000 7216 5402    BSET      L:0x5402, #0x3
    613          
    614          }
   \   000004 87           RETF
    615          
    616          /**
    617            * @}
    618            */
    619          
    620          /**
    621            * @}
    622            */
    623          
    624          /**
    625            * @}
    626            */
    627          
    628          /**
    629            * @}
    630            */
    631          
    632          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Section sizes:

   Bytes  Function/Label
   -----  --------------
      35  LCD_BlinkConfig
       5  LCD_ClearFlag
       5  LCD_ClearITPendingBit
      13  LCD_Cmd
      19  LCD_ContrastConfig
      76  LCD_DeInit
      19  LCD_DeadTimeConfig
      11  LCD_GetFlagStatus
      31  LCD_GetITStatus
      13  LCD_HighDriveCmd
      13  LCD_ITConfig
     135  LCD_Init
      11  LCD_PageSelect
       9  LCD_PortMaskConfig
      19  LCD_PulseOnDurationConfig
       9  LCD_WriteRAM

 
 423 bytes in section .far_func.text
 
 423 bytes of CODE memory

Errors: none
Warnings: none
