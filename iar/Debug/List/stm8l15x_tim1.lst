###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.42.1.142 for STM8               01/Jul/2016  17:30:49 #
# Copyright 2010-2013 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  E:\hwpro-2016\20160627_L\stm8l15x_lib\src\stm8l15x_tim1. #
#                    c                                                        #
#    Command line =  E:\hwpro-2016\20160627_L\stm8l15x_lib\src\stm8l15x_tim1. #
#                    c -e -Ol --no_cse --no_unroll --no_inline                #
#                    --no_code_motion --no_tbaa --no_cross_call --debug       #
#                    --code_model medium --data_model medium -o               #
#                    E:\hwpro-2016\20160627_L\iar\Debug\Obj\ --dlib_config    #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.5\stm8\LIB\dlstm8mmn.h" -D STM8L15X_MD -lC             #
#                    E:\hwpro-2016\20160627_L\iar\Debug\List\ -I              #
#                    E:\hwpro-2016\20160627_L\iar\..\stm8l15x_lib\inc\ -I     #
#                    E:\hwpro-2016\20160627_L\iar\..\user\inc\ -I             #
#                    E:\hwpro-2016\20160627_L\iar\..\utils\xprintf\ -I        #
#                    E:\hwpro-2016\20160627_L\iar\..\drivers\ -I              #
#                    E:\hwpro-2016\20160627_L\iar\..\utils\ -I                #
#                    E:\hwpro-2016\20160627_L\iar\..\app\ --vregs 16          #
#    List file    =  E:\hwpro-2016\20160627_L\iar\Debug\List\stm8l15x_tim1.ls #
#                    t                                                        #
#    Object file  =  E:\hwpro-2016\20160627_L\iar\Debug\Obj\stm8l15x_tim1.o   #
#                                                                             #
#                                                                             #
###############################################################################

E:\hwpro-2016\20160627_L\stm8l15x_lib\src\stm8l15x_tim1.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm8l15x_tim1.c
      4            * @author  MCD Application Team
      5            * @version V1.6.1
      6            * @date    30-September-2014
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the TIM1 peripheral:
      9            *            - TimeBase management
     10            *            - Output Compare management
     11            *            - Input Capture management
     12            *            - Interrupts, DMA and flags management
     13            *            - Clocks management
     14            *            - Synchronization management
     15            *            - Specific interface management
     16            *              
     17            *  @verbatim
     18            *  
     19            *          ===================================================================
     20            *                                 How to use this driver
     21            *          ===================================================================
     22            *          This driver provides functions to configure and initialize the TIM1 
     23            *          peripheral
     24            *          These functions are split in 7 groups: 
     25            *   
     26            *          1. TIM1 TimeBase management: this group includes all needed functions 
     27            *             to configure the TIM Timebase unit:
     28            *                   - Set/Get Prescaler
     29            *                   - Set/Get Autoreload  
     30            *                   - Counter modes configuration
     31            *                   - Select the One Pulse mode
     32            *                   - Update Request Configuration
     33            *                   - Update Disable Configuration
     34            *                   - Auto-Preload Configuration 
     35            *                   - Enable/Disable the counter
     36            *                 
     37            *          2. TIM1 Output Compare management: this group includes all needed 
     38            *             functions to configure the Capture/Compare unit used in Output 
     39            *             compare mode: 
     40            *                   - Configure each channel, independently, in Output Compare mode
     41            *                   - Select the output compare modes
     42            *                   - Select the Polarities of each channel
     43            *                   - Set/Get the Capture/Compare register values
     44            *                   - Select the Output Compare Fast mode 
     45            *                   - Select the Output Compare Forced mode  
     46            *                   - Output Compare-Preload Configuration 
     47            *                   - Clear Output Compare Reference
     48            *                   - Select the OCREF Clear signal
     49            *                   - Enable/Disable the Capture/Compare Channels    
     50            *                   
     51            *          3. TIM1 Input Capture management: this group includes all needed 
     52            *             functions to configure the Capture/Compare unit used in 
     53            *             Input Capture mode:
     54            *                   - Configure each channel in input capture mode
     55            *                   - Configure Channel1/2 in PWM Input mode
     56            *                   - Set the Input Capture Prescaler
     57            *                   - Get the Capture/Compare values      
     58            *        
     59            *          4. TIM1 interrupts, DMA and flags management
     60            *                   - Enable/Disable interrupt sources
     61            *                   - Get flags status
     62            *                   - Clear flags/ Pending bits
     63            *                   - Enable/Disable DMA requests 
     64            *                   - Configure DMA burst mode
     65            *                   - Select CaptureCompare DMA request  
     66            *              
     67            *          5. TIM1 clocks management: this group includes all needed functions 
     68            *             to configure the clock controller unit:
     69            *                   - Select internal/External clock
     70            *                   - Select the external clock mode: ETR(Mode1/Mode2) or TIx
     71            *         
     72            *          6. TIM1 synchronization management: this group includes all needed 
     73            *             functions to configure the Synchronization unit:
     74            *                   - Select Input Trigger  
     75            *                   - Select Output Trigger  
     76            *                   - Select Master Slave Mode 
     77            *                   - ETR Configuration when used as external trigger   
     78            *     
     79            *          7. TIM1 specific interface management, this group includes all 
     80            *             needed functions to use the specific TIM1 interface:
     81            *                   - Encoder Interface Configuration
     82            *                   - Select Hall Sensor        
     83            *   
     84            *  @endverbatim
     85            *    
     86            ******************************************************************************
     87            * @attention
     88            *
     89            * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
     90            *
     91            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     92            * You may not use this file except in compliance with the License.
     93            * You may obtain a copy of the License at:
     94            *
     95            *        http://www.st.com/software_license_agreement_liberty_v2
     96            *
     97            * Unless required by applicable law or agreed to in writing, software 
     98            * distributed under the License is distributed on an "AS IS" BASIS, 
     99            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    100            * See the License for the specific language governing permissions and
    101            * limitations under the License.
    102            *
    103            ******************************************************************************
    104            */
    105          
    106          /* Includes ------------------------------------------------------------------*/
    107          #include "stm8l15x_tim1.h"
    108          
    109          /** @addtogroup STM8L15x_StdPeriph_Driver
    110            * @{
    111            */
    112          
    113          /** @defgroup TIM1
    114            * @brief TIM1 driver modules
    115            * @{
    116            */
    117            
    118          /* Private typedef -----------------------------------------------------------*/
    119          /* Private define ------------------------------------------------------------*/
    120          /* Private macro -------------------------------------------------------------*/
    121          /* Private variables ---------------------------------------------------------*/
    122          /* Private function prototypes -----------------------------------------------*/
    123          /** @defgroup TIM1_Private_Functions_Prototypes
    124            * @{
    125            */
    126          
    127          static void TI1_Config(uint8_t TIM1_ICPolarity, uint8_t TIM1_ICSelection,
    128                                 uint8_t TIM1_ICFilter);
    129          static void TI2_Config(uint8_t TIM1_ICPolarity, uint8_t TIM1_ICSelection,
    130                                 uint8_t TIM1_ICFilter);
    131          static void TI3_Config(uint8_t TIM1_ICPolarity, uint8_t TIM1_ICSelection,
    132                                 uint8_t TIM1_ICFilter);
    133          static void TI4_Config(uint8_t TIM1_ICPolarity, uint8_t TIM1_ICSelection,
    134                                 uint8_t TIM1_ICFilter);
    135          
    136          /**
    137            * @}
    138            */
    139          
    140          /* Private functions ---------------------------------------------------------*/  
    141          /** @defgroup TIM1_Private_Functions
    142            * @{
    143            */
    144          
    145          /** @defgroup TIM1_Group1 TimeBase management functions
    146           *  @brief   TimeBase management functions 
    147           *
    148          @verbatim   
    149           ===============================================================================
    150                                 TimeBase management functions
    151           ===============================================================================  
    152            
    153                 ===================================================================      
    154                        TIM1 Driver: how to use it in Timing(Time base) Mode
    155                 =================================================================== 
    156                 To use the Timer in Timing(Time base) mode, the following steps are mandatory:
    157                 
    158                 1. Enable TIM1 clock using CLK_PeripheralClockConfig(CLK_Peripheral_TIM1, ENABLE) function.
    159                  
    160                 2. Call TIM1_TimeBaseInit() to configure the Time Base unit with the
    161                    corresponding configuration.
    162                    
    163                 3. Enable global interrupts if you need to generate the update interrupt.
    164                    
    165                 4. Enable the corresponding interrupt using the function TIM1_ITConfig(TIM1_IT_Update) 
    166                    
    167                 5. Call the TIM1_Cmd(ENABLE) function to enable the TIM1 counter.
    168                 
    169                 Note1: All other functions can be used separately to modify, if needed,
    170                    a specific feature of the Timer. 
    171          
    172          @endverbatim
    173            * @{
    174            */
    175          
    176          /**
    177            * @brief  Deinitializes the TIM1 peripheral registers to their default reset values.
    178            * @param  None
    179            * @retval None
    180            */

   \                                 In section .far_func.text, align 1
    181          void TIM1_DeInit(void)
    182          {
    183            TIM1->CR1  = TIM1_CR1_RESET_VALUE;
   \                     TIM1_DeInit:
   \   000000 35 00 52B0   MOV       L:0x52b0, #0x0
    184            TIM1->CR2  = TIM1_CR2_RESET_VALUE;
   \   000004 35 00 52B1   MOV       L:0x52b1, #0x0
    185            TIM1->SMCR = TIM1_SMCR_RESET_VALUE;
   \   000008 35 00 52B2   MOV       L:0x52b2, #0x0
    186            TIM1->ETR  = TIM1_ETR_RESET_VALUE;
   \   00000C 35 00 52B3   MOV       L:0x52b3, #0x0
    187            TIM1->IER  = TIM1_IER_RESET_VALUE;
   \   000010 35 00 52B5   MOV       L:0x52b5, #0x0
    188          
    189            /* Disable channels */
    190            TIM1->CCER1 = TIM1_CCER1_RESET_VALUE;
   \   000014 35 00 52BD   MOV       L:0x52bd, #0x0
    191            TIM1->CCER2 = TIM1_CCER2_RESET_VALUE;
   \   000018 35 00 52BE   MOV       L:0x52be, #0x0
    192            /* Configure channels as inputs: it is necessary if lock level is equal to 2 or 3 */
    193            TIM1->CCMR1 = 0x01;
   \   00001C 35 01 52B9   MOV       L:0x52b9, #0x1
    194            TIM1->CCMR2 = 0x01;
   \   000020 35 01 52BA   MOV       L:0x52ba, #0x1
    195            TIM1->CCMR3 = 0x01;
   \   000024 35 01 52BB   MOV       L:0x52bb, #0x1
    196            TIM1->CCMR4 = 0x01;
   \   000028 35 01 52BC   MOV       L:0x52bc, #0x1
    197            /* Then reset channel registers: it also works if lock level is equal to 2 or 3 */
    198            TIM1->CCER1 = TIM1_CCER1_RESET_VALUE;
   \   00002C 35 00 52BD   MOV       L:0x52bd, #0x0
    199            TIM1->CCER2 = TIM1_CCER2_RESET_VALUE;
   \   000030 35 00 52BE   MOV       L:0x52be, #0x0
    200            TIM1->CCMR1 = TIM1_CCMR1_RESET_VALUE;
   \   000034 35 00 52B9   MOV       L:0x52b9, #0x0
    201            TIM1->CCMR2 = TIM1_CCMR2_RESET_VALUE;
   \   000038 35 00 52BA   MOV       L:0x52ba, #0x0
    202            TIM1->CCMR3 = TIM1_CCMR3_RESET_VALUE;
   \   00003C 35 00 52BB   MOV       L:0x52bb, #0x0
    203            TIM1->CCMR4 = TIM1_CCMR4_RESET_VALUE;
   \   000040 35 00 52BC   MOV       L:0x52bc, #0x0
    204            TIM1->CNTRH = TIM1_CNTRH_RESET_VALUE;
   \   000044 35 00 52BF   MOV       L:0x52bf, #0x0
    205            TIM1->CNTRL = TIM1_CNTRL_RESET_VALUE;
   \   000048 35 00 52C0   MOV       L:0x52c0, #0x0
    206            TIM1->PSCRH = TIM1_PSCRH_RESET_VALUE;
   \   00004C 35 00 52C1   MOV       L:0x52c1, #0x0
    207            TIM1->PSCRL = TIM1_PSCRL_RESET_VALUE;
   \   000050 35 00 52C2   MOV       L:0x52c2, #0x0
    208            TIM1->ARRH  = TIM1_ARRH_RESET_VALUE;
   \   000054 35 FF 52C3   MOV       L:0x52c3, #0xff
    209            TIM1->ARRL  = TIM1_ARRL_RESET_VALUE;
   \   000058 35 FF 52C4   MOV       L:0x52c4, #0xff
    210            TIM1->CCR1H = TIM1_CCR1H_RESET_VALUE;
   \   00005C 35 00 52C6   MOV       L:0x52c6, #0x0
    211            TIM1->CCR1L = TIM1_CCR1L_RESET_VALUE;
   \   000060 35 00 52C7   MOV       L:0x52c7, #0x0
    212            TIM1->CCR2H = TIM1_CCR2H_RESET_VALUE;
   \   000064 35 00 52C8   MOV       L:0x52c8, #0x0
    213            TIM1->CCR2L = TIM1_CCR2L_RESET_VALUE;
   \   000068 35 00 52C9   MOV       L:0x52c9, #0x0
    214            TIM1->CCR3H = TIM1_CCR3H_RESET_VALUE;
   \   00006C 35 00 52CA   MOV       L:0x52ca, #0x0
    215            TIM1->CCR3L = TIM1_CCR3L_RESET_VALUE;
   \   000070 35 00 52CB   MOV       L:0x52cb, #0x0
    216            TIM1->CCR4H = TIM1_CCR4H_RESET_VALUE;
   \   000074 35 00 52CC   MOV       L:0x52cc, #0x0
    217            TIM1->CCR4L = TIM1_CCR4L_RESET_VALUE;
   \   000078 35 00 52CD   MOV       L:0x52cd, #0x0
    218            TIM1->OISR  = TIM1_OISR_RESET_VALUE;
   \   00007C 35 00 52D0   MOV       L:0x52d0, #0x0
    219            TIM1->EGR   = 0x01; /* TIM1_EGR_UG */
   \   000080 35 01 52B8   MOV       L:0x52b8, #0x1
    220            TIM1->DTR   = TIM1_DTR_RESET_VALUE;
   \   000084 35 00 52CF   MOV       L:0x52cf, #0x0
    221            TIM1->BKR   = TIM1_BKR_RESET_VALUE;
   \   000088 35 00 52CE   MOV       L:0x52ce, #0x0
    222            TIM1->RCR   = TIM1_RCR_RESET_VALUE;
   \   00008C 35 00 52C5   MOV       L:0x52c5, #0x0
    223            TIM1->SR1   = TIM1_SR1_RESET_VALUE;
   \   000090 35 00 52B6   MOV       L:0x52b6, #0x0
    224            TIM1->SR2   = TIM1_SR2_RESET_VALUE;
   \   000094 35 00 52B7   MOV       L:0x52b7, #0x0
    225          }
   \   000098 87           RETF
    226          
    227          /**
    228            * @brief  Initializes the TIM1 Time Base Unit according to the specified parameters.
    229            * @param  TIM1_Prescaler specifies the Prescaler value.
    230            * @param  TIM1_CounterMode specifies the counter mode from
    231            *          This parameter can be one of the following values:
    232            *            @arg TIM1_CounterMode_Up: Counter mode Up
    233            *            @arg TIM1_CounterMode_Down: Counter mode Down
    234            *            @arg TIM1_CounterMode_CenterAligned1: Counter mode center aligned
    235            *            @arg TIM1_CounterMode_CenterAligned2: Counter mode center aligned
    236            *            @arg TIM1_CounterMode_CenterAligned3: Counter mode center aligned
    237            * @param  TIM1_Period specifies the Period value.
    238            * @param  TIM1_RepetitionCounter specifies the Repetition counter value
    239            * @retval None
    240            */

   \                                 In section .far_func.text, align 1
    241          void TIM1_TimeBaseInit(uint16_t TIM1_Prescaler,
    242                                 TIM1_CounterMode_TypeDef TIM1_CounterMode,
    243                                 uint16_t TIM1_Period,
    244                                 uint8_t TIM1_RepetitionCounter)
    245          {
   \                     TIM1_TimeBaseInit:
   \   000000 BF ..        LDW       S:?w1, X
   \   000002 B7 ..        LD        S:?b1, A
    246            /* Check parameters */
    247            assert_param(IS_TIM1_COUNTER_MODE(TIM1_CounterMode));
    248          
    249          
    250            /* Set the Autoreload value */
    251            TIM1->ARRH = (uint8_t)(TIM1_Period >> 8);
   \   000004 93           LDW       X, Y
   \   000005 4F           CLR       A
   \   000006 01           RRWA      X, A
   \   000007 9F           LD        A, XL
   \   000008 C7 52C3      LD        L:0x52c3, A
    252            TIM1->ARRL = (uint8_t)(TIM1_Period);
   \   00000B 909F         LD        A, YL
   \   00000D C7 52C4      LD        L:0x52c4, A
    253          
    254            /* Set the Prescaler value */
    255            TIM1->PSCRH = (uint8_t)(TIM1_Prescaler >> 8);
   \   000010 BE ..        LDW       X, S:?w1
   \   000012 4F           CLR       A
   \   000013 01           RRWA      X, A
   \   000014 9F           LD        A, XL
   \   000015 C7 52C1      LD        L:0x52c1, A
    256            TIM1->PSCRL = (uint8_t)(TIM1_Prescaler);
   \   000018 B6 ..        LD        A, S:?b3
   \   00001A C7 52C2      LD        L:0x52c2, A
    257          
    258            /* Select the Counter Mode */
    259            TIM1->CR1 = (uint8_t)((uint8_t)(TIM1->CR1 & (uint8_t)(~(TIM1_CR1_CMS | TIM1_CR1_DIR)))
    260                                  | (uint8_t)(TIM1_CounterMode));
   \   00001D C6 52B0      LD        A, L:0x52b0
   \   000020 A4 8F        AND       A, #0x8f
   \   000022 BA ..        OR        A, S:?b1
   \   000024 C7 52B0      LD        L:0x52b0, A
    261          
    262            /* Set the Repetition Counter value */
    263            TIM1->RCR = TIM1_RepetitionCounter;
   \   000027 B6 ..        LD        A, S:?b0
   \   000029 C7 52C5      LD        L:0x52c5, A
    264          
    265          }
   \   00002C 87           RETF
    266          
    267          /**
    268            * @brief  Configures the TIM1 Prescaler.
    269            * @param  Prescaler specifies the Prescaler Register value
    270            *          This parameter must be a value between 0x0000 and 0xFFFF
    271            * @param  TIM1_PSCReloadMode specifies the TIM1 Prescaler Reload mode.
    272            *          This parameter can be one of the following values
    273            *            @arg TIM1_PSCReloadMode_Immediate: The Prescaler is loaded immediately.
    274            *            @arg TIM1_PSCReloadMode_Update: The Prescaler is loaded at the update
    275            *         event.
    276            * @retval None
    277            */
    278          

   \                                 In section .far_func.text, align 1
    279          void TIM1_PrescalerConfig(uint16_t Prescaler, TIM1_PSCReloadMode_TypeDef TIM1_PSCReloadMode)
    280          {
   \                     TIM1_PrescalerConfig:
   \   000000 9093         LDW       Y, X
   \   000002 B7 ..        LD        S:?b0, A
    281            /* Check the parameters */
    282            assert_param(IS_TIM1_PRESCALER_RELOAD(TIM1_PSCReloadMode));
    283          
    284            /* Set the Prescaler value */
    285            TIM1->PSCRH = (uint8_t)(Prescaler >> 8);
   \   000004 93           LDW       X, Y
   \   000005 4F           CLR       A
   \   000006 01           RRWA      X, A
   \   000007 9F           LD        A, XL
   \   000008 C7 52C1      LD        L:0x52c1, A
    286            TIM1->PSCRL = (uint8_t)(Prescaler);
   \   00000B 909F         LD        A, YL
   \   00000D C7 52C2      LD        L:0x52c2, A
    287          
    288            /* Set or reset the UG Bit */
    289            TIM1->EGR = (uint8_t)TIM1_PSCReloadMode;
   \   000010 B6 ..        LD        A, S:?b0
   \   000012 C7 52B8      LD        L:0x52b8, A
    290          }
   \   000015 87           RETF
    291          
    292          /**
    293            * @brief  Specifies the TIM1 Counter Mode to be used.
    294            * @param  TIM1_CounterMode specifies the Counter Mode to be used
    295            *          This parameter can be one of the following values:
    296            *            @arg TIM1_CounterMode_Up: TIM1 Up Counting Mode
    297            *            @arg TIM1_CounterMode_Down: TIM1 Down Counting Mode
    298            *            @arg TIM1_CounterMode_CenterAligned1: TIM1 Center Aligned Mode1
    299            *            @arg TIM1_CounterMode_CenterAligned2: TIM1 Center Aligned Mode2
    300            *            @arg IM1_CounterMode_CenterAligned3: TIM1 Center Aligned Mode3
    301            * @retval None
    302            */

   \                                 In section .far_func.text, align 1
    303          void TIM1_CounterModeConfig(TIM1_CounterMode_TypeDef TIM1_CounterMode)
    304          {
   \                     TIM1_CounterModeConfig:
   \   000000 B7 ..        LD        S:?b0, A
    305            /* Check the parameters */
    306            assert_param(IS_TIM1_COUNTER_MODE(TIM1_CounterMode));
    307          
    308          
    309            /* Reset the CMS and DIR Bits & Set the Counter Mode */
    310            TIM1->CR1 = (uint8_t)((uint8_t)(TIM1->CR1 & (uint8_t)((uint8_t)(~TIM1_CR1_CMS) & (uint8_t)(~TIM1_CR1_DIR)))
    311                                  | (uint8_t)TIM1_CounterMode);
   \   000002 C6 52B0      LD        A, L:0x52b0
   \   000005 A4 8F        AND       A, #0x8f
   \   000007 BA ..        OR        A, S:?b0
   \   000009 C7 52B0      LD        L:0x52b0, A
    312          }
   \   00000C 87           RETF
    313          
    314          /**
    315            * @brief  Sets the TIM1 Counter Register value.
    316            * @param  Counter specifies the Counter register new value.
    317            *          This parameter is between 0x0000 and 0xFFFF.
    318            * @retval None
    319            */

   \                                 In section .far_func.text, align 1
    320          void TIM1_SetCounter(uint16_t Counter)
    321          {
   \                     TIM1_SetCounter:
   \   000000 9093         LDW       Y, X
    322            /* Set the Counter Register value */
    323            TIM1->CNTRH = (uint8_t)(Counter >> 8);
   \   000002 93           LDW       X, Y
   \   000003 4F           CLR       A
   \   000004 01           RRWA      X, A
   \   000005 9F           LD        A, XL
   \   000006 C7 52BF      LD        L:0x52bf, A
    324            TIM1->CNTRL = (uint8_t)(Counter);
   \   000009 909F         LD        A, YL
   \   00000B C7 52C0      LD        L:0x52c0, A
    325          }
   \   00000E 87           RETF
    326          
    327          /**
    328            * @brief  Sets the TIM1 Autoreload Register value.
    329            * @param  Autoreload specifies the Autoreload register new value.
    330            *          This parameter is between 0x0000 and 0xFFFF.
    331            * @retval None
    332            */

   \                                 In section .far_func.text, align 1
    333          void TIM1_SetAutoreload(uint16_t Autoreload)
    334          {
   \                     TIM1_SetAutoreload:
   \   000000 9093         LDW       Y, X
    335            /* Set the Autoreload Register value */
    336            TIM1->ARRH = (uint8_t)(Autoreload >> 8);
   \   000002 93           LDW       X, Y
   \   000003 4F           CLR       A
   \   000004 01           RRWA      X, A
   \   000005 9F           LD        A, XL
   \   000006 C7 52C3      LD        L:0x52c3, A
    337            TIM1->ARRL = (uint8_t)(Autoreload);
   \   000009 909F         LD        A, YL
   \   00000B C7 52C4      LD        L:0x52c4, A
    338          }
   \   00000E 87           RETF
    339          
    340          /**
    341            * @brief  Gets the TIM1 Counter value.
    342            * @param  None
    343            * @retval Counter Register value.
    344            */

   \                                 In section .far_func.text, align 1
    345          uint16_t TIM1_GetCounter(void)
    346          {
    347            /* Get the Counter Register value */
    348            uint16_t tmpcntr = 0;
   \                     TIM1_GetCounter:
   \   000000 905F         CLRW      Y
    349            uint8_t tmpcntrl = 0, tmpcntrh = 0;
   \   000002 3F ..        CLR       S:?b1
   \   000004 3F ..        CLR       S:?b0
    350          
    351            tmpcntrh = TIM1->CNTRH;
   \   000006 C6 52BF      LD        A, L:0x52bf
   \   000009 B7 ..        LD        S:?b0, A
    352            tmpcntrl = TIM1->CNTRL;
   \   00000B C6 52C0      LD        A, L:0x52c0
   \   00000E B7 ..        LD        S:?b1, A
    353          
    354            tmpcntr  = (uint16_t)(tmpcntrl);
   \   000010 5F           CLRW      X
   \   000011 41           EXG       A, XL
   \   000012 B6 ..        LD        A, S:?b1
   \   000014 41           EXG       A, XL
   \   000015 9093         LDW       Y, X
    355            tmpcntr |= (uint16_t)((uint16_t)tmpcntrh << 8);
   \   000017 5F           CLRW      X
   \   000018 41           EXG       A, XL
   \   000019 B6 ..        LD        A, S:?b0
   \   00001B 41           EXG       A, XL
   \   00001C 4F           CLR       A
   \   00001D 02           RLWA      X, A
   \   00001E BF ..        LDW       S:?w0, X
   \   000020 51           EXGW      X, Y
   \   000021 01           RRWA      X, A
   \   000022 BA ..        OR        A, S:?b1
   \   000024 01           RRWA      X, A
   \   000025 BA ..        OR        A, S:?b0
   \   000027 01           RRWA      X, A
   \   000028 51           EXGW      X, Y
    356          
    357            /* Get the Counter Register value */
    358            return (uint16_t)tmpcntr;
   \   000029 93           LDW       X, Y
   \   00002A 87           RETF
    359          }
    360          
    361          /**
    362            * @brief  Gets the TIM1 Prescaler value.
    363            * @param  None
    364            * @retval Prescaler Register value.
    365            */

   \                                 In section .far_func.text, align 1
    366          uint16_t TIM1_GetPrescaler(void)
    367          {
    368            uint16_t tmpreg = 0;
   \                     TIM1_GetPrescaler:
   \   000000 905F         CLRW      Y
    369            tmpreg = (uint16_t)((uint16_t)TIM1->PSCRH << 8);
   \   000002 C6 52C1      LD        A, L:0x52c1
   \   000005 5F           CLRW      X
   \   000006 97           LD        XL, A
   \   000007 4F           CLR       A
   \   000008 02           RLWA      X, A
   \   000009 9093         LDW       Y, X
    370            /* Get the Prescaler Register value */
    371            return (uint16_t)(tmpreg | TIM1->PSCRL);
   \   00000B C6 52C2      LD        A, L:0x52c2
   \   00000E 5F           CLRW      X
   \   00000F 97           LD        XL, A
   \   000010 BF ..        LDW       S:?w0, X
   \   000012 93           LDW       X, Y
   \   000013 01           RRWA      X, A
   \   000014 BA ..        OR        A, S:?b1
   \   000016 01           RRWA      X, A
   \   000017 BA ..        OR        A, S:?b0
   \   000019 01           RRWA      X, A
   \   00001A 87           RETF
    372          }
    373          
    374          /**
    375            * @brief  Enables or Disables the TIM1 Update event.
    376            * @param  NewState new state of the TIM1 peripheral Preload register.
    377            *          This parameter can be ENABLE or DISABLE.
    378            * @retval None
    379            */

   \                                 In section .far_func.text, align 1
    380          void TIM1_UpdateDisableConfig(FunctionalState NewState)
    381          {
    382            /* Check the parameters */
    383            assert_param(IS_FUNCTIONAL_STATE(NewState));
    384          
    385            /* Set or Reset the UDIS Bit */
    386            if (NewState != DISABLE)
   \                     TIM1_UpdateDisableConfig:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM1_UpdateDisableConfig_0
    387            {
    388              TIM1->CR1 |= TIM1_CR1_UDIS;
   \   000003 7212 52B0    BSET      L:0x52b0, #0x1
   \   000007 87           RETF
    389            }
    390            else
    391            {
    392              TIM1->CR1 &= (uint8_t)(~TIM1_CR1_UDIS);
   \                     ??TIM1_UpdateDisableConfig_0:
   \   000008 7213 52B0    BRES      L:0x52b0, #0x1
    393            }
    394          }
   \   00000C 87           RETF
    395          
    396          /**
    397            * @brief  Selects the TIM1 Update Request Interrupt source.
    398            * @param  TIM1_UpdateSource specifies the Update source.
    399            *          This parameter can be one of the following values
    400            *            @arg TIM1_UpdateSource_Regular
    401            *            @arg TIM1_UpdateSource_Global
    402            * @retval None
    403            */

   \                                 In section .far_func.text, align 1
    404          void TIM1_UpdateRequestConfig(TIM1_UpdateSource_TypeDef TIM1_UpdateSource)
    405          {
    406            /* Check the parameters */
    407            assert_param(IS_TIM1_UPDATE_SOURCE(TIM1_UpdateSource));
    408          
    409            /* Set or Reset the URS Bit */
    410            if (TIM1_UpdateSource != TIM1_UpdateSource_Global)
   \                     TIM1_UpdateRequestConfig:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM1_UpdateRequestConfig_0
    411            {
    412              TIM1->CR1 |= TIM1_CR1_URS;
   \   000003 7214 52B0    BSET      L:0x52b0, #0x2
   \   000007 87           RETF
    413            }
    414            else
    415            {
    416              TIM1->CR1 &= (uint8_t)(~TIM1_CR1_URS);
   \                     ??TIM1_UpdateRequestConfig_0:
   \   000008 7215 52B0    BRES      L:0x52b0, #0x2
    417            }
    418          }
   \   00000C 87           RETF
    419          
    420          /**
    421            * @brief  Enables or disables TIM1 peripheral Preload register on ARR.
    422            * @param  NewState new state of the TIM1 peripheral Preload register.
    423            *          This parameter can be ENABLE or DISABLE.
    424            * @retval None
    425            */

   \                                 In section .far_func.text, align 1
    426          void TIM1_ARRPreloadConfig(FunctionalState NewState)
    427          {
    428            /* Check the parameters */
    429            assert_param(IS_FUNCTIONAL_STATE(NewState));
    430          
    431            /* Set or Reset the ARPE Bit */
    432            if (NewState != DISABLE)
   \                     TIM1_ARRPreloadConfig:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM1_ARRPreloadConfig_0
    433            {
    434              TIM1->CR1 |= TIM1_CR1_ARPE;
   \   000003 721E 52B0    BSET      L:0x52b0, #0x7
   \   000007 87           RETF
    435            }
    436            else
    437            {
    438              TIM1->CR1 &= (uint8_t)(~TIM1_CR1_ARPE);
   \                     ??TIM1_ARRPreloadConfig_0:
   \   000008 721F 52B0    BRES      L:0x52b0, #0x7
    439            }
    440          }
   \   00000C 87           RETF
    441          
    442          /**
    443            * @brief  Selects the TIM1’s One Pulse Mode.
    444            * @param  TIM1_OPMode specifies the OPM Mode to be used.
    445            *          This parameter can be one of the following values
    446            *            @arg TIM1_OPMode_Single
    447            *            @arg TIM1_OPMode_Repetitive
    448            * @retval None
    449            */

   \                                 In section .far_func.text, align 1
    450          void TIM1_SelectOnePulseMode(TIM1_OPMode_TypeDef TIM1_OPMode)
    451          {
    452            /* Check the parameters */
    453            assert_param(IS_TIM1_OPM_MODE(TIM1_OPMode));
    454          
    455            /* Set or Reset the OPM Bit */
    456            if (TIM1_OPMode != TIM1_OPMode_Repetitive)
   \                     TIM1_SelectOnePulseMode:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM1_SelectOnePulseMode_0
    457            {
    458              TIM1->CR1 |= TIM1_CR1_OPM;
   \   000003 7216 52B0    BSET      L:0x52b0, #0x3
   \   000007 87           RETF
    459            }
    460            else
    461            {
    462              TIM1->CR1 &= (uint8_t)(~TIM1_CR1_OPM);
   \                     ??TIM1_SelectOnePulseMode_0:
   \   000008 7217 52B0    BRES      L:0x52b0, #0x3
    463            }
    464          }
   \   00000C 87           RETF
    465          
    466          /**
    467            * @brief  Enables or disables the TIM1 peripheral.
    468            * @param  NewState new state of the TIM1 peripheral. 
    469            *          This parameter can be ENABLE or DISABLE.
    470            * @retval None
    471            */

   \                                 In section .far_func.text, align 1
    472          void TIM1_Cmd(FunctionalState NewState)
    473          {
    474            /* Check the parameters */
    475            assert_param(IS_FUNCTIONAL_STATE(NewState));
    476          
    477            /* set or Reset the CEN Bit */
    478            if (NewState != DISABLE)
   \                     TIM1_Cmd:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM1_Cmd_0
    479            {
    480              TIM1->CR1 |= TIM1_CR1_CEN;
   \   000003 7210 52B0    BSET      L:0x52b0, #0x0
   \   000007 87           RETF
    481            }
    482            else
    483            {
    484              TIM1->CR1 &= (uint8_t)(~TIM1_CR1_CEN);
   \                     ??TIM1_Cmd_0:
   \   000008 7211 52B0    BRES      L:0x52b0, #0x0
    485            }
    486          }
   \   00000C 87           RETF
    487          
    488          /**
    489            * @}
    490            */
    491          
    492          /** @defgroup TIM1_Group2 Output Compare management functions
    493           *  @brief    Output Compare management functions 
    494           *
    495          @verbatim   
    496           ===============================================================================
    497                                  Output Compare management functions
    498           ===============================================================================  
    499             
    500                 ===================================================================      
    501                        TIM1 Driver: how to use it in Output Compare Mode
    502                 =================================================================== 
    503                 To use the Timer in Output Compare mode, the following steps are mandatory:
    504                 
    505                 1. Enable TIM1 clock using CLK_PeripheralClockConfig(CLK_Peripheral_TIM1, ENABLE) function.
    506                 
    507                 2. Configure the TIM1 pins in output mode by configuring the corresponding GPIO pins
    508                    
    509                 3. Configure the Time base unit as described in the first part of this driver, if needed,
    510                    otherwise the Timer will run with the default configuration:
    511                    - Autoreload value = 0xFFFF
    512                    - Prescaler value = 0x0000
    513                    - Counter mode = Up counting
    514                
    515                 4. Call TIM1_OCxInit() to configure the channel x with the desired parameters
    516                    including:
    517                    - TIM1 Output Compare mode: TIM1_OCMode
    518                    - TIM1 Output State: TIM1_OutputState
    519                    - TIM1 Complementary Output State: TIM1_OutputNState
    520                    - TIM1 Pulse value: TIM1_Pulse
    521                    - TIM1 Output Compare Polarity : TIM1_OCPolarity
    522                    - TIM1 Complementary Output Compare Polarity : TIM1_OCNPolarity
    523                    - TIM1 Output Idle State: TIM1_OCIdleState
    524                    - TIM1 Complementary Output Idle State: TIM1_OCNIdleState
    525                 
    526                 5. Call the TIM1_Cmd(ENABLE) function to enable the TIM1 counter.
    527                 
    528                 Note1: All other functions can be used separately to modify, if needed,
    529                    a specific feature of the Timer. 
    530                 
    531                 Note2: If the corresponding interrupt or DMA request are needed, the user should:
    532                        1. Enable global interrupts (or the DMA) to use the TIM1 interrupts (or DMA requests). 
    533                        2. Enable the corresponding interrupt (or DMA request) using the function 
    534                        TIM1_ITConfig(TIM1_IT_CCx) (or TIM1_DMACmd(TIM1_DMASource_CCx))   
    535          
    536          @endverbatim
    537            * @{
    538            */
    539            
    540          /**
    541            * @brief  Initializes the TIM1 Channel1 according to the specified parameters.
    542            * @param  TIM1_OCMode specifies the Output Compare mode
    543            *          This parameter can be one of the following values:
    544            *            @arg TIM1_OCMode_Timing: OC Mode Timing
    545            *            @arg TIM1_OCMode_Active: OC Mode Active
    546            *            @arg TIM1_OCMode_Inactive: OC Mode Inactive
    547            *            @arg TIM1_OCMode_Toggle: OC Mode Toggle
    548            *            @arg TIM1_OCMode_PWM1: OC Mode PWM1
    549            *            @arg TIM1_OCMode_PWM2: OC Mode PWM2          
    550            * @param  TIM1_OutputState specifies the Output State
    551            *          This parameter can be one of the following values:
    552            *            @arg TIM1_OutputState_Disable: Output state disable
    553            *            @arg TIM1_OutputState_Enable: Output state enable
    554            * @param  TIM1_OutputNState specifies the Complementary Output State
    555            *          This parameter can be one of the following values:
    556            *            @arg TIM1_OutputNState_Disable: Output N state disable
    557            *            @arg TIM1_OutputNState_Enable: Output N state enable
    558            * @param  TIM1_Pulse specifies the Pulse width value.
    559            * @param  TIM1_OCPolarity specifies the Output Compare Polarity
    560            *          This parameter can be one of the following values:
    561            *            @arg TIM1_OCPolarity_High: Output Compare active low
    562            *            @arg TIM1_OCPolarity_Low: Output Compare active high
    563            * @param  TIM1_OCNPolarity specifies the Complementary Output Compare Polarity 
    564            *          This parameter can be one of the following values:
    565            *            @arg TIM1_OCNPolarity_High: Complementary Output Compare active low
    566            *            @arg TIM1_OCNPolarity_Low: Complementary Output Compare active high
    567            * @param  TIM1_OCIdleState specifies the Output Compare Idle State
    568            *          This parameter can be one of the following values:
    569            *            @arg TIM1_OCIdleState_Set: Output Compare Idle state set
    570            *            @arg TIM1_OCIdleState_Reset: Output Compare Idle state reset
    571            * @param  TIM1_OCNIdleState specifies the Complementary Output Compare Idle State
    572            *          This parameter can be one of the following values:
    573            *            @arg TIM1_OCNIdleState_Set: Complementary Output Compare Idle state set
    574            *            @arg TIM1_OCNIdleState_Reset: Complementary Output Compare Idle state reset
    575            * @retval None
    576            */

   \                                 In section .far_func.text, align 1
    577          void TIM1_OC1Init(TIM1_OCMode_TypeDef TIM1_OCMode,
    578                            TIM1_OutputState_TypeDef TIM1_OutputState,
    579                            TIM1_OutputNState_TypeDef TIM1_OutputNState,
    580                            uint16_t TIM1_Pulse,
    581                            TIM1_OCPolarity_TypeDef TIM1_OCPolarity,
    582                            TIM1_OCNPolarity_TypeDef TIM1_OCNPolarity,
    583                            TIM1_OCIdleState_TypeDef TIM1_OCIdleState,
    584                            TIM1_OCNIdleState_TypeDef TIM1_OCNIdleState)
    585          {
   \                     TIM1_OC1Init:
   \   000000 B7 ..        LD        S:?b6, A
   \   000002 9093         LDW       Y, X
    586            /* Check the parameters */
    587            assert_param(IS_TIM1_OC_MODE(TIM1_OCMode));
    588            assert_param(IS_TIM1_OUTPUT_STATE(TIM1_OutputState));
    589            assert_param(IS_TIM1_OUTPUTN_STATE(TIM1_OutputNState));
    590            assert_param(IS_TIM1_OC_POLARITY(TIM1_OCPolarity));
    591            assert_param(IS_TIM1_OCN_POLARITY(TIM1_OCNPolarity));
    592            assert_param(IS_TIM1_OCIDLE_STATE(TIM1_OCIdleState));
    593            assert_param(IS_TIM1_OCNIDLE_STATE(TIM1_OCNIdleState));
    594          
    595            /* Disable the Channel 1: Reset the CCE Bit, Set the Output State ,
    596            the Output N State, the Output Polarity & the Output N Polarity*/
    597            TIM1->CCER1 &= (uint8_t)(~(TIM1_CCER1_CC1E | TIM1_CCER1_CC1NE
    598                                       | TIM1_CCER1_CC1P | TIM1_CCER1_CC1NP));
   \   000004 C6 52BD      LD        A, L:0x52bd
   \   000007 A4 F0        AND       A, #0xf0
   \   000009 C7 52BD      LD        L:0x52bd, A
    599            /* Set the Output State & Set the Output N State & Set the Output Polarity
    600            & Set the Output N Polarity */
    601            TIM1->CCER1 |= (uint8_t)((uint8_t)((uint8_t)(TIM1_OutputState & TIM1_CCER1_CC1E)
    602                                               | (uint8_t)(TIM1_OutputNState & TIM1_CCER1_CC1NE))
    603                                     | (uint8_t)( (uint8_t)(TIM1_OCPolarity  & TIM1_CCER1_CC1P)
    604                                                  | (uint8_t)(TIM1_OCNPolarity & TIM1_CCER1_CC1NP)));
   \   00000C B6 ..        LD        A, S:?b3
   \   00000E A4 08        AND       A, #0x8
   \   000010 88           PUSH      A
   \   000011 B6 ..        LD        A, S:?b2
   \   000013 A4 02        AND       A, #0x2
   \   000015 B7 ..        LD        S:?b2, A
   \   000017 84           POP       A
   \   000018 BA ..        OR        A, S:?b2
   \   00001A 88           PUSH      A
   \   00001B B6 ..        LD        A, S:?b1
   \   00001D A4 04        AND       A, #0x4
   \   00001F 88           PUSH      A
   \   000020 B6 ..        LD        A, S:?b0
   \   000022 A4 01        AND       A, #0x1
   \   000024 B7 ..        LD        S:?b0, A
   \   000026 84           POP       A
   \   000027 BA ..        OR        A, S:?b0
   \   000029 B7 ..        LD        S:?b0, A
   \   00002B 84           POP       A
   \   00002C BA ..        OR        A, S:?b0
   \   00002E CA 52BD      OR        A, L:0x52bd
   \   000031 C7 52BD      LD        L:0x52bd, A
    605          
    606            /* Reset the Output Compare Bits & Set the Output Compare Mode */
    607            TIM1->CCMR1 = (uint8_t)((uint8_t)(TIM1->CCMR1 & (uint8_t)(~TIM1_CCMR_OCM))
    608                                    | (uint8_t)TIM1_OCMode);
   \   000034 C6 52B9      LD        A, L:0x52b9
   \   000037 A4 8F        AND       A, #0x8f
   \   000039 BA ..        OR        A, S:?b6
   \   00003B C7 52B9      LD        L:0x52b9, A
    609          
    610            /* Reset the Output Idle state & the Output N Idle state bits */
    611            TIM1->OISR &= (uint8_t)(~(TIM1_OISR_OIS1 | TIM1_OISR_OIS1N));
   \   00003E C6 52D0      LD        A, L:0x52d0
   \   000041 A4 FC        AND       A, #0xfc
   \   000043 C7 52D0      LD        L:0x52d0, A
    612            /* Set the Output Idle state & the Output N Idle state configuration */
    613            TIM1->OISR |= (uint8_t)((uint8_t)(TIM1_OCIdleState & TIM1_OISR_OIS1)
    614                                    | (uint8_t)(TIM1_OCNIdleState & TIM1_OISR_OIS1N));
   \   000046 B6 ..        LD        A, S:?b5
   \   000048 A4 02        AND       A, #0x2
   \   00004A 88           PUSH      A
   \   00004B B6 ..        LD        A, S:?b4
   \   00004D A4 01        AND       A, #0x1
   \   00004F B7 ..        LD        S:?b1, A
   \   000051 84           POP       A
   \   000052 BA ..        OR        A, S:?b1
   \   000054 CA 52D0      OR        A, L:0x52d0
   \   000057 C7 52D0      LD        L:0x52d0, A
    615          
    616            /* Set the Pulse value */
    617            TIM1->CCR1H = (uint8_t)(TIM1_Pulse >> 8);
   \   00005A 93           LDW       X, Y
   \   00005B 4F           CLR       A
   \   00005C 01           RRWA      X, A
   \   00005D 9F           LD        A, XL
   \   00005E C7 52C6      LD        L:0x52c6, A
    618            TIM1->CCR1L = (uint8_t)(TIM1_Pulse);
   \   000061 909F         LD        A, YL
   \   000063 C7 52C7      LD        L:0x52c7, A
    619          }
   \   000066 87           RETF
    620          
    621          /**
    622            * @brief  Initializes the TIM1 Channel2 according to the specified parameters.
    623            * @param  TIM1_OCMode specifies the Output Compare mode
    624            *          This parameter can be one of the following values:
    625            *            @arg TIM1_OCMode_Timing: OC Mode Timing
    626            *            @arg TIM1_OCMode_Active: OC Mode Active
    627            *            @arg TIM1_OCMode_Inactive: OC Mode Inactive
    628            *            @arg TIM1_OCMode_Toggle: OC Mode Toggle
    629            *            @arg TIM1_OCMode_PWM1: OC Mode PWM1
    630            *            @arg TIM1_OCMode_PWM2: OC Mode PWM2  
    631            * @param  TIM1_OutputState specifies the Output State
    632            *          This parameter can be one of the following values:
    633            *            @arg TIM1_OutputState_Disable: Output state disable
    634            *            @arg TIM1_OutputState_Enable: Output state enable
    635            * @param  TIM1_OutputNState specifies the Complementary Output State
    636            *          This parameter can be one of the following values:
    637            *            @arg TIM1_OutputNState_Disable: Output N state disable
    638            *            @arg TIM1_OutputNState_Enable: Output N state enable
    639            * @param  TIM1_Pulse specifies the Pulse width value.
    640            * @param  TIM1_OCPolarity specifies the Output Compare Polarity
    641            *          This parameter can be one of the following values:
    642            *            @arg TIM1_OCPolarity_High: Output Compare active low
    643            *            @arg TIM1_OCPolarity_Low: Output Compare active high
    644            * @param  TIM1_OCNPolarity specifies the Complementary Output Compare
    645            *          This parameter can be one of the following values:
    646            *            @arg TIM1_OCNPolarity_High: Complementary Output Compare active low
    647            *            @arg TIM1_OCNPolarity_Low: Complementary Output Compare active high
    648            * @param  TIM1_OCIdleState specifies the Output Compare Idle State
    649            *          This parameter can be one of the following values:
    650            *            @arg TIM1_OCIdleState_Set: Output Compare Idle state set
    651            *            @arg TIM1_OCIdleState_Reset: Output Compare Idle state reset
    652            * @param  TIM1_OCNIdleState specifies the Complementary Output Compare Idle State
    653            *          This parameter can be one of the following values:
    654            *            @arg TIM1_OCNIdleState_Set: Complementary Output Compare Idle state set
    655            *            @arg TIM1_OCNIdleState_Reset: Complementary Output Compare Idle state reset
    656            * @retval None
    657            */

   \                                 In section .far_func.text, align 1
    658          void TIM1_OC2Init(TIM1_OCMode_TypeDef TIM1_OCMode,
    659                            TIM1_OutputState_TypeDef TIM1_OutputState,
    660                            TIM1_OutputNState_TypeDef TIM1_OutputNState,
    661                            uint16_t TIM1_Pulse,
    662                            TIM1_OCPolarity_TypeDef TIM1_OCPolarity,
    663                            TIM1_OCNPolarity_TypeDef TIM1_OCNPolarity,
    664                            TIM1_OCIdleState_TypeDef TIM1_OCIdleState,
    665                            TIM1_OCNIdleState_TypeDef TIM1_OCNIdleState)
    666          {
   \                     TIM1_OC2Init:
   \   000000 B7 ..        LD        S:?b6, A
   \   000002 9093         LDW       Y, X
    667          
    668            /* Check the parameters */
    669            assert_param(IS_TIM1_OC_MODE(TIM1_OCMode));
    670            assert_param(IS_TIM1_OUTPUT_STATE(TIM1_OutputState));
    671            assert_param(IS_TIM1_OUTPUTN_STATE(TIM1_OutputNState));
    672            assert_param(IS_TIM1_OC_POLARITY(TIM1_OCPolarity));
    673            assert_param(IS_TIM1_OCN_POLARITY(TIM1_OCNPolarity));
    674            assert_param(IS_TIM1_OCIDLE_STATE(TIM1_OCIdleState));
    675            assert_param(IS_TIM1_OCNIDLE_STATE(TIM1_OCNIdleState));
    676          
    677            /* Disable the Channel 1: Reset the CCE Bit, Set the Output State,
    678               the Output N State, the Output Polarity & the Output N Polarity*/
    679            TIM1->CCER1 &= (uint8_t)(~(TIM1_CCER1_CC2E | TIM1_CCER1_CC2NE | TIM1_CCER1_CC2P | TIM1_CCER1_CC2NP));
   \   000004 C6 52BD      LD        A, L:0x52bd
   \   000007 A4 0F        AND       A, #0xf
   \   000009 C7 52BD      LD        L:0x52bd, A
    680          
    681            /* Set the Output State & Set the Output N State & Set the Output Polarity & Set the Output N Polarity */
    682            TIM1->CCER1 |= (uint8_t)((uint8_t)((uint8_t)(TIM1_OutputState & TIM1_CCER1_CC2E) | (uint8_t)(TIM1_OutputNState & TIM1_CCER1_CC2NE))
    683                                     | (uint8_t) ((uint8_t)(TIM1_OCPolarity & TIM1_CCER1_CC2P) | (uint8_t)(TIM1_OCNPolarity & TIM1_CCER1_CC2NP)));
   \   00000C B6 ..        LD        A, S:?b3
   \   00000E A4 80        AND       A, #0x80
   \   000010 88           PUSH      A
   \   000011 B6 ..        LD        A, S:?b2
   \   000013 A4 20        AND       A, #0x20
   \   000015 B7 ..        LD        S:?b2, A
   \   000017 84           POP       A
   \   000018 BA ..        OR        A, S:?b2
   \   00001A 88           PUSH      A
   \   00001B B6 ..        LD        A, S:?b1
   \   00001D A4 40        AND       A, #0x40
   \   00001F 88           PUSH      A
   \   000020 B6 ..        LD        A, S:?b0
   \   000022 A4 10        AND       A, #0x10
   \   000024 B7 ..        LD        S:?b0, A
   \   000026 84           POP       A
   \   000027 BA ..        OR        A, S:?b0
   \   000029 B7 ..        LD        S:?b0, A
   \   00002B 84           POP       A
   \   00002C BA ..        OR        A, S:?b0
   \   00002E CA 52BD      OR        A, L:0x52bd
   \   000031 C7 52BD      LD        L:0x52bd, A
    684          
    685            /* Reset the Output Compare Bits & Set the Output Compare Mode */
    686            TIM1->CCMR2 = (uint8_t)((uint8_t)(TIM1->CCMR2 & (uint8_t)(~TIM1_CCMR_OCM)) | (uint8_t)TIM1_OCMode);
   \   000034 C6 52BA      LD        A, L:0x52ba
   \   000037 A4 8F        AND       A, #0x8f
   \   000039 BA ..        OR        A, S:?b6
   \   00003B C7 52BA      LD        L:0x52ba, A
    687          
    688            /* Reset the Output Idle state & the Output N Idle state bits */
    689            TIM1->OISR &= (uint8_t)(~(TIM1_OISR_OIS2 | TIM1_OISR_OIS2N));
   \   00003E C6 52D0      LD        A, L:0x52d0
   \   000041 A4 F3        AND       A, #0xf3
   \   000043 C7 52D0      LD        L:0x52d0, A
    690            /* Set the Output Idle state & the Output N Idle state configuration */
    691            TIM1->OISR |= (uint8_t)((uint8_t)(TIM1_OISR_OIS2 & TIM1_OCIdleState) | (uint8_t)(TIM1_OISR_OIS2N & TIM1_OCNIdleState));
   \   000046 B6 ..        LD        A, S:?b5
   \   000048 A4 08        AND       A, #0x8
   \   00004A 88           PUSH      A
   \   00004B B6 ..        LD        A, S:?b4
   \   00004D A4 04        AND       A, #0x4
   \   00004F B7 ..        LD        S:?b1, A
   \   000051 84           POP       A
   \   000052 BA ..        OR        A, S:?b1
   \   000054 CA 52D0      OR        A, L:0x52d0
   \   000057 C7 52D0      LD        L:0x52d0, A
    692          
    693            /* Set the Pulse value */
    694            TIM1->CCR2H = (uint8_t)(TIM1_Pulse >> 8);
   \   00005A 93           LDW       X, Y
   \   00005B 4F           CLR       A
   \   00005C 01           RRWA      X, A
   \   00005D 9F           LD        A, XL
   \   00005E C7 52C8      LD        L:0x52c8, A
    695            TIM1->CCR2L = (uint8_t)(TIM1_Pulse);
   \   000061 909F         LD        A, YL
   \   000063 C7 52C9      LD        L:0x52c9, A
    696          }
   \   000066 87           RETF
    697          
    698          /**
    699            * @brief  Initializes the TIM1 Channel3 according to the specified parameters.
    700            * @param  TIM1_OCMode specifies the Output Compare mode
    701            *          This parameter can be one of the following values:
    702            *            @arg TIM1_OCMode_Timing: OC Mode Timing
    703            *            @arg TIM1_OCMode_Active: OC Mode Active
    704            *            @arg TIM1_OCMode_Inactive: OC Mode Inactive
    705            *            @arg TIM1_OCMode_Toggle: OC Mode Toggle
    706            *            @arg TIM1_OCMode_PWM1: OC Mode PWM1
    707            *            @arg TIM1_OCMode_PWM2: OC Mode PWM2     
    708            * @param  TIM1_OutputState specifies the Output State
    709            *          This parameter can be one of the following values:
    710            *            @arg TIM1_OutputState_Disable: Output state disable
    711            *            @arg TIM1_OutputState_Enable: Output state enable
    712            * @param  TIM1_OutputNState specifies the Complementary Output State
    713            *          This parameter can be one of the following values:
    714            *            @arg TIM1_OutputNState_Disable: Output N state disable
    715            *            @arg TIM1_OutputNState_Enable: Output N state enable
    716            * @param  TIM1_Pulse specifies the Pulse width value.
    717            * @param  TIM1_OCPolarity specifies the Output Compare Polarity
    718            *          This parameter can be one of the following values:
    719            *            @arg TIM1_OCPolarity_High: Output Compare active low
    720            *            @arg TIM1_OCPolarity_Low: Output Compare active high
    721            * @param  TIM1_OCNPolarity specifies the Complementary Output Compare Polarity
    722            *          This parameter can be one of the following values:
    723            *            @arg TIM1_OCNPolarity_High: Complementary Output Compare active low
    724            *            @arg TIM1_OCNPolarity_Low: Complementary Output Compare active high
    725            * @param  TIM1_OCIdleState specifies the Output Compare Idle State
    726            *          This parameter can be one of the following values:
    727            *            @arg TIM1_OCIdleState_Set: Output Compare Idle state set
    728            *            @arg TIM1_OCIdleState_Reset: Output Compare Idle state reset
    729            * @param  TIM1_OCNIdleState specifies the Complementary Output Compare Idle State
    730            *          This parameter can be one of the following values:
    731            *            @arg TIM1_OCNIdleState_Set: Complementary Output Compare Idle state set
    732            *            @arg TIM1_OCNIdleState_Reset: Complementary Output Compare Idle state reset
    733            * @retval None
    734            */

   \                                 In section .far_func.text, align 1
    735          void TIM1_OC3Init(TIM1_OCMode_TypeDef TIM1_OCMode,
    736                            TIM1_OutputState_TypeDef TIM1_OutputState,
    737                            TIM1_OutputNState_TypeDef TIM1_OutputNState,
    738                            uint16_t TIM1_Pulse,
    739                            TIM1_OCPolarity_TypeDef TIM1_OCPolarity,
    740                            TIM1_OCNPolarity_TypeDef TIM1_OCNPolarity,
    741                            TIM1_OCIdleState_TypeDef TIM1_OCIdleState,
    742                            TIM1_OCNIdleState_TypeDef TIM1_OCNIdleState)
    743          {
   \                     TIM1_OC3Init:
   \   000000 B7 ..        LD        S:?b6, A
   \   000002 9093         LDW       Y, X
    744          
    745            /* Check the parameters */
    746            assert_param(IS_TIM1_OC_MODE(TIM1_OCMode));
    747            assert_param(IS_TIM1_OUTPUT_STATE(TIM1_OutputState));
    748            assert_param(IS_TIM1_OUTPUTN_STATE(TIM1_OutputNState));
    749            assert_param(IS_TIM1_OC_POLARITY(TIM1_OCPolarity));
    750            assert_param(IS_TIM1_OCN_POLARITY(TIM1_OCNPolarity));
    751            assert_param(IS_TIM1_OCIDLE_STATE(TIM1_OCIdleState));
    752            assert_param(IS_TIM1_OCNIDLE_STATE(TIM1_OCNIdleState));
    753          
    754            /* Disable the Channel 1: Reset the CCE Bit, Set the Output State,
    755               the Output N State, the Output Polarity & the Output N Polarity */
    756            TIM1->CCER2 &= (uint8_t)(~( TIM1_CCER2_CC3E | TIM1_CCER2_CC3NE | TIM1_CCER2_CC3P | TIM1_CCER2_CC3NP));
   \   000004 C6 52BE      LD        A, L:0x52be
   \   000007 A4 F0        AND       A, #0xf0
   \   000009 C7 52BE      LD        L:0x52be, A
    757          
    758            /* Set the Output State & Set the Output N State & Set the Output Polarity & Set the Output N Polarity */
    759            TIM1->CCER2 |= (uint8_t)((uint8_t)((uint8_t)(TIM1_OutputState & TIM1_CCER2_CC3E) | (uint8_t)(TIM1_OutputNState & TIM1_CCER2_CC3NE))
    760                                     | (uint8_t)((uint8_t)(TIM1_OCPolarity & TIM1_CCER2_CC3P) | (uint8_t)(TIM1_OCNPolarity & TIM1_CCER2_CC3NP)));
   \   00000C B6 ..        LD        A, S:?b3
   \   00000E A4 08        AND       A, #0x8
   \   000010 88           PUSH      A
   \   000011 B6 ..        LD        A, S:?b2
   \   000013 A4 02        AND       A, #0x2
   \   000015 B7 ..        LD        S:?b2, A
   \   000017 84           POP       A
   \   000018 BA ..        OR        A, S:?b2
   \   00001A 88           PUSH      A
   \   00001B B6 ..        LD        A, S:?b1
   \   00001D A4 04        AND       A, #0x4
   \   00001F 88           PUSH      A
   \   000020 B6 ..        LD        A, S:?b0
   \   000022 A4 01        AND       A, #0x1
   \   000024 B7 ..        LD        S:?b0, A
   \   000026 84           POP       A
   \   000027 BA ..        OR        A, S:?b0
   \   000029 B7 ..        LD        S:?b0, A
   \   00002B 84           POP       A
   \   00002C BA ..        OR        A, S:?b0
   \   00002E CA 52BE      OR        A, L:0x52be
   \   000031 C7 52BE      LD        L:0x52be, A
    761          
    762            /* Reset the Output Compare Bits & Set the Output Compare Mode */
    763            TIM1->CCMR3 = (uint8_t)((uint8_t)(TIM1->CCMR3 & (uint8_t)(~TIM1_CCMR_OCM)) | (uint8_t)TIM1_OCMode);
   \   000034 C6 52BB      LD        A, L:0x52bb
   \   000037 A4 8F        AND       A, #0x8f
   \   000039 BA ..        OR        A, S:?b6
   \   00003B C7 52BB      LD        L:0x52bb, A
    764          
    765            /* Reset the Output Idle state & the Output N Idle state bits */
    766            TIM1->OISR &= (uint8_t)(~(TIM1_OISR_OIS3 | TIM1_OISR_OIS3N));
   \   00003E C6 52D0      LD        A, L:0x52d0
   \   000041 A4 CF        AND       A, #0xcf
   \   000043 C7 52D0      LD        L:0x52d0, A
    767            /* Set the Output Idle state & the Output N Idle state configuration */
    768            TIM1->OISR |= (uint8_t)((uint8_t)(TIM1_OISR_OIS3 & TIM1_OCIdleState) | (uint8_t) (TIM1_OISR_OIS3N & TIM1_OCNIdleState));
   \   000046 B6 ..        LD        A, S:?b5
   \   000048 A4 20        AND       A, #0x20
   \   00004A 88           PUSH      A
   \   00004B B6 ..        LD        A, S:?b4
   \   00004D A4 10        AND       A, #0x10
   \   00004F B7 ..        LD        S:?b1, A
   \   000051 84           POP       A
   \   000052 BA ..        OR        A, S:?b1
   \   000054 CA 52D0      OR        A, L:0x52d0
   \   000057 C7 52D0      LD        L:0x52d0, A
    769          
    770            /* Set the Pulse value */
    771            TIM1->CCR3H = (uint8_t)(TIM1_Pulse >> 8);
   \   00005A 93           LDW       X, Y
   \   00005B 4F           CLR       A
   \   00005C 01           RRWA      X, A
   \   00005D 9F           LD        A, XL
   \   00005E C7 52CA      LD        L:0x52ca, A
    772            TIM1->CCR3L = (uint8_t)(TIM1_Pulse);
   \   000061 909F         LD        A, YL
   \   000063 C7 52CB      LD        L:0x52cb, A
    773          }
   \   000066 87           RETF
    774          
    775          /**
    776            * @brief  Configures the Break feature, dead time, Lock level, the OSSI,
    777            *         and the AOE(automatic output enable).
    778            * @param  TIM1_OSSIState specifies the OSSIS State
    779            *          This parameter can be one of the following values:
    780            *            @arg TIM1_OSSIState_Enable: OSSIS State enabled
    781            *            @arg TIM1_OSSIState_Disable: OSSIS State disabled   
    782            * @param  TIM1_LockLevel specifies the lock level
    783            *          This parameter can be one of the following values:
    784            *            @arg TIM1_LockLevel_Off: No lock level
    785            *            @arg TIM1_LockLevel_1: Lock level 1  
    786            *            @arg TIM1_LockLevel_2: Lock level 2
    787            *            @arg TIM1_LockLevel_3: Lock level 3
    788            * @param  TIM1_DeadTime specifies the dead time value.
    789            * @param  TIM1_Break specifies the Break state
    790            *          This parameter can be one of the following values:
    791            *            @arg TIM1_BreakState_Enable: Break enabled
    792            *            @arg TIM1_BreakState_Disable: Break disabled  
    793            * @param  TIM1_BreakPolarity specifies the Break polarity
    794            *          This parameter can be one of the following values:
    795            *            @arg TIM1_BreakPolarity_Low: Break polarity high
    796            *            @arg TIM1_BreakPolarity_High: Break polarity low
    797            * @param  TIM1_AutomaticOutput specifies the Automatic Output configuration
    798            *          This parameter can be one of the following values:
    799            *            @arg TIM1_AutomaticOutput_Enable: Automatic Output enabled
    800            *            @arg TIM1_AutomaticOutput_Disable: Automatic Output disabled  
    801            * @retval None
    802            */

   \                                 In section .far_func.text, align 1
    803          void TIM1_BDTRConfig(TIM1_OSSIState_TypeDef TIM1_OSSIState,
    804                               TIM1_LockLevel_TypeDef TIM1_LockLevel,
    805                               uint8_t TIM1_DeadTime,
    806                               TIM1_BreakState_TypeDef TIM1_Break,
    807                               TIM1_BreakPolarity_TypeDef TIM1_BreakPolarity,
    808                               TIM1_AutomaticOutput_TypeDef TIM1_AutomaticOutput)
    809          {
   \                     TIM1_BDTRConfig:
   \   000000 B7 ..        LD        S:?b5, A
    810          
    811            /* Check the parameters */
    812            assert_param(IS_TIM1_OSSI_STATE(TIM1_OSSIState));
    813            assert_param(IS_TIM1_LOCK_LEVEL(TIM1_LockLevel));
    814            assert_param(IS_TIM1_BREAK_STATE(TIM1_Break));
    815            assert_param(IS_TIM1_BREAK_POLARITY(TIM1_BreakPolarity));
    816            assert_param(IS_TIM1_AUTOMATIC_OUTPUT_STATE(TIM1_AutomaticOutput));
    817          
    818            TIM1->DTR = (uint8_t)(TIM1_DeadTime);
   \   000002 B6 ..        LD        A, S:?b1
   \   000004 C7 52CF      LD        L:0x52cf, A
    819            /* Set the Lock level, the Break enable Bit and the Polarity, the OSSI State,
    820               the dead time value  and the Automatic Output Enable Bit */
    821          
    822            TIM1->BKR  =  (uint8_t)((uint8_t)((uint8_t)TIM1_OSSIState | (uint8_t)TIM1_LockLevel)
    823                                    | (uint8_t)((uint8_t)((uint8_t)TIM1_Break | (uint8_t)TIM1_BreakPolarity)
    824                                                | (uint8_t)TIM1_AutomaticOutput));
   \   000007 B6 ..        LD        A, S:?b3
   \   000009 BA ..        OR        A, S:?b2
   \   00000B BA ..        OR        A, S:?b4
   \   00000D 88           PUSH      A
   \   00000E B6 ..        LD        A, S:?b0
   \   000010 BA ..        OR        A, S:?b5
   \   000012 B7 ..        LD        S:?b0, A
   \   000014 84           POP       A
   \   000015 BA ..        OR        A, S:?b0
   \   000017 C7 52CE      LD        L:0x52ce, A
    825          
    826          }
   \   00001A 87           RETF
    827          
    828          /**
    829            * @brief  Enables or disables the TIM1 peripheral Main Outputs.
    830            * @param  NewState new state of the TIM1 peripheral. 
    831            *          This parameter can be ENABLE or DISABLE.
    832            * @retval None
    833            */

   \                                 In section .far_func.text, align 1
    834          void TIM1_CtrlPWMOutputs(FunctionalState NewState)
    835          {
    836            /* Check the parameters */
    837            assert_param(IS_FUNCTIONAL_STATE(NewState));
    838          
    839            /* Set or Reset the MOE Bit */
    840          
    841            if (NewState != DISABLE)
   \                     TIM1_CtrlPWMOutputs:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM1_CtrlPWMOutputs_0
    842            {
    843              TIM1->BKR |= TIM1_BKR_MOE;
   \   000003 721E 52CE    BSET      L:0x52ce, #0x7
   \   000007 87           RETF
    844            }
    845            else
    846            {
    847              TIM1->BKR &= (uint8_t)(~TIM1_BKR_MOE);
   \                     ??TIM1_CtrlPWMOutputs_0:
   \   000008 721F 52CE    BRES      L:0x52ce, #0x7
    848            }
    849          }
   \   00000C 87           RETF
    850          
    851          /**
    852            * @brief  Selects the TIM1 Output Compare Mode. This function disables the
    853            *         selected channel before changing the Output Compare Mode. 
    854            * @note   User has to enable this channel using TIM1_CCxCmd and TIM1_CCxNCmd functions.
    855            * @param  TIM1_Channel specifies the TIM1 Channel.
    856            *          This parameter can be one of the following values:
    857            *            @arg TIM1_Channel_1: TIM1 Channel1
    858            *            @arg TIM1_Channel_2: TIM1 Channel2
    859            *            @arg TIM1_Channel_3: TIM1 Channel3
    860            *            @arg TIM1_Channel_4: TIM1 Channel4
    861            * @param  TIM1_OCMode specifies the TIM1 Output Compare Mode.
    862            *          This parameter can be one of the following values:
    863            *            @arg TIM1_OCMode_Timing: OC Mode Timing
    864            *            @arg TIM1_OCMode_Active: OC Mode Active
    865            *            @arg TIM1_OCMode_Inactive: OC Mode Inactive
    866            *            @arg TIM1_OCMode_Toggle: OC Mode Toggle
    867            *            @arg TIM1_OCMode_PWM1: OC Mode PWM1
    868            *            @arg TIM1_OCMode_PWM2: OC Mode PWM2  
    869            * @retval None
    870            */

   \                                 In section .far_func.text, align 1
    871          void TIM1_SelectOCxM(TIM1_Channel_TypeDef TIM1_Channel, TIM1_OCMode_TypeDef TIM1_OCMode)
    872          {
    873            /* Check the parameters */
    874            assert_param(IS_TIM1_CHANNEL(TIM1_Channel));
    875            assert_param(IS_TIM1_OCM(TIM1_OCMode));
    876          
    877            if (TIM1_Channel == TIM1_Channel_1)
   \                     TIM1_SelectOCxM:
   \   000000 4D           TNZ       A
   \   000001 26 0F        JRNE      L:??TIM1_SelectOCxM_0
    878            {
    879              /* Disable the Channel 1: Reset the CCE Bit */
    880              TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC1E);
   \   000003 7211 52BD    BRES      L:0x52bd, #0x0
    881          
    882              /* Reset the Output Compare Bits & Set the Output Compare Mode */
    883              TIM1->CCMR1 = (uint8_t)((uint8_t)(TIM1->CCMR1 & (uint8_t)(~TIM1_CCMR_OCM)) | (uint8_t)TIM1_OCMode);
   \   000007 C6 52B9      LD        A, L:0x52b9
   \   00000A A4 8F        AND       A, #0x8f
   \   00000C BA ..        OR        A, S:?b0
   \   00000E C7 52B9      LD        L:0x52b9, A
   \   000011 87           RETF
    884            }
    885            else if (TIM1_Channel == TIM1_Channel_2)
   \                     ??TIM1_SelectOCxM_0:
   \   000012 A1 01        CP        A, #0x1
   \   000014 26 0F        JRNE      L:??TIM1_SelectOCxM_1
    886            {
    887              /* Disable the Channel 2: Reset the CCE Bit */
    888              TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC2E);
   \   000016 7219 52BD    BRES      L:0x52bd, #0x4
    889          
    890              /* Reset the Output Compare Bits & Set the Output Compare Mode */
    891              TIM1->CCMR2 = (uint8_t)((uint8_t)(TIM1->CCMR2 & (uint8_t)(~TIM1_CCMR_OCM)) | (uint8_t)TIM1_OCMode);
   \   00001A C6 52BA      LD        A, L:0x52ba
   \   00001D A4 8F        AND       A, #0x8f
   \   00001F BA ..        OR        A, S:?b0
   \   000021 C7 52BA      LD        L:0x52ba, A
   \   000024 87           RETF
    892            }
    893            else
    894            {
    895              /* Disable the Channel 3: Reset the CCE Bit */
    896              TIM1->CCER2 &= (uint8_t)(~TIM1_CCER2_CC3E);
   \                     ??TIM1_SelectOCxM_1:
   \   000025 7211 52BE    BRES      L:0x52be, #0x0
    897          
    898              /* Reset the Output Compare Bits & Set the Output Compare Mode */
    899              TIM1->CCMR3 = (uint8_t)((uint8_t)(TIM1->CCMR3 & (uint8_t)(~TIM1_CCMR_OCM)) | (uint8_t)TIM1_OCMode);
   \   000029 C6 52BB      LD        A, L:0x52bb
   \   00002C A4 8F        AND       A, #0x8f
   \   00002E BA ..        OR        A, S:?b0
   \   000030 C7 52BB      LD        L:0x52bb, A
    900          
    901            }
    902          }
   \   000033 87           RETF
    903          
    904          /**
    905            * @brief  Sets the TIM1 Capture Compare1 Register value.
    906            * @param  Compare1 specifies the Capture Compare1 register new value.
    907            *          This parameter is between 0x0000 and 0xFFFF.
    908            * @retval None
    909            */

   \                                 In section .far_func.text, align 1
    910          void TIM1_SetCompare1(uint16_t Compare1)
    911          {
   \                     TIM1_SetCompare1:
   \   000000 9093         LDW       Y, X
    912            /* Set the Capture Compare1 Register value */
    913            TIM1->CCR1H = (uint8_t)(Compare1 >> 8);
   \   000002 93           LDW       X, Y
   \   000003 4F           CLR       A
   \   000004 01           RRWA      X, A
   \   000005 9F           LD        A, XL
   \   000006 C7 52C6      LD        L:0x52c6, A
    914            TIM1->CCR1L = (uint8_t)(Compare1);
   \   000009 909F         LD        A, YL
   \   00000B C7 52C7      LD        L:0x52c7, A
    915          
    916          }
   \   00000E 87           RETF
    917          
    918          /**
    919            * @brief  Sets the TIM1 Capture Compare2 Register value.
    920            * @param  Compare2 specifies the Capture Compare2 register new value.
    921            *          This parameter is between 0x0000 and 0xFFFF.
    922            * @retval None
    923            */

   \                                 In section .far_func.text, align 1
    924          void TIM1_SetCompare2(uint16_t Compare2)
    925          {
   \                     TIM1_SetCompare2:
   \   000000 9093         LDW       Y, X
    926            /* Set the Capture Compare2 Register value */
    927            TIM1->CCR2H = (uint8_t)(Compare2 >> 8);
   \   000002 93           LDW       X, Y
   \   000003 4F           CLR       A
   \   000004 01           RRWA      X, A
   \   000005 9F           LD        A, XL
   \   000006 C7 52C8      LD        L:0x52c8, A
    928            TIM1->CCR2L = (uint8_t)(Compare2);
   \   000009 909F         LD        A, YL
   \   00000B C7 52C9      LD        L:0x52c9, A
    929          }
   \   00000E 87           RETF
    930          
    931          /**
    932            * @brief  Sets the TIM1 Capture Compare3 Register value.
    933            * @param  Compare3 specifies the Capture Compare3 register new value.
    934            *          This parameter is between 0x0000 and 0xFFFF.
    935            * @retval None
    936            */

   \                                 In section .far_func.text, align 1
    937          void TIM1_SetCompare3(uint16_t Compare3)
    938          {
   \                     TIM1_SetCompare3:
   \   000000 9093         LDW       Y, X
    939            /* Set the Capture Compare3 Register value */
    940            TIM1->CCR3H = (uint8_t)(Compare3 >> 8);
   \   000002 93           LDW       X, Y
   \   000003 4F           CLR       A
   \   000004 01           RRWA      X, A
   \   000005 9F           LD        A, XL
   \   000006 C7 52CA      LD        L:0x52ca, A
    941            TIM1->CCR3L = (uint8_t)(Compare3);
   \   000009 909F         LD        A, YL
   \   00000B C7 52CB      LD        L:0x52cb, A
    942          }
   \   00000E 87           RETF
    943          
    944          /**
    945            * @brief  Sets the TIM1 Capture Compare4 Register value.
    946            * @param  Compare4 specifies the Capture Compare4 register new value.
    947            *          This parameter is between 0x0000 and 0xFFFF.
    948            * @retval None
    949            */

   \                                 In section .far_func.text, align 1
    950          void TIM1_SetCompare4(uint16_t Compare4)
    951          {
   \                     TIM1_SetCompare4:
   \   000000 9093         LDW       Y, X
    952            /* Set the Capture Compare4 Register value */
    953            TIM1->CCR4H = (uint8_t)(Compare4 >> 8);
   \   000002 93           LDW       X, Y
   \   000003 4F           CLR       A
   \   000004 01           RRWA      X, A
   \   000005 9F           LD        A, XL
   \   000006 C7 52CC      LD        L:0x52cc, A
    954            TIM1->CCR4L = (uint8_t)(Compare4);
   \   000009 909F         LD        A, YL
   \   00000B C7 52CD      LD        L:0x52cd, A
    955          }
   \   00000E 87           RETF
    956          
    957          /**
    958            * @brief  Sets or Resets the TIM1 peripheral Capture Compare Preload Control bit.
    959            * @param  NewState new state of the Capture Compare Preload Control bit.
    960            *          This parameter can be ENABLE or DISABLE.
    961            * @retval None
    962            */

   \                                 In section .far_func.text, align 1
    963          void TIM1_CCPreloadControl(FunctionalState NewState)
    964          {
    965            /* Check the parameters */
    966            assert_param(IS_FUNCTIONAL_STATE(NewState));
    967          
    968            /* Set or Reset the CCPC Bit */
    969            if (NewState != DISABLE)
   \                     TIM1_CCPreloadControl:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM1_CCPreloadControl_0
    970            {
    971              TIM1->CR2 |= TIM1_CR2_CCPC;
   \   000003 7210 52B1    BSET      L:0x52b1, #0x0
   \   000007 87           RETF
    972            }
    973            else
    974            {
    975              TIM1->CR2 &= (uint8_t)(~TIM1_CR2_CCPC);
   \                     ??TIM1_CCPreloadControl_0:
   \   000008 7211 52B1    BRES      L:0x52b1, #0x0
    976            }
    977          }
   \   00000C 87           RETF
    978          
    979          /**
    980            * @brief  Forces the TIM1 Channel1 output waveform to active or inactive level.
    981            * @param  TIM1_ForcedAction specifies the forced Action to be set to the output waveform.
    982            *          This parameter can be one of the following values:
    983            *            @arg TIM1_ForcedAction_Active: Force active level on OC1REF
    984            *            @arg TIM1_ForcedAction_Inactive: Force inactive level on OC1REF.
    985            * @retval None
    986            */

   \                                 In section .far_func.text, align 1
    987          void TIM1_ForcedOC1Config(TIM1_ForcedAction_TypeDef TIM1_ForcedAction)
    988          {
   \                     TIM1_ForcedOC1Config:
   \   000000 B7 ..        LD        S:?b0, A
    989            /* Check the parameters */
    990            assert_param(IS_TIM1_FORCED_ACTION(TIM1_ForcedAction));
    991          
    992            /* Reset the OCM Bits & Configure the Forced output Mode */
    993            TIM1->CCMR1 =  (uint8_t)((uint8_t)(TIM1->CCMR1 & (uint8_t)(~TIM1_CCMR_OCM)) | (uint8_t)TIM1_ForcedAction);
   \   000002 C6 52B9      LD        A, L:0x52b9
   \   000005 A4 8F        AND       A, #0x8f
   \   000007 BA ..        OR        A, S:?b0
   \   000009 C7 52B9      LD        L:0x52b9, A
    994          }
   \   00000C 87           RETF
    995          
    996          /**
    997            * @brief  Forces the TIM1 Channel2 output waveform to active or inactive level.
    998            * @param  TIM1_ForcedAction specifies the forced Action to be set to the output waveform.
    999            *          This parameter can be one of the following values:
   1000            *            @arg TIM1_ForcedAction_Active: Force active level on OC2REF
   1001            *            @arg TIM1_ForcedAction_Inactive: Force inactive level on OC2REF.
   1002            * @retval None
   1003            */

   \                                 In section .far_func.text, align 1
   1004          void TIM1_ForcedOC2Config(TIM1_ForcedAction_TypeDef TIM1_ForcedAction)
   1005          {
   \                     TIM1_ForcedOC2Config:
   \   000000 B7 ..        LD        S:?b0, A
   1006            /* Check the parameters */
   1007            assert_param(IS_TIM1_FORCED_ACTION(TIM1_ForcedAction));
   1008          
   1009            /* Reset the OCM Bits & Configure the Forced output Mode */
   1010            TIM1->CCMR2  =  (uint8_t)((uint8_t)(TIM1->CCMR2 & (uint8_t)(~TIM1_CCMR_OCM)) | (uint8_t)TIM1_ForcedAction);
   \   000002 C6 52BA      LD        A, L:0x52ba
   \   000005 A4 8F        AND       A, #0x8f
   \   000007 BA ..        OR        A, S:?b0
   \   000009 C7 52BA      LD        L:0x52ba, A
   1011          }
   \   00000C 87           RETF
   1012          
   1013          /**
   1014            * @brief  Forces the TIM1 Channel3 output waveform to active or inactive level.
   1015            * @param  TIM1_ForcedAction specifies the forced Action to be set to the output waveform.
   1016            *          This parameter can be one of the following values:
   1017            *            @arg TIM1_ForcedAction_Active: Force active level on OC3REF
   1018            *            @arg TIM1_ForcedAction_Inactive: Force inactive level on OC3REF.
   1019            * @retval None
   1020            */

   \                                 In section .far_func.text, align 1
   1021          void TIM1_ForcedOC3Config(TIM1_ForcedAction_TypeDef TIM1_ForcedAction)
   1022          {
   \                     TIM1_ForcedOC3Config:
   \   000000 B7 ..        LD        S:?b0, A
   1023            /* Check the parameters */
   1024            assert_param(IS_TIM1_FORCED_ACTION(TIM1_ForcedAction));
   1025          
   1026            /* Reset the OCM Bits */ /* Configure The Forced output Mode */
   1027            TIM1->CCMR3 = (uint8_t)((uint8_t)(TIM1->CCMR3 & (uint8_t)(~TIM1_CCMR_OCM)) | (uint8_t)TIM1_ForcedAction);
   \   000002 C6 52BB      LD        A, L:0x52bb
   \   000005 A4 8F        AND       A, #0x8f
   \   000007 BA ..        OR        A, S:?b0
   \   000009 C7 52BB      LD        L:0x52bb, A
   1028          }
   \   00000C 87           RETF
   1029          
   1030          /**
   1031            * @brief  Enables or disables the TIM1 peripheral Preload Register on CCR1.
   1032            * @param  NewState new state of the Capture Compare Preload register.
   1033            *          This parameter can be ENABLE or DISABLE.
   1034            * @retval None
   1035            */

   \                                 In section .far_func.text, align 1
   1036          void TIM1_OC1PreloadConfig(FunctionalState NewState)
   1037          {
   1038            /* Check the parameters */
   1039            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1040          
   1041            /* Set or Reset the OC1PE Bit */
   1042            if (NewState != DISABLE)
   \                     TIM1_OC1PreloadConfig:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM1_OC1PreloadConfig_0
   1043            {
   1044              TIM1->CCMR1 |= TIM1_CCMR_OCxPE;
   \   000003 7216 52B9    BSET      L:0x52b9, #0x3
   \   000007 87           RETF
   1045            }
   1046            else
   1047            {
   1048              TIM1->CCMR1 &= (uint8_t)(~TIM1_CCMR_OCxPE);
   \                     ??TIM1_OC1PreloadConfig_0:
   \   000008 7217 52B9    BRES      L:0x52b9, #0x3
   1049            }
   1050          }
   \   00000C 87           RETF
   1051          
   1052          /**
   1053            * @brief  Enables or disables the TIM1 peripheral Preload Register on CCR2.
   1054            * @param  NewState new state of the Capture Compare Preload register.
   1055            *          This parameter can be ENABLE or DISABLE.
   1056            * @retval None
   1057            */

   \                                 In section .far_func.text, align 1
   1058          void TIM1_OC2PreloadConfig(FunctionalState NewState)
   1059          {
   1060            /* Check the parameters */
   1061            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1062          
   1063            /* Set or Reset the OC2PE Bit */
   1064            if (NewState != DISABLE)
   \                     TIM1_OC2PreloadConfig:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM1_OC2PreloadConfig_0
   1065            {
   1066              TIM1->CCMR2 |= TIM1_CCMR_OCxPE;
   \   000003 7216 52BA    BSET      L:0x52ba, #0x3
   \   000007 87           RETF
   1067            }
   1068            else
   1069            {
   1070              TIM1->CCMR2 &= (uint8_t)(~TIM1_CCMR_OCxPE);
   \                     ??TIM1_OC2PreloadConfig_0:
   \   000008 7217 52BA    BRES      L:0x52ba, #0x3
   1071            }
   1072          }
   \   00000C 87           RETF
   1073          
   1074          /**
   1075            * @brief  Enables or disables the TIM1 peripheral Preload Register on CCR3.
   1076            * @param  NewState new state of the Capture Compare Preload register.
   1077            *          This parameter can be ENABLE or DISABLE.
   1078            * @retval None
   1079            */

   \                                 In section .far_func.text, align 1
   1080          void TIM1_OC3PreloadConfig(FunctionalState NewState)
   1081          {
   1082            /* Check the parameters */
   1083            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1084          
   1085            /* Set or Reset the OC3PE Bit */
   1086            if (NewState != DISABLE)
   \                     TIM1_OC3PreloadConfig:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM1_OC3PreloadConfig_0
   1087            {
   1088              TIM1->CCMR3 |= TIM1_CCMR_OCxPE;
   \   000003 7216 52BB    BSET      L:0x52bb, #0x3
   \   000007 87           RETF
   1089            }
   1090            else
   1091            {
   1092              TIM1->CCMR3 &= (uint8_t)(~TIM1_CCMR_OCxPE);
   \                     ??TIM1_OC3PreloadConfig_0:
   \   000008 7217 52BB    BRES      L:0x52bb, #0x3
   1093            }
   1094          }
   \   00000C 87           RETF
   1095          
   1096          /**
   1097            * @brief  Enables or disables the TIM1 peripheral Preload Register on CCR4.
   1098            * @param  NewState new state of the Capture Compare Preload register.
   1099            *          This parameter can be ENABLE or DISABLE.
   1100            * @retval None
   1101            */

   \                                 In section .far_func.text, align 1
   1102          void TIM1_OC4PreloadConfig(FunctionalState NewState)
   1103          {
   1104            /* Check the parameters */
   1105            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1106          
   1107            /* Set or Reset the OC4PE Bit */
   1108            if (NewState != DISABLE)
   \                     TIM1_OC4PreloadConfig:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM1_OC4PreloadConfig_0
   1109            {
   1110              TIM1->CCMR4 |= TIM1_CCMR_OCxPE;
   \   000003 7216 52BC    BSET      L:0x52bc, #0x3
   \   000007 87           RETF
   1111            }
   1112            else
   1113            {
   1114              TIM1->CCMR4 &= (uint8_t)(~TIM1_CCMR_OCxPE);
   \                     ??TIM1_OC4PreloadConfig_0:
   \   000008 7217 52BC    BRES      L:0x52bc, #0x3
   1115            }
   1116          }
   \   00000C 87           RETF
   1117          
   1118          /**
   1119            * @brief  Configures the TIM1 Capture Compare 1 Fast feature.
   1120            * @param  NewState new state of the Output Compare Fast Enable bit.
   1121            *          This parameter can be ENABLE or DISABLE.
   1122            * @retval None
   1123            */

   \                                 In section .far_func.text, align 1
   1124          void TIM1_OC1FastConfig(FunctionalState NewState)
   1125          {
   1126            /* Check the parameters */
   1127            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1128          
   1129            /* Set or Reset the OC1FE Bit */
   1130            if (NewState != DISABLE)
   \                     TIM1_OC1FastConfig:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM1_OC1FastConfig_0
   1131            {
   1132              TIM1->CCMR1 |= TIM1_CCMR_OCxFE;
   \   000003 7214 52B9    BSET      L:0x52b9, #0x2
   \   000007 87           RETF
   1133            }
   1134            else
   1135            {
   1136              TIM1->CCMR1 &= (uint8_t)(~TIM1_CCMR_OCxFE);
   \                     ??TIM1_OC1FastConfig_0:
   \   000008 7215 52B9    BRES      L:0x52b9, #0x2
   1137            }
   1138          }
   \   00000C 87           RETF
   1139          
   1140          /**
   1141            * @brief  Configures the TIM1 Capture Compare 2 Fast feature.
   1142            * @param  NewState new state of the Output Compare Fast Enable bit.
   1143            *          This parameter can be ENABLE or DISABLE.
   1144            * @retval None
   1145            */

   \                                 In section .far_func.text, align 1
   1146          void TIM1_OC2FastConfig(FunctionalState NewState)
   1147          {
   1148            /* Check the parameters */
   1149            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1150          
   1151            /* Set or Reset the OC2FE Bit */
   1152            if (NewState != DISABLE)
   \                     TIM1_OC2FastConfig:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM1_OC2FastConfig_0
   1153            {
   1154              TIM1->CCMR2 |= TIM1_CCMR_OCxFE;
   \   000003 7214 52BA    BSET      L:0x52ba, #0x2
   \   000007 87           RETF
   1155            }
   1156            else
   1157            {
   1158              TIM1->CCMR2 &= (uint8_t)(~TIM1_CCMR_OCxFE);
   \                     ??TIM1_OC2FastConfig_0:
   \   000008 7215 52BA    BRES      L:0x52ba, #0x2
   1159            }
   1160          }
   \   00000C 87           RETF
   1161          
   1162          /**
   1163            * @brief  Configures the TIM1 Capture Compare 3 Fast feature.
   1164            * @param  NewState new state of the Output Compare Fast Enable bit.
   1165            *          This parameter can be ENABLE or DISABLE.
   1166            * @retval None
   1167            */

   \                                 In section .far_func.text, align 1
   1168          void TIM1_OC3FastConfig(FunctionalState NewState)
   1169          {
   1170            /* Check the parameters */
   1171            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1172          
   1173            /* Set or Reset the OC3FE Bit */
   1174            if (NewState != DISABLE)
   \                     TIM1_OC3FastConfig:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM1_OC3FastConfig_0
   1175            {
   1176              TIM1->CCMR3 |= TIM1_CCMR_OCxFE;
   \   000003 7214 52BB    BSET      L:0x52bb, #0x2
   \   000007 87           RETF
   1177            }
   1178            else
   1179            {
   1180              TIM1->CCMR3 &= (uint8_t)(~TIM1_CCMR_OCxFE);
   \                     ??TIM1_OC3FastConfig_0:
   \   000008 7215 52BB    BRES      L:0x52bb, #0x2
   1181            }
   1182          }
   \   00000C 87           RETF
   1183          
   1184          /**
   1185            * @brief   Clears or safeguards the OC1REF signal.
   1186            * @param  NewState new state of the Output Compare 1 Clear Enable bit.
   1187            *          This parameter can be ENABLE or DISABLE.
   1188            * @retval None
   1189            */

   \                                 In section .far_func.text, align 1
   1190          void TIM1_ClearOC1Ref(FunctionalState NewState)
   1191          {
   1192            /* Check the parameters */
   1193            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1194          
   1195            /* Set or Reset the OC1CE Bit */
   1196            if (NewState != DISABLE)
   \                     TIM1_ClearOC1Ref:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM1_ClearOC1Ref_0
   1197            {
   1198              TIM1->CCMR1 |= TIM1_CCMR_OCxCE;
   \   000003 721E 52B9    BSET      L:0x52b9, #0x7
   \   000007 87           RETF
   1199            }
   1200            else
   1201            {
   1202              TIM1->CCMR1 &= (uint8_t)(~TIM1_CCMR_OCxCE);
   \                     ??TIM1_ClearOC1Ref_0:
   \   000008 721F 52B9    BRES      L:0x52b9, #0x7
   1203            }
   1204          }
   \   00000C 87           RETF
   1205          
   1206          /**
   1207            * @brief  Clears or safeguards the OC2REF signal.
   1208            * @param  NewState new state of the Output Compare 2 Clear Enable bit.
   1209            *          This parameter can be ENABLE or DISABLE.
   1210            * @retval None
   1211            */

   \                                 In section .far_func.text, align 1
   1212          void TIM1_ClearOC2Ref(FunctionalState NewState)
   1213          {
   1214            /* Check the parameters */
   1215            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1216          
   1217            /* Set or Reset the OC2CE Bit */
   1218            if (NewState != DISABLE)
   \                     TIM1_ClearOC2Ref:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM1_ClearOC2Ref_0
   1219            {
   1220              TIM1->CCMR2 |= TIM1_CCMR_OCxCE;
   \   000003 721E 52BA    BSET      L:0x52ba, #0x7
   \   000007 87           RETF
   1221            }
   1222            else
   1223            {
   1224              TIM1->CCMR2 &= (uint8_t)(~TIM1_CCMR_OCxCE);
   \                     ??TIM1_ClearOC2Ref_0:
   \   000008 721F 52BA    BRES      L:0x52ba, #0x7
   1225            }
   1226          }
   \   00000C 87           RETF
   1227          
   1228          /**
   1229            * @brief  Clears or safeguards the OC3REF signal.
   1230            * @param  NewState new state of the Output Compare 3 Clear Enable bit.
   1231            *          This parameter can be ENABLE or DISABLE.
   1232            * @retval None
   1233            */

   \                                 In section .far_func.text, align 1
   1234          void TIM1_ClearOC3Ref(FunctionalState NewState)
   1235          {
   1236            /* Check the parameters */
   1237            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1238          
   1239            /* Set or Reset the OC3CE Bit */
   1240            if (NewState != DISABLE)
   \                     TIM1_ClearOC3Ref:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM1_ClearOC3Ref_0
   1241            {
   1242              TIM1->CCMR3 |= TIM1_CCMR_OCxCE;
   \   000003 721E 52BB    BSET      L:0x52bb, #0x7
   \   000007 87           RETF
   1243            }
   1244            else
   1245            {
   1246              TIM1->CCMR3 &= (uint8_t)(~TIM1_CCMR_OCxCE);
   \                     ??TIM1_ClearOC3Ref_0:
   \   000008 721F 52BB    BRES      L:0x52bb, #0x7
   1247            }
   1248          }
   \   00000C 87           RETF
   1249          
   1250          /**
   1251            * @brief  Clears or safeguards the OC4REF signal.
   1252            * @param  NewState new state of the Output Compare 4 Clear Enable bit.
   1253            *          This parameter can be ENABLE or DISABLE.
   1254            * @retval None
   1255            */

   \                                 In section .far_func.text, align 1
   1256          void TIM1_ClearOC4Ref(FunctionalState NewState)
   1257          {
   1258            /* Check the parameters */
   1259            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1260          
   1261            /* Set or Reset the OC4CE Bit */
   1262            if (NewState != DISABLE)
   \                     TIM1_ClearOC4Ref:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM1_ClearOC4Ref_0
   1263            {
   1264              TIM1->CCMR4 |= TIM1_CCMR_OCxCE;
   \   000003 721E 52BC    BSET      L:0x52bc, #0x7
   \   000007 87           RETF
   1265            }
   1266            else
   1267            {
   1268              TIM1->CCMR4 &= (uint8_t)(~TIM1_CCMR_OCxCE);
   \                     ??TIM1_ClearOC4Ref_0:
   \   000008 721F 52BC    BRES      L:0x52bc, #0x7
   1269            }
   1270          }
   \   00000C 87           RETF
   1271          
   1272          /**
   1273            * @brief  Configures the TIM1 Channel 1 polarity.
   1274            * @param  TIM1_OCPolarity specifies the OC1 Polarity.
   1275            *          This parameter can be one of the following values:
   1276            *            @arg TIM1_OCPolarity_High: Output Compare active low
   1277            *            @arg TIM1_OCPolarity_Low: Output Compare active high
   1278            * @retval None
   1279            */

   \                                 In section .far_func.text, align 1
   1280          void TIM1_OC1PolarityConfig(TIM1_OCPolarity_TypeDef TIM1_OCPolarity)
   1281          {
   1282            /* Check the parameters */
   1283            assert_param(IS_TIM1_OC_POLARITY(TIM1_OCPolarity));
   1284          
   1285            /* Set or Reset the CC1P Bit */
   1286            if (TIM1_OCPolarity != TIM1_OCPolarity_High)
   \                     TIM1_OC1PolarityConfig:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM1_OC1PolarityConfig_0
   1287            {
   1288              TIM1->CCER1 |= TIM1_CCER1_CC1P;
   \   000003 7212 52BD    BSET      L:0x52bd, #0x1
   \   000007 87           RETF
   1289            }
   1290            else
   1291            {
   1292              TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC1P);
   \                     ??TIM1_OC1PolarityConfig_0:
   \   000008 7213 52BD    BRES      L:0x52bd, #0x1
   1293            }
   1294          }
   \   00000C 87           RETF
   1295          
   1296          /**
   1297            * @brief  Configures the TIM1 Channel 1N polarity.
   1298            * @param  TIM1_OCNPolarity specifies the OC1N Polarity.
   1299            *          This parameter can be one of the following values:
   1300            *            @arg TIM1_OCNPolarity_High: Complementary Output Compare active low
   1301            *            @arg TIM1_OCNPolarity_Low: Complementary Output Compare active high
   1302            * @retval None
   1303            */

   \                                 In section .far_func.text, align 1
   1304          void TIM1_OC1NPolarityConfig(TIM1_OCNPolarity_TypeDef TIM1_OCNPolarity)
   1305          {
   1306            /* Check the parameters */
   1307            assert_param(IS_TIM1_OCN_POLARITY(TIM1_OCNPolarity));
   1308          
   1309            /* Set or Reset the CC3P Bit */
   1310            if (TIM1_OCNPolarity != TIM1_OCNPolarity_High)
   \                     TIM1_OC1NPolarityConfig:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM1_OC1NPolarityConfig_0
   1311            {
   1312              TIM1->CCER1 |= TIM1_CCER1_CC1NP;
   \   000003 7216 52BD    BSET      L:0x52bd, #0x3
   \   000007 87           RETF
   1313            }
   1314            else
   1315            {
   1316              TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC1NP);
   \                     ??TIM1_OC1NPolarityConfig_0:
   \   000008 7217 52BD    BRES      L:0x52bd, #0x3
   1317            }
   1318          }
   \   00000C 87           RETF
   1319          
   1320          /**
   1321            * @brief  Configures the TIM1 Channel 2 polarity.
   1322            * @param  TIM1_OCPolarity specifies the OC2 Polarity.
   1323            *          This parameter can be one of the following values:
   1324            *            @arg TIM1_OCPolarity_High: Output Compare active low
   1325            *            @arg TIM1_OCPolarity_Low: Output Compare active high
   1326            * @retval None
   1327            */

   \                                 In section .far_func.text, align 1
   1328          void TIM1_OC2PolarityConfig(TIM1_OCPolarity_TypeDef TIM1_OCPolarity)
   1329          {
   1330            /* Check the parameters */
   1331            assert_param(IS_TIM1_OC_POLARITY(TIM1_OCPolarity));
   1332          
   1333            /* Set or Reset the CC2P Bit */
   1334            if (TIM1_OCPolarity != TIM1_OCPolarity_High)
   \                     TIM1_OC2PolarityConfig:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM1_OC2PolarityConfig_0
   1335            {
   1336              TIM1->CCER1 |= TIM1_CCER1_CC2P;
   \   000003 721A 52BD    BSET      L:0x52bd, #0x5
   \   000007 87           RETF
   1337            }
   1338            else
   1339            {
   1340              TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC2P);
   \                     ??TIM1_OC2PolarityConfig_0:
   \   000008 721B 52BD    BRES      L:0x52bd, #0x5
   1341            }
   1342          }
   \   00000C 87           RETF
   1343          
   1344          /**
   1345            * @brief  Configures the TIM1 Channel 2N polarity.
   1346            * @param  TIM1_OCNPolarity specifies the OC2N Polarity.
   1347            *          This parameter can be one of the following values:
   1348            *            @arg TIM1_OCNPolarity_High: Complementary Output Compare active low
   1349            *            @arg TIM1_OCNPolarity_Low: Complementary Output Compare active high
   1350            * @retval None
   1351            */

   \                                 In section .far_func.text, align 1
   1352          void TIM1_OC2NPolarityConfig(TIM1_OCNPolarity_TypeDef TIM1_OCNPolarity)
   1353          {
   1354            /* Check the parameters */
   1355            assert_param(IS_TIM1_OCN_POLARITY(TIM1_OCNPolarity));
   1356          
   1357            /* Set or Reset the CC3P Bit */
   1358            if (TIM1_OCNPolarity != TIM1_OCNPolarity_High)
   \                     TIM1_OC2NPolarityConfig:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM1_OC2NPolarityConfig_0
   1359            {
   1360              TIM1->CCER1 |= TIM1_CCER1_CC2NP;
   \   000003 721E 52BD    BSET      L:0x52bd, #0x7
   \   000007 87           RETF
   1361            }
   1362            else
   1363            {
   1364              TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC2NP);
   \                     ??TIM1_OC2NPolarityConfig_0:
   \   000008 721F 52BD    BRES      L:0x52bd, #0x7
   1365            }
   1366          }
   \   00000C 87           RETF
   1367          
   1368          /**
   1369            * @brief  Configures the TIM1 Channel 3 polarity.
   1370            * @param  TIM1_OCPolarity specifies the OC3 Polarity.
   1371            *          This parameter can be one of the following values:
   1372            *            @arg TIM1_OCPolarity_High: Output Compare active low
   1373            *            @arg TIM1_OCPolarity_Low: Output Compare active high
   1374            * @retval None
   1375            */

   \                                 In section .far_func.text, align 1
   1376          void TIM1_OC3PolarityConfig(TIM1_OCPolarity_TypeDef TIM1_OCPolarity)
   1377          {
   1378            /* Check the parameters */
   1379            assert_param(IS_TIM1_OC_POLARITY(TIM1_OCPolarity));
   1380          
   1381            /* Set or Reset the CC3P Bit */
   1382            if (TIM1_OCPolarity != TIM1_OCPolarity_High)
   \                     TIM1_OC3PolarityConfig:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM1_OC3PolarityConfig_0
   1383            {
   1384              TIM1->CCER2 |= TIM1_CCER2_CC3P;
   \   000003 7212 52BE    BSET      L:0x52be, #0x1
   \   000007 87           RETF
   1385            }
   1386            else
   1387            {
   1388              TIM1->CCER2 &= (uint8_t)(~TIM1_CCER2_CC3P);
   \                     ??TIM1_OC3PolarityConfig_0:
   \   000008 7213 52BE    BRES      L:0x52be, #0x1
   1389            }
   1390          }
   \   00000C 87           RETF
   1391          
   1392          /**
   1393            * @brief  Configures the TIM1 Channel 3N polarity.
   1394            * @param  TIM1_OCNPolarity specifies the OC3N Polarity.
   1395            *          This parameter can be one of the following values:
   1396            *            @arg TIM1_OCNPolarity_High: Complementary Output Compare active low
   1397            *            @arg TIM1_OCNPolarity_Low: Complementary Output Compare active high
   1398            * @retval None
   1399            */

   \                                 In section .far_func.text, align 1
   1400          void TIM1_OC3NPolarityConfig(TIM1_OCNPolarity_TypeDef TIM1_OCNPolarity)
   1401          {
   1402            /* Check the parameters */
   1403            assert_param(IS_TIM1_OCN_POLARITY(TIM1_OCNPolarity));
   1404          
   1405            /* Set or Reset the CC3P Bit */
   1406            if (TIM1_OCNPolarity != TIM1_OCNPolarity_High)
   \                     TIM1_OC3NPolarityConfig:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM1_OC3NPolarityConfig_0
   1407            {
   1408              TIM1->CCER2 |= TIM1_CCER2_CC3NP;
   \   000003 7216 52BE    BSET      L:0x52be, #0x3
   \   000007 87           RETF
   1409            }
   1410            else
   1411            {
   1412              TIM1->CCER2 &= (uint8_t)(~TIM1_CCER2_CC3NP);
   \                     ??TIM1_OC3NPolarityConfig_0:
   \   000008 7217 52BE    BRES      L:0x52be, #0x3
   1413            }
   1414          }
   \   00000C 87           RETF
   1415          
   1416          /**
   1417            * @brief  Selects the OCReference Clear source.
   1418            * @param  TIM1_OCReferenceClear: specifies the OCReference Clear source.
   1419            *          This parameter can be one of the following values:
   1420            *            @arg TIM1_OCReferenceClear_ETRF: OCReference Clear source ETR
   1421            *            @arg TIM1_OCReferenceClear_OCREFCLR: OCReference Clear source OCREF 
   1422            * @retval None
   1423            */

   \                                 In section .far_func.text, align 1
   1424          void TIM1_SelectOCREFClear(TIM1_OCReferenceClear_TypeDef TIM1_OCReferenceClear)
   1425          {
   1426            /* Check the parameters */
   1427            assert_param(IS_TIM1_OCREFERENCECECLEAR_SOURCE(TIM1_OCReferenceClear));
   1428          
   1429            /* Set the TIM1_OCReferenceClear source */
   1430            TIM1->SMCR &=  (uint8_t) (~TIM1_SMCR_OCCS);
   \                     TIM1_SelectOCREFClear:
   \   000000 7217 52B2    BRES      L:0x52b2, #0x3
   1431            TIM1->SMCR |=  (uint8_t) TIM1_OCReferenceClear;
   \   000004 CA 52B2      OR        A, L:0x52b2
   \   000007 C7 52B2      LD        L:0x52b2, A
   1432          }
   \   00000A 87           RETF
   1433          
   1434          /**
   1435            * @brief  Selects the TIM1 peripheral Commutation event.
   1436            * @param  NewState new state of the Commutation event.
   1437            *          This parameter can be ENABLE or DISABLE.
   1438            * @retval None
   1439            */

   \                                 In section .far_func.text, align 1
   1440          void TIM1_SelectCOM(FunctionalState NewState)
   1441          {
   1442            /* Check the parameters */
   1443            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1444          
   1445            /* Set or Reset the CCUS Bit */
   1446            if (NewState != DISABLE)
   \                     TIM1_SelectCOM:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM1_SelectCOM_0
   1447            {
   1448              TIM1->CR2 |= TIM1_CR2_CCUS;
   \   000003 7214 52B1    BSET      L:0x52b1, #0x2
   \   000007 87           RETF
   1449            }
   1450            else
   1451            {
   1452              TIM1->CR2 &= (uint8_t)(~TIM1_CR2_CCUS);
   \                     ??TIM1_SelectCOM_0:
   \   000008 7215 52B1    BRES      L:0x52b1, #0x2
   1453            }
   1454          }
   \   00000C 87           RETF
   1455          
   1456          /**
   1457            * @brief  Enables or disables the TIM1 Capture Compare Channel x (x=1,..,4).
   1458            * @param  TIM1_Channel specifies the TIM1 Channel.
   1459            *          This parameter can be one of the following values:
   1460            *            @arg TIM1_Channel_1: TIM1 Channel1
   1461            *            @arg TIM1_Channel_2: TIM1 Channel2
   1462            *            @arg TIM1_Channel_3: TIM1 Channel3
   1463            *            @arg TIM1_CHANNEL_4: TIM1 Channel4
   1464            * @param  NewState specifies the TIM1 Channel CCxE bit new state.
   1465            *          This parameter can be: ENABLE or DISABLE.
   1466            * @retval None
   1467            */

   \                                 In section .far_func.text, align 1
   1468          void TIM1_CCxCmd(TIM1_Channel_TypeDef TIM1_Channel, FunctionalState NewState)
   1469          {
   1470            /* Check the parameters */
   1471            assert_param(IS_TIM1_CHANNEL(TIM1_Channel));
   1472            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1473          
   1474            if (TIM1_Channel == TIM1_Channel_1)
   \                     TIM1_CCxCmd:
   \   000000 4D           TNZ       A
   \   000001 26 0E        JRNE      L:??TIM1_CCxCmd_0
   1475            {
   1476              /* Set or Reset the CC1E Bit */
   1477              if (NewState != DISABLE)
   \   000003 3D ..        TNZ       S:?b0
   \   000005 27 05        JREQ      L:??TIM1_CCxCmd_1
   1478              {
   1479                TIM1->CCER1 |= TIM1_CCER1_CC1E;
   \   000007 7210 52BD    BSET      L:0x52bd, #0x0
   \   00000B 87           RETF
   1480              }
   1481              else
   1482              {
   1483                TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC1E);
   \                     ??TIM1_CCxCmd_1:
   \   00000C 7211 52BD    BRES      L:0x52bd, #0x0
   \   000010 87           RETF
   1484              }
   1485            }
   1486            else if (TIM1_Channel == TIM1_Channel_2)
   \                     ??TIM1_CCxCmd_0:
   \   000011 A1 01        CP        A, #0x1
   \   000013 26 0E        JRNE      L:??TIM1_CCxCmd_2
   1487            {
   1488              /* Set or Reset the CC2E Bit */
   1489              if (NewState != DISABLE)
   \   000015 3D ..        TNZ       S:?b0
   \   000017 27 05        JREQ      L:??TIM1_CCxCmd_3
   1490              {
   1491                TIM1->CCER1 |= TIM1_CCER1_CC2E;
   \   000019 7218 52BD    BSET      L:0x52bd, #0x4
   \   00001D 87           RETF
   1492              }
   1493              else
   1494              {
   1495                TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC2E);
   \                     ??TIM1_CCxCmd_3:
   \   00001E 7219 52BD    BRES      L:0x52bd, #0x4
   \   000022 87           RETF
   1496              }
   1497            }
   1498            else if (TIM1_Channel == TIM1_Channel_3)
   \                     ??TIM1_CCxCmd_2:
   \   000023 A1 02        CP        A, #0x2
   \   000025 26 0E        JRNE      L:??TIM1_CCxCmd_4
   1499            {
   1500              /* Set or Reset the CC3E Bit */
   1501              if (NewState != DISABLE)
   \   000027 3D ..        TNZ       S:?b0
   \   000029 27 05        JREQ      L:??TIM1_CCxCmd_5
   1502              {
   1503                TIM1->CCER2 |= TIM1_CCER2_CC3E;
   \   00002B 7210 52BE    BSET      L:0x52be, #0x0
   \   00002F 87           RETF
   1504              }
   1505              else
   1506              {
   1507                TIM1->CCER2 &= (uint8_t)(~TIM1_CCER2_CC3E);
   \                     ??TIM1_CCxCmd_5:
   \   000030 7211 52BE    BRES      L:0x52be, #0x0
   \   000034 87           RETF
   1508              }
   1509            }
   1510            else
   1511            {
   1512              /* Set or Reset the CC4E Bit */
   1513              if (NewState != DISABLE)
   \                     ??TIM1_CCxCmd_4:
   \   000035 3D ..        TNZ       S:?b0
   \   000037 27 05        JREQ      L:??TIM1_CCxCmd_6
   1514              {
   1515                TIM1->CCER2 |= TIM1_CCER2_CC4E;
   \   000039 7218 52BE    BSET      L:0x52be, #0x4
   \   00003D 87           RETF
   1516              }
   1517              else
   1518              {
   1519                TIM1->CCER2 &= (uint8_t)(~TIM1_CCER2_CC4E);
   \                     ??TIM1_CCxCmd_6:
   \   00003E 7219 52BE    BRES      L:0x52be, #0x4
   1520              }
   1521            }
   1522          }
   \   000042 87           RETF
   1523          
   1524          /**
   1525            * @brief  Enables or disables the TIM1 Capture Compare Channel xN (xN=1,..,3).
   1526            * @param  TIM1_Channel specifies the TIM1 Channel.
   1527            *          This parameter can be one of the following values:
   1528            *            @arg TIM1_Channel_1: TIM1 Channel1
   1529            *            @arg TIM1_Channel_2: TIM1 Channel2
   1530            *            @arg TIM1_Channel_3: TIM1 Channel3
   1531            * @param  NewState specifies the TIM1 Channel CCxNE bit new state.
   1532            *          This parameter can be: ENABLE or DISABLE.
   1533            * @retval None
   1534            */

   \                                 In section .far_func.text, align 1
   1535          void TIM1_CCxNCmd(TIM1_Channel_TypeDef TIM1_Channel, FunctionalState NewState)
   1536          {
   1537            /* Check the parameters */
   1538            assert_param(IS_TIM1_COMPLEMENTARY_CHANNEL(TIM1_Channel));
   1539            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1540          
   1541            if (TIM1_Channel == TIM1_Channel_1)
   \                     TIM1_CCxNCmd:
   \   000000 4D           TNZ       A
   \   000001 26 0E        JRNE      L:??TIM1_CCxNCmd_0
   1542            {
   1543              /* Set or Reset the CC1NE Bit */
   1544              if (NewState != DISABLE)
   \   000003 3D ..        TNZ       S:?b0
   \   000005 27 05        JREQ      L:??TIM1_CCxNCmd_1
   1545              {
   1546                TIM1->CCER1 |= TIM1_CCER1_CC1NE;
   \   000007 7214 52BD    BSET      L:0x52bd, #0x2
   \   00000B 87           RETF
   1547              }
   1548              else
   1549              {
   1550                TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC1NE);
   \                     ??TIM1_CCxNCmd_1:
   \   00000C 7215 52BD    BRES      L:0x52bd, #0x2
   \   000010 87           RETF
   1551              }
   1552            }
   1553            else if (TIM1_Channel == TIM1_Channel_2)
   \                     ??TIM1_CCxNCmd_0:
   \   000011 A1 01        CP        A, #0x1
   \   000013 26 0E        JRNE      L:??TIM1_CCxNCmd_2
   1554            {
   1555              /* Set or Reset the CC2NE Bit */
   1556              if (NewState != DISABLE)
   \   000015 3D ..        TNZ       S:?b0
   \   000017 27 05        JREQ      L:??TIM1_CCxNCmd_3
   1557              {
   1558                TIM1->CCER1 |= TIM1_CCER1_CC2NE;
   \   000019 721C 52BD    BSET      L:0x52bd, #0x6
   \   00001D 87           RETF
   1559              }
   1560              else
   1561              {
   1562                TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC2NE);
   \                     ??TIM1_CCxNCmd_3:
   \   00001E 721D 52BD    BRES      L:0x52bd, #0x6
   \   000022 87           RETF
   1563              }
   1564            }
   1565            else
   1566            {
   1567              /* Set or Reset the CC3NE Bit */
   1568              if (NewState != DISABLE)
   \                     ??TIM1_CCxNCmd_2:
   \   000023 3D ..        TNZ       S:?b0
   \   000025 27 05        JREQ      L:??TIM1_CCxNCmd_4
   1569              {
   1570                TIM1->CCER2 |= TIM1_CCER2_CC3NE;
   \   000027 7214 52BE    BSET      L:0x52be, #0x2
   \   00002B 87           RETF
   1571              }
   1572              else
   1573              {
   1574                TIM1->CCER2 &= (uint8_t)(~TIM1_CCER2_CC3NE);
   \                     ??TIM1_CCxNCmd_4:
   \   00002C 7215 52BE    BRES      L:0x52be, #0x2
   1575              }
   1576            }
   1577          }
   \   000030 87           RETF
   1578          
   1579          /**
   1580            * @}
   1581            */
   1582          
   1583          /** @defgroup TIM1_Group3 Input Capture management functions
   1584           *  @brief    Input Capture management functions 
   1585           *
   1586          @verbatim   
   1587           ===============================================================================
   1588                                Input Capture management functions
   1589           ===============================================================================  
   1590             
   1591                 ===================================================================      
   1592                        TIM1 Driver: how to use it in Input Capture Mode
   1593                 =================================================================== 
   1594                 To use the Timer in Input Capture mode, the following steps are mandatory:
   1595                 
   1596                 1. Enable TIM1 clock using CLK_PeripheralClockConfig(CLK_Peripheral_TIM1, ENABLE) function.
   1597                 
   1598                 2. Configure the TIM1 pins in input mode by configuring the corresponding GPIO pins
   1599                 
   1600                 3. Configure the Time base unit as described in the first part of this driver, if needed,
   1601                    otherwise the Timer will run with the default configuration:
   1602                    - Autoreload value = 0xFFFF
   1603                    - Prescaler value = 0x0000
   1604                    - Counter mode = Up counting
   1605                 
   1606                 4. Call TIM1_ICInit() to configure the desired channel to measure only 
   1607                    frequency or duty cycle of the input signal using the corresponding configuration: 
   1608                    - TIM1 Channel: TIM1_Channel
   1609                    - TIM1 Input Capture polarity: TIM1_ICPolarity
   1610                    - TIM1 Input Capture selection: TIM1_ICSelection
   1611                    - TIM1 Input Capture Prescaler: TIM1_ICPSC
   1612                    - TIM1 Input Capture filter value
   1613                    or,
   1614                    Call TIM1_PWMIConfig() to configure the desired channels with the 
   1615                    corresponding configuration and to measure the frequency and the duty
   1616                    cycle of the input signal.
   1617                    
   1618                 5. Enable global interrupts or the DMA to read the measured frequency. 
   1619                    
   1620                 6. Enable the corresponding interrupt (or DMA request) to read the captured value,
   1621                    using the function TIM1_ITConfig(TIM1_IT_CCx) (or TIM1_DMACmd(TIM1_DMASource_CCx))
   1622                 
   1623                 7. Call the TIM1_Cmd(ENABLE) function to enable the TIM1 counter.
   1624                 
   1625                 8. Use TIM1_GetCapturex() to read the captured value corresponding to
   1626                    channel x.
   1627                 
   1628                 Note1: All other functions can be used separately to modify, if needed,
   1629                    a specific feature of the Timer. 
   1630          
   1631          @endverbatim
   1632            * @{
   1633            */
   1634          
   1635          /**
   1636            * @brief  Initializes the TIM1 peripheral according to the specified parameters.
   1637            * @param  TIM1_Channel specifies the input capture channel
   1638            *          This parameter can be one of the following values:
   1639            *            @arg TIM1_Channel_1: TIM1 Channel1
   1640            *            @arg TIM1_Channel_2: TIM1 Channel2
   1641            *            @arg TIM1_Channel_3: TIM1 Channel3
   1642            *            @arg TIM1_Channel_4: TIM1 Channel4
   1643            * @param  TIM1_ICPolarity specifies the Input capture polarity
   1644            *          This parameter can be one of the following values:
   1645            *            @arg TIM1_ICPolarity_Rising: Input capture polarity rising
   1646            *            @arg TIM1_ICPolarity_Falling: Input capture polarity falling
   1647            * @param  TIM1_ICSelection specifies the Input capture source selection
   1648            *          This parameter can be one of the following values:
   1649            *            @arg TIM1_ICSelection_DirectTI: TIM1 Input x is selected to be connected to ICx.
   1650            *            @arg TIM1_ICSelection_IndirectTI: TIM1 Input x is selected to be connected to ICy.
   1651            *            @arg TIM1_ICSelection_TRGI: TIM1 Input x is selected to be connected to the TRGI   
   1652            * @param  TIM1_ICPrescaler specifies the Input capture Prescaler
   1653            *          This parameter can be one of the following values:
   1654            *            @arg TIM1_ICPSC_DIV1: Input Capture Prescaler = 1 (one capture every 1 event)
   1655            *            @arg TIM1_ICPSC_DIV2: Input Capture Prescaler = 2 (one capture every 2 events)
   1656            *            @arg TIM1_ICPSC_DIV4: Input Capture Prescaler = 4 (one capture every 4 events)
   1657            *            @arg TIM1_ICPSC_DIV8: Input Capture Prescaler = 8 (one capture every 8 events)   
   1658            * @param  TIM1_ICFilter specifies the Input capture filter value.
   1659            * @note   If the channel 3 is selected the TIM1_ICSelection_IndirectTI parameter is forbidden.
   1660            * @note   If the channel 4 is selected the TIM1_ICSelection_DirectTI parameter is forbidden.
   1661            * @retval None
   1662            */
   1663          

   \                                 In section .far_func.text, align 1
   1664          void TIM1_ICInit(TIM1_Channel_TypeDef TIM1_Channel,
   1665                           TIM1_ICPolarity_TypeDef TIM1_ICPolarity,
   1666                           TIM1_ICSelection_TypeDef TIM1_ICSelection,
   1667                           TIM1_ICPSC_TypeDef TIM1_ICPrescaler,
   1668                           uint8_t TIM1_ICFilter)
   1669          {
   \                     TIM1_ICInit:
   \   000000 45 .. ..     MOV       S:?b4, S:?b0
   \   000003 45 .. ..     MOV       S:?b0, S:?b1
   \   000006 45 .. ..     MOV       S:?b5, S:?b2
   \   000009 45 .. ..     MOV       S:?b1, S:?b3
   1670          
   1671            /* Check the parameters */
   1672            assert_param(IS_TIM1_CHANNEL(TIM1_Channel));
   1673            assert_param(IS_TIM1_IC_POLARITY(TIM1_ICPolarity));
   1674            assert_param(IS_TIM1_IC_SELECTION(TIM1_ICSelection));
   1675            assert_param(IS_TIM1_IC_PRESCALER(TIM1_ICPrescaler));
   1676            assert_param(IS_TIM1_IC_FILTER(TIM1_ICFilter));
   1677          
   1678            if (TIM1_Channel == TIM1_Channel_1)
   \   00000C 4D           TNZ       A
   \   00000D 26 0C        JRNE      L:??TIM1_ICInit_0
   1679            {
   1680              /* TI1 Configuration */
   1681              TI1_Config(TIM1_ICPolarity, TIM1_ICSelection, TIM1_ICFilter);
   \   00000F B6 ..        LD        A, S:?b4
   \   000011 8D ......    CALLF     TI1_Config
   1682              /* Set the Input Capture Prescaler value */
   1683              TIM1_SetIC1Prescaler(TIM1_ICPrescaler);
   \   000015 B6 ..        LD        A, S:?b5
   \   000017 AC ......    JPF       TIM1_SetIC1Prescaler
   1684            }
   1685            else if (TIM1_Channel == TIM1_Channel_2)
   \                     ??TIM1_ICInit_0:
   \   00001B A1 01        CP        A, #0x1
   \   00001D 26 0C        JRNE      L:??TIM1_ICInit_1
   1686            {
   1687              /* TI2 Configuration */
   1688              TI2_Config(TIM1_ICPolarity, TIM1_ICSelection, TIM1_ICFilter);
   \   00001F B6 ..        LD        A, S:?b4
   \   000021 8D ......    CALLF     TI2_Config
   1689              /* Set the Input Capture Prescaler value */
   1690              TIM1_SetIC2Prescaler(TIM1_ICPrescaler);
   \   000025 B6 ..        LD        A, S:?b5
   \   000027 AC ......    JPF       TIM1_SetIC2Prescaler
   1691            }
   1692            else if (TIM1_Channel == TIM1_Channel_3)
   \                     ??TIM1_ICInit_1:
   \   00002B A1 02        CP        A, #0x2
   \   00002D 26 0C        JRNE      L:??TIM1_ICInit_2
   1693            {
   1694              /* TI3 Configuration */
   1695              TI3_Config(TIM1_ICPolarity, TIM1_ICSelection, TIM1_ICFilter);
   \   00002F B6 ..        LD        A, S:?b4
   \   000031 8D ......    CALLF     TI3_Config
   1696              /* Set the Input Capture Prescaler value */
   1697              TIM1_SetIC3Prescaler(TIM1_ICPrescaler);
   \   000035 B6 ..        LD        A, S:?b5
   \   000037 AC ......    JPF       TIM1_SetIC3Prescaler
   1698            }
   1699            else
   1700            {
   1701              /* TI4 Configuration */
   1702              TI4_Config(TIM1_ICPolarity, TIM1_ICSelection, TIM1_ICFilter);
   \                     ??TIM1_ICInit_2:
   \   00003B B6 ..        LD        A, S:?b4
   \   00003D 8D ......    CALLF     TI4_Config
   1703              /* Set the Input Capture Prescaler value */
   1704              TIM1_SetIC4Prescaler(TIM1_ICPrescaler);
   \   000041 B6 ..        LD        A, S:?b5
   \   000043 AC ......    JPF       TIM1_SetIC4Prescaler
   1705            }
   1706          }
   1707          
   1708          /**
   1709            * @brief  Configures the TIM1 peripheral in PWM Input Mode according to the
   1710            *         specified parameters.
   1711            * @param  TIM1_Channel specifies the input capture channel
   1712            *          This parameter can be one of the following values:
   1713            *            @arg TIM1_Channel_1: TIM1 Channel1
   1714            *            @arg TIM1_Channel_2: TIM1 Channel2
   1715            * @param  TIM1_ICPolarity specifies the Input capture polarity
   1716            *          This parameter can be one of the following values:
   1717            *            @arg TIM1_ICPolarity_Rising: Input capture polarity rising
   1718            *            @arg TIM1_ICPolarity_Falling: Input capture polarity falling
   1719            * @param  TIM1_ICSelection specifies the Input capture source selection 
   1720            *          This parameter can be one of the following values:
   1721            *            @arg TIM1_ICSelection_DirectTI: TIM1 Input x is selected to be connected to ICx.
   1722            *            @arg TIM1_ICSelection_IndirectTI: TIM1 Input x is selected to be connected to ICy.
   1723            *            @arg TIM1_ICSelection_TRGI: TIM1 Input x is selected to be connected to the TRGI     
   1724            * @param  TIM1_ICPrescaler specifies the Input capture Prescaler
   1725            *          This parameter can be one of the following values:
   1726            *            @arg TIM1_ICPSC_DIV1: Input Capture Prescaler = 1 (one capture every 1 event)
   1727            *            @arg TIM1_ICPSC_DIV2: Input Capture Prescaler = 2 (one capture every 2 events)
   1728            *            @arg TIM1_ICPSC_DIV4: Input Capture Prescaler = 4 (one capture every 4 events)
   1729            *            @arg TIM1_ICPSC_DIV8: Input Capture Prescaler = 8 (one capture every 8 events)   
   1730            * @param  TIM1_ICFilter specifies the Input capture filter value.
   1731            * @retval None
   1732            */

   \                                 In section .far_func.text, align 1, keep-with-next
   1733          void TIM1_PWMIConfig(TIM1_Channel_TypeDef TIM1_Channel,
   1734                               TIM1_ICPolarity_TypeDef TIM1_ICPolarity,
   1735                               TIM1_ICSelection_TypeDef TIM1_ICSelection,
   1736                               TIM1_ICPSC_TypeDef TIM1_ICPrescaler,
   1737                               uint8_t TIM1_ICFilter)
   1738          {
   \                     TIM1_PWMIConfig:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b6, A
   \   000005 45 .. ..     MOV       S:?b7, S:?b0
   \   000008 45 .. ..     MOV       S:?b0, S:?b1
   \   00000B 45 .. ..     MOV       S:?b8, S:?b2
   1739            TIM1_ICPolarity_TypeDef icpolarity = TIM1_ICPolarity_Rising;
   \   00000E 3F ..        CLR       S:?b5
   1740            TIM1_ICSelection_TypeDef icselection = TIM1_ICSelection_DirectTI;
   \   000010 35 01 ....   MOV       S:?b4, #0x1
   1741          
   1742            /* Check the parameters */
   1743            assert_param(IS_TIM1_PWMI_CHANNEL(TIM1_Channel));
   1744            assert_param(IS_TIM1_IC_POLARITY(TIM1_ICPolarity));
   1745            assert_param(IS_TIM1_IC_SELECTION(TIM1_ICSelection));
   1746            assert_param(IS_TIM1_IC_PRESCALER(TIM1_ICPrescaler));
   1747          
   1748            /* Select the Opposite Input Polarity */
   1749            if (TIM1_ICPolarity != TIM1_ICPolarity_Falling)
   \   000014 B6 ..        LD        A, S:?b7
   \   000016 A1 01        CP        A, #0x1
   \   000018 27 06        JREQ      L:??TIM1_PWMIConfig_0
   1750            {
   1751              icpolarity = TIM1_ICPolarity_Falling;
   \   00001A 35 01 ....   MOV       S:?b5, #0x1
   \   00001E 20 02        JRA       L:??TIM1_PWMIConfig_1
   1752            }
   1753            else
   1754            {
   1755              icpolarity = TIM1_ICPolarity_Rising;
   \                     ??TIM1_PWMIConfig_0:
   \   000020 3F ..        CLR       S:?b5
   1756            }
   1757          
   1758            /* Select the Opposite Input */
   1759            if (TIM1_ICSelection == TIM1_ICSelection_DirectTI)
   \                     ??TIM1_PWMIConfig_1:
   \   000022 B6 ..        LD        A, S:?b0
   \   000024 A1 01        CP        A, #0x1
   \   000026 26 06        JRNE      L:??TIM1_PWMIConfig_2
   1760            {
   1761              icselection = TIM1_ICSelection_IndirectTI;
   \   000028 35 02 ....   MOV       S:?b4, #0x2
   \   00002C 20 04        JRA       L:??TIM1_PWMIConfig_3
   1762            }
   1763            else
   1764            {
   1765              icselection = TIM1_ICSelection_DirectTI;
   \                     ??TIM1_PWMIConfig_2:
   \   00002E 35 01 ....   MOV       S:?b4, #0x1
   1766            }
   1767          
   1768            if (TIM1_Channel == TIM1_Channel_1)
   \                     ??TIM1_PWMIConfig_3:
   \   000032 3D ..        TNZ       S:?b6
   \   000034 26 23        JRNE      L:??TIM1_PWMIConfig_4
   1769            {
   1770              /* TI1 Configuration */
   1771              TI1_Config(TIM1_ICPolarity, TIM1_ICSelection, TIM1_ICFilter);
   \   000036 45 .. ..     MOV       S:?b1, S:?b3
   \   000039 B6 ..        LD        A, S:?b7
   \   00003B 8D ......    CALLF     TI1_Config
   1772          
   1773              /* Set the Input Capture Prescaler value */
   1774              TIM1_SetIC1Prescaler(TIM1_ICPrescaler);
   \   00003F B6 ..        LD        A, S:?b8
   \   000041 8D ......    CALLF     TIM1_SetIC1Prescaler
   1775          
   1776              /* TI2 Configuration */
   1777              TI2_Config(icpolarity, icselection, TIM1_ICFilter);
   \   000045 45 .. ..     MOV       S:?b1, S:?b3
   \   000048 45 .. ..     MOV       S:?b0, S:?b4
   \   00004B B6 ..        LD        A, S:?b5
   \   00004D 8D ......    CALLF     TI2_Config
   1778          
   1779              /* Set the Input Capture Prescaler value */
   1780              TIM1_SetIC2Prescaler(TIM1_ICPrescaler);
   \   000051 B6 ..        LD        A, S:?b8
   \   000053 8D ......    CALLF     TIM1_SetIC2Prescaler
   \   000057 20 21        JRA       L:??TIM1_PWMIConfig_5
   1781            }
   1782            else
   1783            {
   1784              /* TI2 Configuration */
   1785              TI2_Config(TIM1_ICPolarity, TIM1_ICSelection, TIM1_ICFilter);
   \                     ??TIM1_PWMIConfig_4:
   \   000059 45 .. ..     MOV       S:?b1, S:?b3
   \   00005C B6 ..        LD        A, S:?b7
   \   00005E 8D ......    CALLF     TI2_Config
   1786          
   1787              /* Set the Input Capture Prescaler value */
   1788              TIM1_SetIC2Prescaler(TIM1_ICPrescaler);
   \   000062 B6 ..        LD        A, S:?b8
   \   000064 8D ......    CALLF     TIM1_SetIC2Prescaler
   1789          
   1790              /* TI1 Configuration */
   1791              TI1_Config(icpolarity, icselection, TIM1_ICFilter);
   \   000068 45 .. ..     MOV       S:?b1, S:?b3
   \   00006B 45 .. ..     MOV       S:?b0, S:?b4
   \   00006E B6 ..        LD        A, S:?b5
   \   000070 8D ......    CALLF     TI1_Config
   1792          
   1793              /* Set the Input Capture Prescaler value */
   1794              TIM1_SetIC1Prescaler(TIM1_ICPrescaler);
   \   000074 B6 ..        LD        A, S:?b8
   \   000076 8D ......    CALLF     TIM1_SetIC1Prescaler
   1795            }
   1796          }
   \                     ??TIM1_PWMIConfig_5:
   \   00007A 32 ....      POP       S:?b8
   \   00007D 87           RETF
   1797          
   1798          /**
   1799            * @brief  Gets the TIM1 Input Capture 1 value.
   1800            * @param  None
   1801            * @retval Capture Compare 1 Register value.
   1802            */

   \                                 In section .far_func.text, align 1, keep-with-next
   1803          uint16_t TIM1_GetCapture1(void)
   1804          {
   1805            /* Get the Capture 1 Register value */
   1806          
   1807            uint16_t tmpccr1 = 0;
   \                     TIM1_GetCapture1:
   \   000000 905F         CLRW      Y
   1808            uint8_t tmpccr1l = 0, tmpccr1h = 0;
   \   000002 3F ..        CLR       S:?b1
   \   000004 3F ..        CLR       S:?b0
   1809          
   1810            tmpccr1h = TIM1->CCR1H;
   \   000006 C6 52C6      LD        A, L:0x52c6
   \   000009 B7 ..        LD        S:?b0, A
   1811            tmpccr1l = TIM1->CCR1L;
   \   00000B C6 52C7      LD        A, L:0x52c7
   \   00000E B7 ..        LD        S:?b1, A
   1812          
   1813            tmpccr1 = (uint16_t)(tmpccr1l);
   \   000010 5F           CLRW      X
   \   000011 41           EXG       A, XL
   \   000012 B6 ..        LD        A, S:?b1
   \   000014 41           EXG       A, XL
   \   000015 9093         LDW       Y, X
   1814            tmpccr1 |= (uint16_t)((uint16_t)tmpccr1h << 8);
   \   000017 5F           CLRW      X
   \   000018 41           EXG       A, XL
   \   000019 B6 ..        LD        A, S:?b0
   \   00001B 41           EXG       A, XL
   \   00001C 4F           CLR       A
   \   00001D 02           RLWA      X, A
   \   00001E BF ..        LDW       S:?w0, X
   \   000020 51           EXGW      X, Y
   \   000021 01           RRWA      X, A
   \   000022 BA ..        OR        A, S:?b1
   \   000024 01           RRWA      X, A
   \   000025 BA ..        OR        A, S:?b0
   \   000027 01           RRWA      X, A
   \   000028 51           EXGW      X, Y
   1815            /* Get the Capture 1 Register value */
   1816            return (uint16_t)tmpccr1;
   \   000029 93           LDW       X, Y
   \   00002A 87           RETF
   1817          }
   1818          
   1819          /**
   1820            * @brief  Gets the TIM1 Input Capture 2 value.
   1821            * @param  None
   1822            * @retval Capture Compare 2 Register value.
   1823            */

   \                                 In section .far_func.text, align 1, keep-with-next
   1824          uint16_t TIM1_GetCapture2(void)
   1825          {
   1826            /* Get the Capture 2 Register value */
   1827          
   1828            uint16_t tmpccr2 = 0;
   \                     TIM1_GetCapture2:
   \   000000 905F         CLRW      Y
   1829            uint8_t tmpccr2l = 0, tmpccr2h = 0;
   \   000002 3F ..        CLR       S:?b1
   \   000004 3F ..        CLR       S:?b0
   1830          
   1831            tmpccr2h = TIM1->CCR2H;
   \   000006 C6 52C8      LD        A, L:0x52c8
   \   000009 B7 ..        LD        S:?b0, A
   1832            tmpccr2l = TIM1->CCR2L;
   \   00000B C6 52C9      LD        A, L:0x52c9
   \   00000E B7 ..        LD        S:?b1, A
   1833          
   1834            tmpccr2 = (uint16_t)(tmpccr2l);
   \   000010 5F           CLRW      X
   \   000011 41           EXG       A, XL
   \   000012 B6 ..        LD        A, S:?b1
   \   000014 41           EXG       A, XL
   \   000015 9093         LDW       Y, X
   1835            tmpccr2 |= (uint16_t)((uint16_t)tmpccr2h << 8);
   \   000017 5F           CLRW      X
   \   000018 41           EXG       A, XL
   \   000019 B6 ..        LD        A, S:?b0
   \   00001B 41           EXG       A, XL
   \   00001C 4F           CLR       A
   \   00001D 02           RLWA      X, A
   \   00001E BF ..        LDW       S:?w0, X
   \   000020 51           EXGW      X, Y
   \   000021 01           RRWA      X, A
   \   000022 BA ..        OR        A, S:?b1
   \   000024 01           RRWA      X, A
   \   000025 BA ..        OR        A, S:?b0
   \   000027 01           RRWA      X, A
   \   000028 51           EXGW      X, Y
   1836            /* Get the Capture 2 Register value */
   1837            return (uint16_t)tmpccr2;
   \   000029 93           LDW       X, Y
   \   00002A 87           RETF
   1838          }
   1839          
   1840          /**
   1841            * @brief  Gets the TIM1 Input Capture 3 value.
   1842            * @param  None
   1843            * @retval Capture Compare 3 Register value.
   1844            */

   \                                 In section .far_func.text, align 1, keep-with-next
   1845          uint16_t TIM1_GetCapture3(void)
   1846          {
   1847            /* Get the Capture 3 Register value */
   1848            uint16_t tmpccr3 = 0;
   \                     TIM1_GetCapture3:
   \   000000 905F         CLRW      Y
   1849            uint8_t tmpccr3l = 0, tmpccr3h = 0;
   \   000002 3F ..        CLR       S:?b1
   \   000004 3F ..        CLR       S:?b0
   1850          
   1851            tmpccr3h = TIM1->CCR3H;
   \   000006 C6 52CA      LD        A, L:0x52ca
   \   000009 B7 ..        LD        S:?b0, A
   1852            tmpccr3l = TIM1->CCR3L;
   \   00000B C6 52CB      LD        A, L:0x52cb
   \   00000E B7 ..        LD        S:?b1, A
   1853          
   1854            tmpccr3 = (uint16_t)(tmpccr3l);
   \   000010 5F           CLRW      X
   \   000011 41           EXG       A, XL
   \   000012 B6 ..        LD        A, S:?b1
   \   000014 41           EXG       A, XL
   \   000015 9093         LDW       Y, X
   1855            tmpccr3 |= (uint16_t)((uint16_t)tmpccr3h << 8);
   \   000017 5F           CLRW      X
   \   000018 41           EXG       A, XL
   \   000019 B6 ..        LD        A, S:?b0
   \   00001B 41           EXG       A, XL
   \   00001C 4F           CLR       A
   \   00001D 02           RLWA      X, A
   \   00001E BF ..        LDW       S:?w0, X
   \   000020 51           EXGW      X, Y
   \   000021 01           RRWA      X, A
   \   000022 BA ..        OR        A, S:?b1
   \   000024 01           RRWA      X, A
   \   000025 BA ..        OR        A, S:?b0
   \   000027 01           RRWA      X, A
   \   000028 51           EXGW      X, Y
   1856            /* Get the Capture 3 Register value */
   1857            return (uint16_t)tmpccr3;
   \   000029 93           LDW       X, Y
   \   00002A 87           RETF
   1858          }
   1859          
   1860          /**
   1861            * @brief  Gets the TIM1 Input Capture 4 value.
   1862            * @param  None
   1863            * @retval Capture Compare 4 Register value.
   1864            */

   \                                 In section .far_func.text, align 1, keep-with-next
   1865          uint16_t TIM1_GetCapture4(void)
   1866          {
   1867            /* Get the Capture 4 Register value */
   1868            uint16_t tmpccr4 = 0;
   \                     TIM1_GetCapture4:
   \   000000 905F         CLRW      Y
   1869            uint8_t tmpccr4l = 0, tmpccr4h = 0;
   \   000002 3F ..        CLR       S:?b1
   \   000004 3F ..        CLR       S:?b0
   1870          
   1871            tmpccr4h = TIM1->CCR4H;
   \   000006 C6 52CC      LD        A, L:0x52cc
   \   000009 B7 ..        LD        S:?b0, A
   1872            tmpccr4l = TIM1->CCR4L;
   \   00000B C6 52CD      LD        A, L:0x52cd
   \   00000E B7 ..        LD        S:?b1, A
   1873          
   1874            tmpccr4 = (uint16_t)(tmpccr4l);
   \   000010 5F           CLRW      X
   \   000011 41           EXG       A, XL
   \   000012 B6 ..        LD        A, S:?b1
   \   000014 41           EXG       A, XL
   \   000015 9093         LDW       Y, X
   1875            tmpccr4 |= (uint16_t)((uint16_t)tmpccr4h << 8);
   \   000017 5F           CLRW      X
   \   000018 41           EXG       A, XL
   \   000019 B6 ..        LD        A, S:?b0
   \   00001B 41           EXG       A, XL
   \   00001C 4F           CLR       A
   \   00001D 02           RLWA      X, A
   \   00001E BF ..        LDW       S:?w0, X
   \   000020 51           EXGW      X, Y
   \   000021 01           RRWA      X, A
   \   000022 BA ..        OR        A, S:?b1
   \   000024 01           RRWA      X, A
   \   000025 BA ..        OR        A, S:?b0
   \   000027 01           RRWA      X, A
   \   000028 51           EXGW      X, Y
   1876            /* Get the Capture 4 Register value */
   1877            return (uint16_t)tmpccr4;
   \   000029 93           LDW       X, Y
   \   00002A 87           RETF
   1878          }
   1879          
   1880          /**
   1881            * @brief  Sets the TIM1 Input Capture 1 prescaler.
   1882            * @param  TIM1_IC1Prescaler specifies the Input Capture prescaler new value
   1883            *          This parameter can be one of the following values:
   1884            *            @arg TIM1_ICPSC_DIV1: Input Capture Prescaler = 1 (one capture every 1 event)
   1885            *            @arg TIM1_ICPSC_DIV2: Input Capture Prescaler = 2 (one capture every 2 events)
   1886            *            @arg TIM1_ICPSC_DIV4: Input Capture Prescaler = 4 (one capture every 4 events)
   1887            *            @arg TIM1_ICPSC_DIV8: Input Capture Prescaler = 8 (one capture every 8 events)   
   1888            * @retval None
   1889            */

   \                                 In section .far_func.text, align 1, keep-with-next
   1890          void TIM1_SetIC1Prescaler(TIM1_ICPSC_TypeDef TIM1_IC1Prescaler)
   1891          {
   \                     TIM1_SetIC1Prescaler:
   \   000000 B7 ..        LD        S:?b0, A
   1892            /* Check the parameters */
   1893            assert_param(IS_TIM1_IC_PRESCALER(TIM1_IC1Prescaler));
   1894          
   1895            /* Reset the IC1PSC Bits */ /* Set the IC1PSC value */
   1896            TIM1->CCMR1 = (uint8_t)((uint8_t)(TIM1->CCMR1 & (uint8_t)(~TIM1_CCMR_ICxPSC)) | (uint8_t)TIM1_IC1Prescaler);
   \   000002 C6 52B9      LD        A, L:0x52b9
   \   000005 A4 F3        AND       A, #0xf3
   \   000007 BA ..        OR        A, S:?b0
   \   000009 C7 52B9      LD        L:0x52b9, A
   1897          }
   \   00000C 87           RETF
   1898          
   1899          /**
   1900            * @brief  Sets the TIM1 Input Capture 2 prescaler.
   1901            * @param  TIM1_IC2Prescaler specifies the Input Capture prescaler new value
   1902            *          This parameter can be one of the following values:
   1903            *            @arg TIM1_ICPSC_DIV1: Input Capture Prescaler = 1 (one capture every 1 event)
   1904            *            @arg TIM1_ICPSC_DIV2: Input Capture Prescaler = 2 (one capture every 2 events)
   1905            *            @arg TIM1_ICPSC_DIV4: Input Capture Prescaler = 4 (one capture every 4 events)
   1906            *            @arg TIM1_ICPSC_DIV8: Input Capture Prescaler = 8 (one capture every 8 events)   
   1907            * @retval None
   1908            */

   \                                 In section .far_func.text, align 1, keep-with-next
   1909          void TIM1_SetIC2Prescaler(TIM1_ICPSC_TypeDef TIM1_IC2Prescaler)
   1910          {
   \                     TIM1_SetIC2Prescaler:
   \   000000 B7 ..        LD        S:?b0, A
   1911            /* Check the parameters */
   1912            assert_param(IS_TIM1_IC_PRESCALER(TIM1_IC2Prescaler));
   1913          
   1914            /* Reset the IC1PSC Bits */ /* Set the IC1PSC value */
   1915            TIM1->CCMR2 = (uint8_t)((uint8_t)(TIM1->CCMR2 & (uint8_t)(~TIM1_CCMR_ICxPSC)) | (uint8_t)TIM1_IC2Prescaler);
   \   000002 C6 52BA      LD        A, L:0x52ba
   \   000005 A4 F3        AND       A, #0xf3
   \   000007 BA ..        OR        A, S:?b0
   \   000009 C7 52BA      LD        L:0x52ba, A
   1916          }
   \   00000C 87           RETF
   1917          
   1918          /**
   1919            * @brief  Sets the TIM1 Input Capture 3 prescaler.
   1920            * @param  TIM1_IC3Prescaler specifies the Input Capture prescaler new value
   1921            *          This parameter can be one of the following values:
   1922            *            @arg TIM1_ICPSC_DIV1: Input Capture Prescaler = 1 (one capture every 1 event)
   1923            *            @arg TIM1_ICPSC_DIV2: Input Capture Prescaler = 2 (one capture every 2 events)
   1924            *            @arg TIM1_ICPSC_DIV4: Input Capture Prescaler = 4 (one capture every 4 events)
   1925            *            @arg TIM1_ICPSC_DIV8: Input Capture Prescaler = 8 (one capture every 8 events)   
   1926            * @retval None
   1927            */

   \                                 In section .far_func.text, align 1, keep-with-next
   1928          void TIM1_SetIC3Prescaler(TIM1_ICPSC_TypeDef TIM1_IC3Prescaler)
   1929          {
   \                     TIM1_SetIC3Prescaler:
   \   000000 B7 ..        LD        S:?b0, A
   1930          
   1931            /* Check the parameters */
   1932            assert_param(IS_TIM1_IC_PRESCALER(TIM1_IC3Prescaler));
   1933          
   1934            /* Reset the IC1PSC Bits & Set the IC1PSC value */
   1935            TIM1->CCMR3 = (uint8_t)((uint8_t)(TIM1->CCMR3 & (uint8_t)(~TIM1_CCMR_ICxPSC)) | (uint8_t)TIM1_IC3Prescaler);
   \   000002 C6 52BB      LD        A, L:0x52bb
   \   000005 A4 F3        AND       A, #0xf3
   \   000007 BA ..        OR        A, S:?b0
   \   000009 C7 52BB      LD        L:0x52bb, A
   1936          }
   \   00000C 87           RETF
   1937          
   1938          /**
   1939            * @brief  Sets the TIM1 Input Capture 4 prescaler.
   1940            * @param  TIM1_IC4Prescaler specifies the Input Capture prescaler new value
   1941            *          This parameter can be one of the following values:
   1942            *            @arg TIM1_ICPSC_DIV1: Input Capture Prescaler = 1 (one capture every 1 event)
   1943            *            @arg TIM1_ICPSC_DIV2: Input Capture Prescaler = 2 (one capture every 2 events)
   1944            *            @arg TIM1_ICPSC_DIV4: Input Capture Prescaler = 4 (one capture every 4 events)
   1945            *            @arg TIM1_ICPSC_DIV8: Input Capture Prescaler = 8 (one capture every 8 events)   
   1946            * @retval None
   1947            */

   \                                 In section .far_func.text, align 1, keep-with-next
   1948          void TIM1_SetIC4Prescaler(TIM1_ICPSC_TypeDef TIM1_IC4Prescaler)
   1949          {
   \                     TIM1_SetIC4Prescaler:
   \   000000 B7 ..        LD        S:?b0, A
   1950          
   1951            /* Check the parameters */
   1952            assert_param(IS_TIM1_IC_PRESCALER(TIM1_IC4Prescaler));
   1953          
   1954            /* Reset the IC1PSC Bits &  Set the IC1PSC value */
   1955            TIM1->CCMR4 = (uint8_t)((uint8_t)(TIM1->CCMR4 & (uint8_t)(~TIM1_CCMR_ICxPSC)) | (uint8_t)TIM1_IC4Prescaler);
   \   000002 C6 52BC      LD        A, L:0x52bc
   \   000005 A4 F3        AND       A, #0xf3
   \   000007 BA ..        OR        A, S:?b0
   \   000009 C7 52BC      LD        L:0x52bc, A
   1956          }
   \   00000C 87           RETF
   1957          
   1958          /**
   1959            * @}
   1960            */
   1961          
   1962          /** @defgroup TIM1_Group4 Interrupts DMA and flags management functions
   1963           *  @brief    Interrupts, DMA and flags management functions 
   1964           *
   1965          @verbatim   
   1966           ===============================================================================
   1967                           Interrupts, DMA and flags management functions
   1968           ===============================================================================  
   1969          
   1970          @endverbatim
   1971            * @{
   1972            */
   1973          
   1974          /**
   1975            * @brief  Enables or disables the specified TIM1 interrupts.
   1976            * @param  NewState new state of the TIM1 peripheral.
   1977            *          This parameter can be: ENABLE or DISABLE.
   1978            * @param  TIM1_IT specifies the TIM1 interrupts sources to be enabled or disabled.
   1979            *          This parameter can be any combination of the following values:
   1980            *            @arg TIM1_IT_Update: Update
   1981            *            @arg TIM1_IT_CC1: Capture Compare Channel1
   1982            *            @arg TIM1_IT_CC2: Capture Compare Channel2 
   1983            *            @arg TIM1_IT_CC3: Capture Compare Channel3
   1984            *            @arg TIM1_IT_CC4: Capture Compare Channel4 
   1985            *            @arg TIM1_IT_COM: Commutation
   1986            *            @arg TIM1_IT_Trigger: Trigger 
   1987            *            @arg TIM1_IT_Break: Break  
   1988            * @param  NewState new state of the TIM1 peripheral.
   1989            * @retval None
   1990            */

   \                                 In section .far_func.text, align 1
   1991          void TIM1_ITConfig(TIM1_IT_TypeDef  TIM1_IT, FunctionalState NewState)
   1992          {
   1993            /* Check the parameters */
   1994            assert_param(IS_TIM1_IT(TIM1_IT));
   1995            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1996          
   1997            if (NewState != DISABLE)
   \                     TIM1_ITConfig:
   \   000000 3D ..        TNZ       S:?b0
   \   000002 27 07        JREQ      L:??TIM1_ITConfig_0
   1998            {
   1999              /* Enable the Interrupt sources */
   2000              TIM1->IER |= (uint8_t)TIM1_IT;
   \   000004 CA 52B5      OR        A, L:0x52b5
   \   000007 C7 52B5      LD        L:0x52b5, A
   \   00000A 87           RETF
   2001            }
   2002            else
   2003            {
   2004              /* Disable the Interrupt sources */
   2005              TIM1->IER &= (uint8_t)(~(uint8_t)TIM1_IT);
   \                     ??TIM1_ITConfig_0:
   \   00000B 43           CPL       A
   \   00000C C4 52B5      AND       A, L:0x52b5
   \   00000F C7 52B5      LD        L:0x52b5, A
   2006            }
   2007          }
   \   000012 87           RETF
   2008          
   2009          /**
   2010            * @brief  Configures the TIM1 event to be generated by software.
   2011            * @param  TIM1_EventSource specifies the event source.
   2012            *          This parameter can be any combination of the following values:
   2013            *            @arg TIM1_EventSource_Update: Update
   2014            *            @arg TIM1_EventSource_CC1: Capture Compare Channel1
   2015            *            @arg TIM1_EventSource_CC2: Capture Compare Channel2 
   2016            *            @arg TIM1_EventSource_CC3: Capture Compare Channel3
   2017            *            @arg TIM1_EventSource_CC4: Capture Compare Channel4 
   2018            *            @arg TIM1_EventSource_COM: Commutation
   2019            *            @arg TIM1_EventSource_Trigger: Trigger 
   2020            *            @arg TIM1_EventSource_Break: Break  
   2021            * @retval None
   2022            */

   \                                 In section .far_func.text, align 1
   2023          void TIM1_GenerateEvent(TIM1_EventSource_TypeDef TIM1_EventSource)
   2024          {
   2025            /* Check the parameters */
   2026            assert_param(IS_TIM1_EVENT_SOURCE(TIM1_EventSource));
   2027          
   2028            /* Set the event sources */
   2029            TIM1->EGR = (uint8_t)TIM1_EventSource;
   \                     TIM1_GenerateEvent:
   \   000000 C7 52B8      LD        L:0x52b8, A
   2030          }
   \   000003 87           RETF
   2031          /**
   2032            * @brief  Checks whether the specified TIM1 flag is set or not.
   2033            * @param  TIM1_FLAG specifies the flag to check.
   2034            *          This parameter can be one of the following values:
   2035            *            @arg TIM1_FLAG_Update: TIM1 update Flag
   2036            *            @arg TIM1_FLAG_CC1: TIM1 Capture Compare 1 Flag
   2037            *            @arg TIM1_FLAG_CC2: TIM1 Capture Compare 2 Flag
   2038            *            @arg TIM1_FLAG_CC3: TIM1 Capture Compare 3 Flag
   2039            *            @arg TIM1_FLAG_CC4: TIM1 Capture Compare 4 Flag
   2040            *            @arg TIM1_FLAG_COM: TIM1 Commutation Flag
   2041            *            @arg TIM1_FLAG_Trigger: TIM1 Trigger Flag
   2042            *            @arg TIM1_FLAG_Break: TIM1 Break Flag
   2043            *            @arg TIM1_FLAG_CC1OF: TIM1 Capture Compare 1 overcapture Flag
   2044            *            @arg TIM1_FLAG_CC2OF: TIM1 Capture Compare 2 overcapture Flag
   2045            *            @arg TIM1_FLAG_CC3OF: TIM1 Capture Compare 3 overcapture Flag
   2046            *            @arg TIM1_FLAG_CC4OF: TIM1 Capture Compare 4 overcapture Flag
   2047            * @retval FlagStatus The new state of TIM1_FLAG (SET or RESET).
   2048            */

   \                                 In section .far_func.text, align 1
   2049          FlagStatus TIM1_GetFlagStatus(TIM1_FLAG_TypeDef TIM1_FLAG)
   2050          {
   2051            FlagStatus bitstatus = RESET;
   \                     TIM1_GetFlagStatus:
   \   000000 3F ..        CLR       S:?b0
   2052            uint8_t tim1_flag_l = 0, tim1_flag_h = 0;
   \   000002 3F ..        CLR       S:?b2
   \   000004 3F ..        CLR       S:?b1
   2053          
   2054            /* Check the parameters */
   2055            assert_param(IS_TIM1_GET_FLAG(TIM1_FLAG));
   2056          
   2057            tim1_flag_l = (uint8_t)(TIM1->SR1 & (uint8_t)TIM1_FLAG);
   \   000006 9F           LD        A, XL
   \   000007 C4 52B6      AND       A, L:0x52b6
   \   00000A B7 ..        LD        S:?b2, A
   2058            tim1_flag_h = (uint8_t)(TIM1->SR2 & (uint8_t)((uint16_t)TIM1_FLAG >> 8));
   \   00000C 4F           CLR       A
   \   00000D 01           RRWA      X, A
   \   00000E 9F           LD        A, XL
   \   00000F C4 52B7      AND       A, L:0x52b7
   \   000012 B7 ..        LD        S:?b1, A
   2059          
   2060            if ((uint8_t)((uint8_t)tim1_flag_l | (uint8_t)tim1_flag_h) != 0)
   \   000014 B6 ..        LD        A, S:?b1
   \   000016 BA ..        OR        A, S:?b2
   \   000018 A1 00        CP        A, #0x0
   \   00001A 27 06        JREQ      L:??TIM1_GetFlagStatus_0
   2061            {
   2062              bitstatus = SET;
   \   00001C 35 01 ....   MOV       S:?b0, #0x1
   \   000020 20 02        JRA       L:??TIM1_GetFlagStatus_1
   2063            }
   2064            else
   2065            {
   2066              bitstatus = RESET;
   \                     ??TIM1_GetFlagStatus_0:
   \   000022 3F ..        CLR       S:?b0
   2067            }
   2068            return (FlagStatus)(bitstatus);
   \                     ??TIM1_GetFlagStatus_1:
   \   000024 B6 ..        LD        A, S:?b0
   \   000026 87           RETF
   2069          }
   2070          
   2071          /**
   2072            * @brief  Clears the TIM1’s pending flags.
   2073            * @param  TIM1_FLAG specifies the flag to clear.
   2074            *          This parameter can be one of the following values:
   2075            *            @arg TIM1_FLAG_Update: TIM1 update Flag
   2076            *            @arg TIM1_FLAG_CC1: TIM1 Capture Compare 1 Flag
   2077            *            @arg TIM1_FLAG_CC2: TIM1 Capture Compare 2 Flag
   2078            *            @arg TIM1_FLAG_CC3: TIM1 Capture Compare 3 Flag
   2079            *            @arg TIM1_FLAG_CC4: TIM1 Capture Compare 4 Flag
   2080            *            @arg TIM1_FLAG_COM: TIM1 Commutation Flag
   2081            *            @arg TIM1_FLAG_Trigger: TIM1 Trigger Flag
   2082            *            @arg TIM1_FLAG_Break: TIM1 Break Flag
   2083            *            @arg TIM1_FLAG_CC1OF: TIM1 Capture Compare 1 overcapture Flag
   2084            *            @arg TIM1_FLAG_CC2OF: TIM1 Capture Compare 2 overcapture Flag
   2085            *            @arg TIM1_FLAG_CC3OF: TIM1 Capture Compare 3 overcapture Flag
   2086            *            @arg TIM1_FLAG_CC4OF: TIM1 Capture Compare 4 overcapture Flag
   2087            * @retval None.
   2088            */

   \                                 In section .far_func.text, align 1
   2089          void TIM1_ClearFlag(TIM1_FLAG_TypeDef TIM1_FLAG)
   2090          {
   2091            /* Check the parameters */
   2092            assert_param(IS_TIM1_CLEAR_FLAG(TIM1_FLAG));
   2093          
   2094            /* Clear the flags (rc_w0) clear this bit by writing 0. Writing ‘1’ has no effect*/
   2095            TIM1->SR1 = (uint8_t)(~(uint8_t)(TIM1_FLAG));
   \                     TIM1_ClearFlag:
   \   000000 9F           LD        A, XL
   \   000001 43           CPL       A
   \   000002 C7 52B6      LD        L:0x52b6, A
   2096            TIM1->SR2 = (uint8_t)((uint8_t)(~((uint8_t)((uint16_t)TIM1_FLAG >> 8))) & (uint8_t)0x1E);
   \   000005 4F           CLR       A
   \   000006 01           RRWA      X, A
   \   000007 9F           LD        A, XL
   \   000008 43           CPL       A
   \   000009 A4 1E        AND       A, #0x1e
   \   00000B C7 52B7      LD        L:0x52b7, A
   2097          }
   \   00000E 87           RETF
   2098          
   2099          /**
   2100            * @brief  Checks whether the TIM1 interrupt has occurred or not.
   2101            * @param  TIM1_IT specifies the TIM1 interrupt source to check.
   2102            *          This parameter can be any combination of the following values:
   2103            *            @arg TIM1_IT_Update: Update
   2104            *            @arg TIM1_IT_CC1: Capture Compare Channel1
   2105            *            @arg TIM1_IT_CC2: Capture Compare Channel2 
   2106            *            @arg TIM1_IT_CC3: Capture Compare Channel3
   2107            *            @arg TIM1_IT_CC4: Capture Compare Channel4 
   2108            *            @arg TIM1_IT_COM: Commutation
   2109            *            @arg TIM1_IT_Trigger: Trigger 
   2110            *            @arg TIM1_IT_Break: Break  
   2111            * @retval ITStatus The new state of the TIM1_IT(SET or RESET).
   2112            */
   2113          

   \                                 In section .far_func.text, align 1
   2114          ITStatus TIM1_GetITStatus(TIM1_IT_TypeDef TIM1_IT)
   2115          {
   \                     TIM1_GetITStatus:
   \   000000 B7 ..        LD        S:?b3, A
   2116            ITStatus bitstatus = RESET;
   \   000002 3F ..        CLR       S:?b0
   2117          
   2118            uint8_t TIM1_itStatus = 0x0, TIM1_itEnable = 0x0;
   \   000004 3F ..        CLR       S:?b2
   \   000006 3F ..        CLR       S:?b1
   2119          
   2120            /* Check the parameters */
   2121            assert_param(IS_TIM1_GET_IT(TIM1_IT));
   2122          
   2123            TIM1_itStatus = (uint8_t)(TIM1->SR1 & (uint8_t)TIM1_IT);
   \   000008 B6 ..        LD        A, S:?b3
   \   00000A C4 52B6      AND       A, L:0x52b6
   \   00000D B7 ..        LD        S:?b2, A
   2124          
   2125            TIM1_itEnable = (uint8_t)(TIM1->IER & (uint8_t)TIM1_IT);
   \   00000F B6 ..        LD        A, S:?b3
   \   000011 C4 52B5      AND       A, L:0x52b5
   \   000014 B7 ..        LD        S:?b1, A
   2126          
   2127            if ((TIM1_itStatus != (uint8_t)RESET ) && (TIM1_itEnable != (uint8_t)RESET ))
   \   000016 3D ..        TNZ       S:?b2
   \   000018 27 0A        JREQ      L:??TIM1_GetITStatus_0
   \   00001A 3D ..        TNZ       S:?b1
   \   00001C 27 06        JREQ      L:??TIM1_GetITStatus_0
   2128            {
   2129              bitstatus = SET;
   \   00001E 35 01 ....   MOV       S:?b0, #0x1
   \   000022 20 02        JRA       L:??TIM1_GetITStatus_1
   2130            }
   2131            else
   2132            {
   2133              bitstatus = RESET;
   \                     ??TIM1_GetITStatus_0:
   \   000024 3F ..        CLR       S:?b0
   2134            }
   2135            return (ITStatus)(bitstatus);
   \                     ??TIM1_GetITStatus_1:
   \   000026 B6 ..        LD        A, S:?b0
   \   000028 87           RETF
   2136          }
   2137          
   2138          /**
   2139            * @brief  Clears the TIM1's interrupt pending bits.
   2140            * @param  TIM1_IT specifies the pending bit to clear.
   2141            *          This parameter can be any combination of the following values:
   2142            *            @arg TIM1_IT_Update: Update
   2143            *            @arg TIM1_IT_CC1: Capture Compare Channel1
   2144            *            @arg TIM1_IT_CC2: Capture Compare Channel2 
   2145            *            @arg TIM1_IT_CC3: Capture Compare Channel3
   2146            *            @arg TIM1_IT_CC4: Capture Compare Channel4 
   2147            *            @arg TIM1_IT_COM: Commutation
   2148            *            @arg TIM1_IT_Trigger: Trigger 
   2149            *            @arg TIM1_IT_Break: Break  
   2150            * @retval None.
   2151            */

   \                                 In section .far_func.text, align 1
   2152          void TIM1_ClearITPendingBit(TIM1_IT_TypeDef TIM1_IT)
   2153          {
   2154            /* Check the parameters */
   2155            assert_param(IS_TIM1_IT(TIM1_IT));
   2156          
   2157            /* Clear the IT pending Bit */
   2158            TIM1->SR1 = (uint8_t)(~(uint8_t)TIM1_IT);
   \                     TIM1_ClearITPendingBit:
   \   000000 43           CPL       A
   \   000001 C7 52B6      LD        L:0x52b6, A
   2159          }
   \   000004 87           RETF
   2160          
   2161          /**
   2162            * @brief  Configures the TIM1’s DMA interface.
   2163            * @param  TIM1_DMABase: DMA Base address.
   2164            * @param  TIM1_DMABurstLength: DMA Burst length.
   2165            * @retval None.
   2166            */

   \                                 In section .far_func.text, align 1
   2167          void TIM1_DMAConfig(TIM1_DMABase_TypeDef TIM1_DMABase,
   2168                              TIM1_DMABurstLength_TypeDef TIM1_DMABurstLength)
   2169          {
   2170            /* Check the parameters */
   2171            assert_param(IS_TIM1_DMABase(TIM1_DMABase));
   2172            assert_param(IS_TIM1_DMABurstLength(TIM1_DMABurstLength));
   2173          
   2174            /* Set the DMA Base and the DMA Burst Length */
   2175            TIM1->DCR1 = (uint8_t)TIM1_DMABase;
   \                     TIM1_DMAConfig:
   \   000000 C7 52D1      LD        L:0x52d1, A
   2176            TIM1->DCR2 = (uint8_t)TIM1_DMABurstLength;
   \   000003 B6 ..        LD        A, S:?b0
   \   000005 C7 52D2      LD        L:0x52d2, A
   2177          }
   \   000008 87           RETF
   2178          
   2179          /**
   2180            * @brief  Enables or disables the TIM’s DMA Requests.
   2181            * @param  TIM1_DMASources: specifies the DMA Request sources.
   2182            *          This parameter can be any combination of the following values:
   2183            *            @arg TIM1_DMA_Update: TIM1 update Interrupt source
   2184            *            @arg DMA_Trigger: TIM1 Trigger DMA source
   2185            * @param  NewState  new state of the DMA Request sources.
   2186            *          This parameter can be: ENABLE or DISABLE.
   2187            * @retval None.
   2188            */

   \                                 In section .far_func.text, align 1
   2189          void TIM1_DMACmd(TIM1_DMASource_TypeDef TIM1_DMASource, FunctionalState NewState)
   2190          {
   2191            /* Check the parameters */
   2192            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2193            assert_param(IS_TIM1_DMA_SOURCE(TIM1_DMASource));
   2194          
   2195            if (NewState != DISABLE)
   \                     TIM1_DMACmd:
   \   000000 3D ..        TNZ       S:?b0
   \   000002 27 07        JREQ      L:??TIM1_DMACmd_0
   2196            {
   2197              /* Enable the DMA sources */
   2198              TIM1->DER |= (uint8_t)TIM1_DMASource;
   \   000004 CA 52B4      OR        A, L:0x52b4
   \   000007 C7 52B4      LD        L:0x52b4, A
   \   00000A 87           RETF
   2199            }
   2200            else
   2201            {
   2202              /* Disable the DMA sources */
   2203              TIM1->DER &= (uint8_t)(~TIM1_DMASource);
   \                     ??TIM1_DMACmd_0:
   \   00000B 43           CPL       A
   \   00000C C4 52B4      AND       A, L:0x52b4
   \   00000F C7 52B4      LD        L:0x52b4, A
   2204            }
   2205          }
   \   000012 87           RETF
   2206          
   2207          /**
   2208            * @brief  Selects the TIM1 peripheral Capture Compare DMA source.
   2209            * @param   NewState: new state of the Capture Compare DMA source.
   2210            *          This parameter can be: ENABLE or DISABLE.
   2211            * @retval None
   2212            */

   \                                 In section .far_func.text, align 1
   2213          void TIM1_SelectCCDMA(FunctionalState NewState)
   2214          {
   2215            /* Check the parameters */
   2216            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2217          
   2218            if (NewState != DISABLE)
   \                     TIM1_SelectCCDMA:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM1_SelectCCDMA_0
   2219            {
   2220              /* Set the CCDS Bit */
   2221              TIM1->CR2 |= TIM1_CR2_CCDS;
   \   000003 7216 52B1    BSET      L:0x52b1, #0x3
   \   000007 87           RETF
   2222            }
   2223            else
   2224            {
   2225              /* Reset the CCDS Bit */
   2226              TIM1->CR2 &= (uint8_t)(~TIM1_CR2_CCDS);
   \                     ??TIM1_SelectCCDMA_0:
   \   000008 7217 52B1    BRES      L:0x52b1, #0x3
   2227            }
   2228          }
   \   00000C 87           RETF
   2229          
   2230          /**
   2231            * @}
   2232            */
   2233          
   2234          /** @defgroup TIM1_Group5 Clocks management functions
   2235           *  @brief    Clocks management functions
   2236           *
   2237          @verbatim   
   2238           ===============================================================================
   2239                                   Clocks management functions
   2240           ===============================================================================  
   2241          
   2242          @endverbatim
   2243            * @{
   2244            */
   2245          
   2246          /**
   2247            * @brief  Configures the TIM1 internal Clock.
   2248            * @param  None
   2249            * @retval None
   2250            */

   \                                 In section .far_func.text, align 1
   2251          void TIM1_InternalClockConfig(void)
   2252          {
   2253            /* Disable slave mode to clock the prescaler directly with the internal clock */
   2254            TIM1->SMCR &= (uint8_t)(~TIM1_SMCR_SMS);
   \                     TIM1_InternalClockConfig:
   \   000000 C6 52B2      LD        A, L:0x52b2
   \   000003 A4 F8        AND       A, #0xf8
   \   000005 C7 52B2      LD        L:0x52b2, A
   2255          }
   \   000008 87           RETF
   2256          
   2257          /**
   2258            * @brief  Configures the TIM1 Trigger as External Clock.
   2259            * @param  TIM1_TIxExternalCLKSource specifies Trigger source.
   2260            *          This parameter can be one of the following values:
   2261            *            @arg TIM1_TIxExternalCLK1Source_TI1: TI1 Edge Detector
   2262            *            @arg TIM1_TIxExternalCLK1Source_TI2: Filtered TIM1 Input 1
   2263            *            @arg TIM1_TIxExternalCLK1Source_TI1ED: Filtered TIM1 Input 2
   2264            * @param  TIM1_ICPolarity specifies the TIx Polarity.
   2265            *          This parameter can be one of the following values:
   2266            *            @arg TIM1_ICPolarity_Rising: Input capture polarity rising
   2267            *            @arg TIM1_ICPolarity_Falling: Input capture polarity falling
   2268            * @param  ICFilter specifies the filter value.
   2269            *          This parameter must be a value between 0x00 and 0x0F
   2270            * @retval None
   2271            */

   \                                 In section .far_func.text, align 1
   2272          void TIM1_TIxExternalClockConfig(TIM1_TIxExternalCLK1Source_TypeDef TIM1_TIxExternalCLKSource,
   2273                                           TIM1_ICPolarity_TypeDef TIM1_ICPolarity,
   2274                                           uint8_t ICFilter)
   2275          {
   \                     TIM1_TIxExternalClockConfig:
   \   000000 B7 ..        LD        S:?b3, A
   \   000002 45 .. ..     MOV       S:?b2, S:?b0
   2276            /* Check the parameters */
   2277            assert_param(IS_TIM1_TIXCLK_SOURCE(TIM1_TIxExternalCLKSource));
   2278            assert_param(IS_TIM1_IC_POLARITY(TIM1_ICPolarity));
   2279            assert_param(IS_TIM1_IC_FILTER(ICFilter));
   2280          
   2281            /* Configure the TIM1 Input Clock Source */
   2282            if (TIM1_TIxExternalCLKSource == TIM1_TIxExternalCLK1Source_TI2)
   \   000005 B6 ..        LD        A, S:?b3
   \   000007 A1 60        CP        A, #0x60
   \   000009 26 0C        JRNE      L:??TIM1_TIxExternalClockConfig_0
   2283            {
   2284              TI2_Config(TIM1_ICPolarity, TIM1_ICSelection_DirectTI, ICFilter);
   \   00000B 35 01 ....   MOV       S:?b0, #0x1
   \   00000F B6 ..        LD        A, S:?b2
   \   000011 8D ......    CALLF     TI2_Config
   \   000015 20 0A        JRA       L:??TIM1_TIxExternalClockConfig_1
   2285            }
   2286            else
   2287            {
   2288              TI1_Config(TIM1_ICPolarity, TIM1_ICSelection_DirectTI, ICFilter);
   \                     ??TIM1_TIxExternalClockConfig_0:
   \   000017 35 01 ....   MOV       S:?b0, #0x1
   \   00001B B6 ..        LD        A, S:?b2
   \   00001D 8D ......    CALLF     TI1_Config
   2289            }
   2290          
   2291            /* Select the Trigger source */
   2292            TIM1_SelectInputTrigger((TIM1_TRGSelection_TypeDef)TIM1_TIxExternalCLKSource);
   \                     ??TIM1_TIxExternalClockConfig_1:
   \   000021 B6 ..        LD        A, S:?b3
   \   000023 8D ......    CALLF     TIM1_SelectInputTrigger
   2293          
   2294            /* Select the External clock mode1 */
   2295            TIM1->SMCR |= (uint8_t)(TIM1_SlaveMode_External1);
   \   000027 C6 52B2      LD        A, L:0x52b2
   \   00002A AA 07        OR        A, #0x7
   \   00002C C7 52B2      LD        L:0x52b2, A
   2296          }
   \   00002F 87           RETF
   2297          
   2298          /**
   2299            * @brief  Configures the TIM1 External clock Mode1.
   2300            * @param  TIM1_ExtTRGPrescaler specifies the external Trigger Prescaler.
   2301            *          This parameter can be one of the following values:
   2302            *            @arg TIM1_ExtTRGPSC_OFF
   2303            *            @arg TIM1_ExtTRGPSC_DIV2
   2304            *            @arg TIM1_ExtTRGPSC_DIV4
   2305            *            @arg TIM1_ExtTRGPSC_DIV8.
   2306            * @param  TIM1_ExtTRGPolarity specifies the external Trigger Polarity.
   2307            *          This parameter can be one of the following values:
   2308            *            @arg TIM1_ExtTRGPolarity_Inverted
   2309            *            @arg TIM1_ExtTRGPolarity_NonInverted
   2310            * @param  ExtTRGFilter specifies the External Trigger Filter.
   2311            *          This parameter must be a value between 0x00 and 0x0F
   2312            * @retval None
   2313            */

   \                                 In section .far_func.text, align 1
   2314          void TIM1_ETRClockMode1Config(TIM1_ExtTRGPSC_TypeDef TIM1_ExtTRGPrescaler,
   2315                                        TIM1_ExtTRGPolarity_TypeDef TIM1_ExtTRGPolarity,
   2316                                        uint8_t ExtTRGFilter)
   2317          {
   2318            /* Check the parameters */
   2319            assert_param(IS_TIM1_EXT_PRESCALER(TIM1_ExtTRGPrescaler));
   2320            assert_param(IS_TIM1_EXT_POLARITY(TIM1_ExtTRGPolarity));
   2321            assert_param(IS_TIM1_EXT_TRG_FILTER(ExtTRGFilter));
   2322          
   2323            /* Configure the ETR Clock source */
   2324            TIM1_ETRConfig(TIM1_ExtTRGPrescaler, TIM1_ExtTRGPolarity, ExtTRGFilter);
   \                     TIM1_ETRClockMode1Config:
   \   000000 8D ......    CALLF     TIM1_ETRConfig
   2325          
   2326            /* Select the External clock mode1 & Select the Trigger selection : ETRF */
   2327            TIM1->SMCR = (uint8_t)((uint8_t)(TIM1->SMCR & (uint8_t)(~(TIM1_SMCR_SMS | TIM1_SMCR_TS)))
   2328                                   | (uint8_t)((uint8_t)TIM1_SlaveMode_External1 | (uint8_t) TIM1_TRGSelection_ETRF));
   \   000004 C6 52B2      LD        A, L:0x52b2
   \   000007 AA 77        OR        A, #0x77
   \   000009 C7 52B2      LD        L:0x52b2, A
   2329          }
   \   00000C 87           RETF
   2330          
   2331          /**
   2332            * @brief  Configures the TIM1 External clock Mode2.
   2333            * @param  TIM1_ExtTRGPrescaler specifies the external Trigger Prescaler.
   2334            *          This parameter can be one of the following values:
   2335            *            @arg TIM1_ExtTRGPSC_OFF
   2336            *            @arg TIM1_ExtTRGPSC_DIV2
   2337            *            @arg TIM1_ExtTRGPSC_DIV4
   2338            *            @arg TIM1_ExtTRGPSC_DIV8.
   2339            * @param  TIM1_ExtTRGPolarity specifies the external Trigger Polarity.
   2340            *          This parameter can be one of the following values:
   2341            *            @arg TIM1_ExtTRGPolarity_Inverted
   2342            *            @arg TIM1_ExtTRGPolarity_NonInverted
   2343            * @param  ExtTRGFilter specifies the External Trigger Filter.
   2344            *          This parameter must be a value between 0x00 and 0x0F
   2345            * @retval None
   2346            */

   \                                 In section .far_func.text, align 1
   2347          void TIM1_ETRClockMode2Config(TIM1_ExtTRGPSC_TypeDef TIM1_ExtTRGPrescaler,
   2348                                        TIM1_ExtTRGPolarity_TypeDef TIM1_ExtTRGPolarity,
   2349                                        uint8_t ExtTRGFilter)
   2350          {
   2351            /* Check the parameters */
   2352            assert_param(IS_TIM1_EXT_PRESCALER(TIM1_ExtTRGPrescaler));
   2353            assert_param(IS_TIM1_EXT_POLARITY(TIM1_ExtTRGPolarity));
   2354          
   2355            /* Configure the ETR Clock source */
   2356            TIM1_ETRConfig(TIM1_ExtTRGPrescaler, TIM1_ExtTRGPolarity, ExtTRGFilter);
   \                     TIM1_ETRClockMode2Config:
   \   000000 8D ......    CALLF     TIM1_ETRConfig
   2357          
   2358            /* Enable the External clock mode2 */
   2359            TIM1->ETR |= TIM1_ETR_ECE;
   \   000004 721C 52B3    BSET      L:0x52b3, #0x6
   2360          }
   \   000008 87           RETF
   2361          
   2362          /**
   2363            * @}
   2364            */
   2365          
   2366          /** @defgroup TIM1_Group6 Synchronization management functions
   2367           *  @brief    Synchronization management functions 
   2368           *
   2369          @verbatim   
   2370           ===============================================================================
   2371                                 Synchronization management functions
   2372           ===============================================================================  
   2373                             
   2374                 ===================================================================      
   2375                        TIM1 Driver: how to use it in synchronization Mode
   2376                 =================================================================== 
   2377                 Case of two/several Timers
   2378                 **************************
   2379                 1. If TIM1 is used as master to other timers use the following functions:
   2380                    - TIM1_SelectOutputTrigger()
   2381                    - TIM1_SelectMasterSlaveMode()
   2382                 2. If TIM1 is used as slave to other timers use the following functions:
   2383                    - TIM1_SelectInputTrigger()
   2384                    - TIM1_SelectSlaveMode()
   2385                    
   2386                 Case of Timers and external trigger (TRIG pin)
   2387                 ********************************************       
   2388                 1. Configure the External trigger using TIM1_ETRConfig()
   2389                 2. Configure the Slave Timer using the following functions:
   2390                    - TIM1_SelectInputTrigger()
   2391                    - TIM1_SelectSlaveMode()
   2392          
   2393          @endverbatim
   2394            * @{
   2395            */
   2396          
   2397          /**
   2398            * @brief  Selects the TIM1 Input Trigger source.
   2399            * @param  TIM1_InputTriggerSource specifies Input Trigger source.
   2400            *          This parameter can be one of the following values:
   2401            *            @arg TIM1_TRGSelection_TIM4
   2402            *            @arg TIM1_TRGSelection_TIM3
   2403            *            @arg TIM1_TRGSelection_TIM2
   2404            *            @arg TIM1_TRGSelection_TI1F_ED: TI1 Edge Detector
   2405            *            @arg TIM1_TRGSelection_TI1FP1: Filtered Timer Input 1
   2406            *            @arg TIM1_TRGSelection_TI2FP2: Filtered Timer Input 2
   2407            *            @arg TIM1_TRGSelection_ETRF: External Trigger input
   2408            * @retval None
   2409            */

   \                                 In section .far_func.text, align 1
   2410          void TIM1_SelectInputTrigger(TIM1_TRGSelection_TypeDef TIM1_InputTriggerSource)
   2411          {
   \                     TIM1_SelectInputTrigger:
   \   000000 B7 ..        LD        S:?b0, A
   2412            /* Check the parameters */
   2413            assert_param(IS_TIM1_TRIGGER_SELECTION(TIM1_InputTriggerSource));
   2414          
   2415            /* Select the Tgigger Source */
   2416            TIM1->SMCR = (uint8_t)((uint8_t)(TIM1->SMCR & (uint8_t)(~TIM1_SMCR_TS)) | (uint8_t)TIM1_InputTriggerSource);
   \   000002 C6 52B2      LD        A, L:0x52b2
   \   000005 A4 8F        AND       A, #0x8f
   \   000007 BA ..        OR        A, S:?b0
   \   000009 C7 52B2      LD        L:0x52b2, A
   2417          }
   \   00000C 87           RETF
   2418          
   2419          /**
   2420            * @brief  Selects the TIM1 Trigger Output Mode.
   2421            * @param  TIM1_TRGOSource specifies the Trigger Output source.
   2422            *          This parameter can be one of the following values
   2423            *            @arg TIM1_TRGOSource_Reset
   2424            *            @arg TIM1_TRGOSource_Enable
   2425            *            @arg TIM1_TRGOSource_Update
   2426            *            @arg TIM1_TRGOSource_OC1
   2427            *            @arg TIM1_TRGOSource_OC1REF
   2428            *            @arg TIM1_TRGOSource_OC2REF
   2429            *            @arg TIM1_TRGOSource_OC3REF
   2430            *            @arg TIM1_TRGOSource_OC4REF
   2431            * @retval None
   2432            */

   \                                 In section .far_func.text, align 1
   2433          void TIM1_SelectOutputTrigger(TIM1_TRGOSource_TypeDef TIM1_TRGOSource)
   2434          {
   \                     TIM1_SelectOutputTrigger:
   \   000000 B7 ..        LD        S:?b0, A
   2435            /* Check the parameters */
   2436            assert_param(IS_TIM1_TRGO_SOURCE(TIM1_TRGOSource));
   2437            /* Reset the MMS Bits & Select the TRGO source */
   2438            TIM1->CR2 = (uint8_t)((uint8_t)(TIM1->CR2 & (uint8_t)(~TIM1_CR2_MMS)) | (uint8_t) TIM1_TRGOSource);
   \   000002 C6 52B1      LD        A, L:0x52b1
   \   000005 A4 8F        AND       A, #0x8f
   \   000007 BA ..        OR        A, S:?b0
   \   000009 C7 52B1      LD        L:0x52b1, A
   2439          }
   \   00000C 87           RETF
   2440          
   2441          /**
   2442            * @brief  Selects the TIM1 Slave Mode.
   2443            * @param  TIM1_SlaveMode specifies the TIM1 Slave Mode.
   2444            *          This parameter can be one of the following values
   2445            *            @arg TIM1_SlaveMode_Reset
   2446            *            @arg TIM1_SlaveMode_Gated
   2447            *            @arg TIM1_SlaveMode_Trigger
   2448            *            @arg TIM1_SlaveMode_External1
   2449            * @retval None
   2450            */

   \                                 In section .far_func.text, align 1
   2451          void TIM1_SelectSlaveMode(TIM1_SlaveMode_TypeDef TIM1_SlaveMode)
   2452          {
   \                     TIM1_SelectSlaveMode:
   \   000000 B7 ..        LD        S:?b0, A
   2453            /* Check the parameters */
   2454            assert_param(IS_TIM1_SLAVE_MODE(TIM1_SlaveMode));
   2455          
   2456            /* Reset the SMS Bits and Select the Slave Mode */
   2457            TIM1->SMCR = (uint8_t)((uint8_t)(TIM1->SMCR & (uint8_t)(~TIM1_SMCR_SMS)) | (uint8_t)TIM1_SlaveMode);
   \   000002 C6 52B2      LD        A, L:0x52b2
   \   000005 A4 F8        AND       A, #0xf8
   \   000007 BA ..        OR        A, S:?b0
   \   000009 C7 52B2      LD        L:0x52b2, A
   2458          
   2459          }
   \   00000C 87           RETF
   2460          
   2461          /**
   2462            * @brief  Sets or Resets the TIM1 Master/Slave Mode.
   2463            * @param  NewState new state of the synchronization between TIM1 and its slaves
   2464            *         (through TRGO). This parameter can be ENABLE or DISABLE.
   2465            * @retval None
   2466            */

   \                                 In section .far_func.text, align 1
   2467          void TIM1_SelectMasterSlaveMode(FunctionalState NewState)
   2468          {
   2469            /* Check the parameters */
   2470            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2471          
   2472            /* Set or Reset the MSM Bit */
   2473            if (NewState != DISABLE)
   \                     TIM1_SelectMasterSlaveMode:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM1_SelectMasterSlaveMode_0
   2474            {
   2475              TIM1->SMCR |= TIM1_SMCR_MSM;
   \   000003 721E 52B2    BSET      L:0x52b2, #0x7
   \   000007 87           RETF
   2476            }
   2477            else
   2478            {
   2479              TIM1->SMCR &= (uint8_t)(~TIM1_SMCR_MSM);
   \                     ??TIM1_SelectMasterSlaveMode_0:
   \   000008 721F 52B2    BRES      L:0x52b2, #0x7
   2480            }
   2481          }
   \   00000C 87           RETF
   2482          
   2483          /**
   2484            * @brief  Configures the TIM1 External Trigger.
   2485            * @param  TIM1_ExtTRGPrescaler specifies the external Trigger Prescaler.
   2486            *          This parameter can be one of the following values:
   2487            *            @arg TIM1_ExtTRGPSC_OFF
   2488            *            @arg TIM1_ExtTRGPSC_DIV2
   2489            *            @arg TIM1_ExtTRGPSC_DIV4
   2490            *            @arg TIM1_ExtTRGPSC_DIV8.
   2491            * @param  TIM1_ExtTRGPolarity specifies the external Trigger Polarity.
   2492            *          This parameter can be one of the following values:
   2493            *            @arg TIM1_ExtTRGPolarity_Inverted
   2494            *            @arg TIM1_ExtTRGPolarity_NonInverted
   2495            * @param  ExtTRGFilter specifies the External Trigger Filter.
   2496            *          This parameter must be a value between 0x00 and 0x0F
   2497            * @retval None
   2498            */

   \                                 In section .far_func.text, align 1
   2499          void TIM1_ETRConfig(TIM1_ExtTRGPSC_TypeDef TIM1_ExtTRGPrescaler,
   2500                              TIM1_ExtTRGPolarity_TypeDef TIM1_ExtTRGPolarity,
   2501                              uint8_t ExtTRGFilter)
   2502          {
   \                     TIM1_ETRConfig:
   \   000000 B7 ..        LD        S:?b2, A
   \   000002 B6 ..        LD        A, S:?b0
   2503            assert_param(IS_TIM1_EXT_TRG_FILTER(ExtTRGFilter));
   2504          
   2505            /* Set the Prescaler, the Filter value and the Polarity */
   2506            TIM1->ETR |= (uint8_t)((uint8_t)((uint8_t) TIM1_ExtTRGPrescaler
   2507                                             | (uint8_t) TIM1_ExtTRGPolarity)
   2508                                   | (uint8_t) ExtTRGFilter);
   \   000004 BA ..        OR        A, S:?b2
   \   000006 BA ..        OR        A, S:?b1
   \   000008 CA 52B3      OR        A, L:0x52b3
   \   00000B C7 52B3      LD        L:0x52b3, A
   2509          }
   \   00000E 87           RETF
   2510          
   2511          /**
   2512            * @}
   2513            */
   2514          
   2515          /** @defgroup TIM1_Group7 Specific interface management functions
   2516           *  @brief    Specific interface management functions 
   2517           *
   2518          @verbatim   
   2519           ===============================================================================
   2520                              Specific interface management functions
   2521           ===============================================================================  
   2522          
   2523          @endverbatim
   2524            * @{
   2525            */
   2526          
   2527          /**
   2528            * @brief  Configures the TIM1 Encoder Interface.
   2529            * @param  TIM1_EncoderMode specifies the TIM1 Encoder Mode.
   2530            *          This parameter can be one of the following values
   2531            *            @arg TIM1_EncoderMode_TI1: Counter counts on TI1FP1 edge
   2532            *          depending on TI2FP2 level.
   2533            *            @arg TIM1_EncoderMode_TI2: Counter counts on TI2FP2 edge
   2534            *         depending on TI1FP1 level.
   2535            *            @arg TIM1_EncoderMode_TI12: Counter counts on both TI1FP1 and
   2536            *         TI2FP2 edges depending on the level of the other input.
   2537            * @param  TIM1_IC1Polarity specifies the IC1 Polarity.
   2538            *          This parameter can be one of the following values:
   2539            *            @arg TIM1_ICPolarity_Rising: Input capture polarity rising
   2540            *            @arg TIM1_ICPolarity_Falling: Input capture polarity falling
   2541            * @param  TIM1_IC2Polarity specifies the IC2 Polarity.
   2542            *          This parameter can be one of the following values:
   2543            *            @arg TIM1_ICPolarity_Rising: Input capture polarity rising
   2544            *            @arg TIM1_ICPolarity_Falling: Input capture polarity falling
   2545            * @retval None
   2546            */

   \                                 In section .far_func.text, align 1
   2547          void TIM1_EncoderInterfaceConfig(TIM1_EncoderMode_TypeDef TIM1_EncoderMode,
   2548                                           TIM1_ICPolarity_TypeDef TIM1_IC1Polarity,
   2549                                           TIM1_ICPolarity_TypeDef TIM1_IC2Polarity)
   2550          {
   \                     TIM1_EncoderInterfaceConfig:
   \   000000 B7 ..        LD        S:?b2, A
   2551            /* Check the parameters */
   2552            assert_param(IS_TIM1_ENCODER_MODE(TIM1_EncoderMode));
   2553            assert_param(IS_TIM1_IC_POLARITY(TIM1_IC1Polarity));
   2554            assert_param(IS_TIM1_IC_POLARITY(TIM1_IC2Polarity));
   2555          
   2556            /* Set the TI1 and the TI2 Polarities */
   2557            if (TIM1_IC1Polarity != TIM1_ICPolarity_Rising)
   \   000002 3D ..        TNZ       S:?b0
   \   000004 27 06        JREQ      L:??TIM1_EncoderInterfaceConfig_0
   2558            {
   2559              TIM1->CCER1 |= TIM1_CCER1_CC1P;
   \   000006 7212 52BD    BSET      L:0x52bd, #0x1
   \   00000A 20 04        JRA       L:??TIM1_EncoderInterfaceConfig_1
   2560            }
   2561            else
   2562            {
   2563              TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC1P);
   \                     ??TIM1_EncoderInterfaceConfig_0:
   \   00000C 7213 52BD    BRES      L:0x52bd, #0x1
   2564            }
   2565          
   2566            if (TIM1_IC2Polarity != TIM1_ICPolarity_Rising)
   \                     ??TIM1_EncoderInterfaceConfig_1:
   \   000010 3D ..        TNZ       S:?b1
   \   000012 27 06        JREQ      L:??TIM1_EncoderInterfaceConfig_2
   2567            {
   2568              TIM1->CCER1 |= TIM1_CCER1_CC2P;
   \   000014 721A 52BD    BSET      L:0x52bd, #0x5
   \   000018 20 04        JRA       L:??TIM1_EncoderInterfaceConfig_3
   2569            }
   2570            else
   2571            {
   2572              TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC2P);
   \                     ??TIM1_EncoderInterfaceConfig_2:
   \   00001A 721B 52BD    BRES      L:0x52bd, #0x5
   2573            }
   2574            /* Set the encoder Mode */
   2575            TIM1->SMCR = (uint8_t)((uint8_t)(TIM1->SMCR & (uint8_t)(TIM1_SMCR_MSM | TIM1_SMCR_TS)) | (uint8_t) TIM1_EncoderMode);
   \                     ??TIM1_EncoderInterfaceConfig_3:
   \   00001E C6 52B2      LD        A, L:0x52b2
   \   000021 A4 F0        AND       A, #0xf0
   \   000023 BA ..        OR        A, S:?b2
   \   000025 C7 52B2      LD        L:0x52b2, A
   2576          
   2577            /* Select the Capture Compare 1 and the Capture Compare 2 as input */
   2578            TIM1->CCMR1 = (uint8_t)((uint8_t)(TIM1->CCMR1 & (uint8_t)(~TIM1_CCMR_CCxS))  | (uint8_t) CCMR_TIxDirect_Set);
   \   000028 C6 52B9      LD        A, L:0x52b9
   \   00002B A4 FC        AND       A, #0xfc
   \   00002D AA 01        OR        A, #0x1
   \   00002F C7 52B9      LD        L:0x52b9, A
   2579            TIM1->CCMR2 = (uint8_t)((uint8_t)(TIM1->CCMR2 & (uint8_t)(~TIM1_CCMR_CCxS)) | (uint8_t) CCMR_TIxDirect_Set);
   \   000032 C6 52BA      LD        A, L:0x52ba
   \   000035 A4 FC        AND       A, #0xfc
   \   000037 AA 01        OR        A, #0x1
   \   000039 C7 52BA      LD        L:0x52ba, A
   2580          
   2581          }
   \   00003C 87           RETF
   2582          
   2583          /**
   2584            * @brief  Enables or Disables the TIM’s Hall sensor interface.
   2585            * @param  NewState : The new state of the TIM1 Hall sensor interface.
   2586            *          This parameter can be ENABLE or DISABLE
   2587            * @retval None
   2588            */

   \                                 In section .far_func.text, align 1
   2589          void TIM1_SelectHallSensor(FunctionalState NewState)
   2590          {
   2591            /* Check the parameters */
   2592            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2593          
   2594            /* Set or Reset the TI1S Bit */
   2595            if (NewState != DISABLE)
   \                     TIM1_SelectHallSensor:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??TIM1_SelectHallSensor_0
   2596            {
   2597              TIM1->CR2 |= TIM1_CR2_TI1S;
   \   000003 721E 52B1    BSET      L:0x52b1, #0x7
   \   000007 87           RETF
   2598            }
   2599            else
   2600            {
   2601              TIM1->CR2 &= (uint8_t)(~TIM1_CR2_TI1S);
   \                     ??TIM1_SelectHallSensor_0:
   \   000008 721F 52B1    BRES      L:0x52b1, #0x7
   2602            }
   2603          }
   \   00000C 87           RETF
   2604          
   2605          /**
   2606            * @}
   2607            */
   2608          
   2609          /**
   2610            * @brief  Configure the TI1 as Input.
   2611            * @param  TIM1_ICPolarity  The Input Polarity.
   2612            *          This parameter can be one of the following values:
   2613            *            @arg TIM1_ICPolarity_Rising: Input capture polarity rising
   2614            *            @arg TIM1_ICPolarity_Falling: Input capture polarity falling
   2615            * @param  TIM1_ICSelection specifies the input to be used.
   2616            *          This parameter can be one of the following values:
   2617            *            @arg TIM1_ICSelection_DirectTI: TIM1 Input 1 is selected to be connected to IC1.
   2618            *            @arg TIM1_ICSelection_IndirectTI: TIM1 Input 1 is selected to be connected to IC2.
   2619            * @param  TIM1_ICFilter Specifies the Input Capture Filter.
   2620            *          This parameter must be a value between 0x00 and 0x0F.
   2621            * @retval None
   2622            */

   \                                 In section .far_func.text, align 1
   2623          static void TI1_Config(uint8_t TIM1_ICPolarity, uint8_t TIM1_ICSelection, uint8_t TIM1_ICFilter)
   2624          {
   \                     TI1_Config:
   \   000000 B7 ..        LD        S:?b2, A
   \   000002 B6 ..        LD        A, S:?b1
   2625          
   2626            /* Disable the Channel 1: Reset the CCE Bit */
   2627            TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC1E);
   \   000004 7211 52BD    BRES      L:0x52bd, #0x0
   2628          
   2629            /* Select the Input and set the filter */
   2630            TIM1->CCMR1 = (uint8_t)((uint8_t)(TIM1->CCMR1 & (uint8_t)(~( TIM1_CCMR_CCxS | TIM1_CCMR_ICxF)))
   2631                                    | (uint8_t)(( (TIM1_ICSelection)) | ((uint8_t)( TIM1_ICFilter << 4))));
   \   000008 4E           SWAP      A
   \   000009 A4 F0        AND       A, #0xf0
   \   00000B BA ..        OR        A, S:?b0
   \   00000D 88           PUSH      A
   \   00000E C6 52B9      LD        A, L:0x52b9
   \   000011 A4 0C        AND       A, #0xc
   \   000013 B7 ..        LD        S:?b1, A
   \   000015 84           POP       A
   \   000016 BA ..        OR        A, S:?b1
   \   000018 C7 52B9      LD        L:0x52b9, A
   2632          
   2633          
   2634          
   2635            /* Select the Polarity */
   2636            if (TIM1_ICPolarity != TIM1_ICPolarity_Rising)
   \   00001B 3D ..        TNZ       S:?b2
   \   00001D 27 06        JREQ      L:??TI1_Config_0
   2637            {
   2638              TIM1->CCER1 |= TIM1_CCER1_CC1P;
   \   00001F 7212 52BD    BSET      L:0x52bd, #0x1
   \   000023 20 04        JRA       L:??TI1_Config_1
   2639            }
   2640            else
   2641            {
   2642              TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC1P);
   \                     ??TI1_Config_0:
   \   000025 7213 52BD    BRES      L:0x52bd, #0x1
   2643            }
   2644          
   2645            /* Set the CCE Bit */
   2646            TIM1->CCER1 |=  TIM1_CCER1_CC1E;
   \                     ??TI1_Config_1:
   \   000029 7210 52BD    BSET      L:0x52bd, #0x0
   2647          }
   \   00002D 87           RETF
   2648          
   2649          /**
   2650            * @brief  Configure the TI2 as Input.
   2651            * @param  TIM1_ICPolarity  The Input Polarity.
   2652            *          This parameter can be one of the following values:
   2653            *            @arg TIM1_ICPolarity_Rising: Input capture polarity rising
   2654            *            @arg TIM1_ICPolarity_Falling: Input capture polarity falling
   2655            * @param  TIM1_ICSelection specifies the input to be used.
   2656            *          This parameter can be one of the following values:
   2657            *            @arg TIM1_ICSelection_DirectTI: TIM1 Input 2 is selected to be connected to IC2.
   2658            *            @arg TIM1_ICSelection_IndirectTI: TIM1 Input 2 is selected to be connected to IC1.
   2659            * @param  TIM1_ICFilter Specifies the Input Capture Filter.
   2660            *          This parameter must be a value between 0x00 and 0x0F.
   2661            * @retval None
   2662            */

   \                                 In section .far_func.text, align 1
   2663          static void TI2_Config(uint8_t TIM1_ICPolarity, uint8_t TIM1_ICSelection, uint8_t TIM1_ICFilter)
   2664          {
   \                     TI2_Config:
   \   000000 B7 ..        LD        S:?b2, A
   \   000002 B6 ..        LD        A, S:?b1
   2665            /* Disable the Channel 2: Reset the CCE Bit */
   2666            TIM1->CCER1 &=  (uint8_t)(~TIM1_CCER1_CC2E);
   \   000004 7219 52BD    BRES      L:0x52bd, #0x4
   2667          
   2668            /* Select the Input and set the filter */
   2669            TIM1->CCMR2  = (uint8_t)((uint8_t)(TIM1->CCMR2 & (uint8_t)(~( TIM1_CCMR_CCxS | TIM1_CCMR_ICxF)))
   2670                                     | (uint8_t)(( (TIM1_ICSelection)) | ((uint8_t)( TIM1_ICFilter << 4))));
   \   000008 4E           SWAP      A
   \   000009 A4 F0        AND       A, #0xf0
   \   00000B BA ..        OR        A, S:?b0
   \   00000D 88           PUSH      A
   \   00000E C6 52BA      LD        A, L:0x52ba
   \   000011 A4 0C        AND       A, #0xc
   \   000013 B7 ..        LD        S:?b1, A
   \   000015 84           POP       A
   \   000016 BA ..        OR        A, S:?b1
   \   000018 C7 52BA      LD        L:0x52ba, A
   2671            /* Select the Polarity */
   2672            if (TIM1_ICPolarity != TIM1_ICPolarity_Rising)
   \   00001B 3D ..        TNZ       S:?b2
   \   00001D 27 06        JREQ      L:??TI2_Config_0
   2673            {
   2674              TIM1->CCER1 |= TIM1_CCER1_CC2P;
   \   00001F 721A 52BD    BSET      L:0x52bd, #0x5
   \   000023 20 04        JRA       L:??TI2_Config_1
   2675            }
   2676            else
   2677            {
   2678              TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC2P);
   \                     ??TI2_Config_0:
   \   000025 721B 52BD    BRES      L:0x52bd, #0x5
   2679            }
   2680            /* Set the CCE Bit */
   2681            TIM1->CCER1 |=  TIM1_CCER1_CC2E;
   \                     ??TI2_Config_1:
   \   000029 7218 52BD    BSET      L:0x52bd, #0x4
   2682          }
   \   00002D 87           RETF
   2683          
   2684          /**
   2685            * @brief  Configure the TI3 as Input.
   2686            * @param  TIM1_ICPolarity  The Input Polarity.
   2687            *          This parameter can be one of the following values:
   2688            *            @arg TIM1_ICPolarity_Rising: Input capture polarity rising
   2689            *            @arg TIM1_ICPolarity_Falling: Input capture polarity falling
   2690            * @param  TIM1_ICSelection specifies the input to be used.
   2691            *          This parameter can be one of the following values:
   2692            *            @arg TIM1_ICSelection_DirectTI: TIM1 Input 3 is selected to
   2693            *                         be connected to IC3.
   2694            * @param  TIM1_ICFilter Specifies the Input Capture Filter.
   2695            *          This parameter must be a value between 0x00 and 0x0F.
   2696            * @retval None
   2697            */

   \                                 In section .far_func.text, align 1
   2698          static void TI3_Config(uint8_t TIM1_ICPolarity, uint8_t TIM1_ICSelection, uint8_t TIM1_ICFilter)
   2699          {
   \                     TI3_Config:
   \   000000 B7 ..        LD        S:?b2, A
   \   000002 B6 ..        LD        A, S:?b1
   2700            /* Disable the Channel 3: Reset the CCE Bit */
   2701            TIM1->CCER2 &=  (uint8_t)(~TIM1_CCER2_CC3E);
   \   000004 7211 52BE    BRES      L:0x52be, #0x0
   2702          
   2703            /* Select the Input and set the filter */
   2704            TIM1->CCMR3 = (uint8_t)((uint8_t)(TIM1->CCMR3 & (uint8_t)(~( TIM1_CCMR_CCxS | TIM1_CCMR_ICxF)))
   2705                                    | (uint8_t)(( (TIM1_ICSelection)) | ((uint8_t)( TIM1_ICFilter << 4))));
   \   000008 4E           SWAP      A
   \   000009 A4 F0        AND       A, #0xf0
   \   00000B BA ..        OR        A, S:?b0
   \   00000D 88           PUSH      A
   \   00000E C6 52BB      LD        A, L:0x52bb
   \   000011 A4 0C        AND       A, #0xc
   \   000013 B7 ..        LD        S:?b1, A
   \   000015 84           POP       A
   \   000016 BA ..        OR        A, S:?b1
   \   000018 C7 52BB      LD        L:0x52bb, A
   2706          
   2707            /* Select the Polarity */
   2708            if (TIM1_ICPolarity != TIM1_ICPolarity_Rising)
   \   00001B 3D ..        TNZ       S:?b2
   \   00001D 27 06        JREQ      L:??TI3_Config_0
   2709            {
   2710              TIM1->CCER2 |= TIM1_CCER2_CC3P;
   \   00001F 7212 52BE    BSET      L:0x52be, #0x1
   \   000023 20 04        JRA       L:??TI3_Config_1
   2711            }
   2712            else
   2713            {
   2714              TIM1->CCER2 &= (uint8_t)(~TIM1_CCER2_CC3P);
   \                     ??TI3_Config_0:
   \   000025 7213 52BE    BRES      L:0x52be, #0x1
   2715            }
   2716            /* Set the CCE Bit */
   2717            TIM1->CCER2 |=  TIM1_CCER2_CC3E;
   \                     ??TI3_Config_1:
   \   000029 7210 52BE    BSET      L:0x52be, #0x0
   2718          }
   \   00002D 87           RETF
   2719          
   2720          /**
   2721            * @brief  Configure the TI4 as Input.
   2722            * @param  TIM1_ICPolarity  The Input Polarity.
   2723            *          This parameter can be one of the following values:
   2724            *            @arg TIM1_ICPolarity_Rising: Input capture polarity rising
   2725            *            @arg TIM1_ICPolarity_Falling: Input capture polarity falling
   2726            * @param  TIM1_ICSelection specifies the input to be used.
   2727            *          This parameter can be one of the following values:
   2728            *            @arg TIM1_ICSelection_IndirectTI: TIM1 Input 4 is selected to be connected to IC3.
   2729            * @param  TIM1_ICFilter Specifies the Input Capture Filter.
   2730            *          This parameter must be a value between 0x00 and 0x0F.
   2731            * @retval None
   2732            */

   \                                 In section .far_func.text, align 1
   2733          static void TI4_Config(uint8_t TIM1_ICPolarity, uint8_t TIM1_ICSelection, uint8_t TIM1_ICFilter)
   2734          {
   \                     TI4_Config:
   \   000000 B7 ..        LD        S:?b2, A
   \   000002 B6 ..        LD        A, S:?b1
   2735          
   2736            /* Disable the Channel 4: Reset the CCE Bit */
   2737            TIM1->CCER2 &=  (uint8_t)(~TIM1_CCER2_CC4E);
   \   000004 7219 52BE    BRES      L:0x52be, #0x4
   2738          
   2739            /* Select the Input and set the filter */
   2740            TIM1->CCMR4 = (uint8_t)((uint8_t)(TIM1->CCMR4 & (uint8_t)(~( TIM1_CCMR_CCxS | TIM1_CCMR_ICxF)))
   2741                                    | (uint8_t)(( (TIM1_ICSelection)) | ((uint8_t)( TIM1_ICFilter << 4))));
   \   000008 4E           SWAP      A
   \   000009 A4 F0        AND       A, #0xf0
   \   00000B BA ..        OR        A, S:?b0
   \   00000D 88           PUSH      A
   \   00000E C6 52BC      LD        A, L:0x52bc
   \   000011 A4 0C        AND       A, #0xc
   \   000013 B7 ..        LD        S:?b1, A
   \   000015 84           POP       A
   \   000016 BA ..        OR        A, S:?b1
   \   000018 C7 52BC      LD        L:0x52bc, A
   2742          
   2743            /* Select the Polarity */
   2744            if (TIM1_ICPolarity != TIM1_ICPolarity_Rising)
   \   00001B 3D ..        TNZ       S:?b2
   \   00001D 27 06        JREQ      L:??TI4_Config_0
   2745            {
   2746              TIM1->CCER2 |= TIM1_CCER2_CC4P;
   \   00001F 721A 52BE    BSET      L:0x52be, #0x5
   \   000023 20 04        JRA       L:??TI4_Config_1
   2747            }
   2748            else
   2749            {
   2750              TIM1->CCER2 &= (uint8_t)(~TIM1_CCER2_CC4P);
   \                     ??TI4_Config_0:
   \   000025 721B 52BE    BRES      L:0x52be, #0x5
   2751            }
   2752          
   2753            /* Set the CCE Bit */
   2754            TIM1->CCER2 |=  TIM1_CCER2_CC4E;
   \                     ??TI4_Config_1:
   \   000029 7218 52BE    BSET      L:0x52be, #0x4
   2755          }
   \   00002D 87           RETF
   2756          
   2757          
   2758          /**
   2759            * @}
   2760            */ 
   2761          
   2762          /**
   2763            * @}
   2764            */ 
   2765            
   2766          /**
   2767            * @}
   2768            */
   2769          
   2770          /**
   2771            * @}
   2772            */
   2773          
   2774          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Section sizes:

   Bytes  Function/Label
   -----  --------------
      46  TI1_Config
      46  TI2_Config
      46  TI3_Config
      46  TI4_Config
      13  TIM1_ARRPreloadConfig
      27  TIM1_BDTRConfig
      13  TIM1_CCPreloadControl
      67  TIM1_CCxCmd
      49  TIM1_CCxNCmd
      15  TIM1_ClearFlag
       5  TIM1_ClearITPendingBit
      13  TIM1_ClearOC1Ref
      13  TIM1_ClearOC2Ref
      13  TIM1_ClearOC3Ref
      13  TIM1_ClearOC4Ref
      13  TIM1_Cmd
      13  TIM1_CounterModeConfig
      13  TIM1_CtrlPWMOutputs
      19  TIM1_DMACmd
       9  TIM1_DMAConfig
     153  TIM1_DeInit
      13  TIM1_ETRClockMode1Config
       9  TIM1_ETRClockMode2Config
      15  TIM1_ETRConfig
      61  TIM1_EncoderInterfaceConfig
      13  TIM1_ForcedOC1Config
      13  TIM1_ForcedOC2Config
      13  TIM1_ForcedOC3Config
       4  TIM1_GenerateEvent
      43  TIM1_GetCapture1
      43  TIM1_GetCapture2
      43  TIM1_GetCapture3
      43  TIM1_GetCapture4
      43  TIM1_GetCounter
      39  TIM1_GetFlagStatus
      41  TIM1_GetITStatus
      27  TIM1_GetPrescaler
      71  TIM1_ICInit
      19  TIM1_ITConfig
       9  TIM1_InternalClockConfig
      13  TIM1_OC1FastConfig
     103  TIM1_OC1Init
      13  TIM1_OC1NPolarityConfig
      13  TIM1_OC1PolarityConfig
      13  TIM1_OC1PreloadConfig
      13  TIM1_OC2FastConfig
     103  TIM1_OC2Init
      13  TIM1_OC2NPolarityConfig
      13  TIM1_OC2PolarityConfig
      13  TIM1_OC2PreloadConfig
      13  TIM1_OC3FastConfig
     103  TIM1_OC3Init
      13  TIM1_OC3NPolarityConfig
      13  TIM1_OC3PolarityConfig
      13  TIM1_OC3PreloadConfig
      13  TIM1_OC4PreloadConfig
     126  TIM1_PWMIConfig
      22  TIM1_PrescalerConfig
      13  TIM1_SelectCCDMA
      13  TIM1_SelectCOM
      13  TIM1_SelectHallSensor
      13  TIM1_SelectInputTrigger
      13  TIM1_SelectMasterSlaveMode
      11  TIM1_SelectOCREFClear
      52  TIM1_SelectOCxM
      13  TIM1_SelectOnePulseMode
      13  TIM1_SelectOutputTrigger
      13  TIM1_SelectSlaveMode
      15  TIM1_SetAutoreload
      15  TIM1_SetCompare1
      15  TIM1_SetCompare2
      15  TIM1_SetCompare3
      15  TIM1_SetCompare4
      15  TIM1_SetCounter
      13  TIM1_SetIC1Prescaler
      13  TIM1_SetIC2Prescaler
      13  TIM1_SetIC3Prescaler
      13  TIM1_SetIC4Prescaler
      48  TIM1_TIxExternalClockConfig
      45  TIM1_TimeBaseInit
      13  TIM1_UpdateDisableConfig
      13  TIM1_UpdateRequestConfig

 
 2 261 bytes in section .far_func.text
 
 2 261 bytes of CODE memory

Errors: none
Warnings: none
