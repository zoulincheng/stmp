###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.42.1.142 for STM8               01/Jul/2016  17:36:13 #
# Copyright 2010-2013 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  E:\hwpro-2016\20160627_L\drivers\iic.c                   #
#    Command line =  E:\hwpro-2016\20160627_L\drivers\iic.c -e -Ol --no_cse   #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_cross_call --debug --code_model medium              #
#                    --data_model medium -o E:\hwpro-2016\20160627_L\iar\Debu #
#                    g\Obj\ --dlib_config "C:\Program Files (x86)\IAR         #
#                    Systems\Embedded Workbench 6.5\stm8\LIB\dlstm8mmn.h" -D  #
#                    STM8L15X_MD -lC E:\hwpro-2016\20160627_L\iar\Debug\List\ #
#                     -I E:\hwpro-2016\20160627_L\iar\..\stm8l15x_lib\inc\    #
#                    -I E:\hwpro-2016\20160627_L\iar\..\user\inc\ -I          #
#                    E:\hwpro-2016\20160627_L\iar\..\utils\xprintf\ -I        #
#                    E:\hwpro-2016\20160627_L\iar\..\drivers\ -I              #
#                    E:\hwpro-2016\20160627_L\iar\..\utils\ -I                #
#                    E:\hwpro-2016\20160627_L\iar\..\app\ --vregs 16          #
#    List file    =  E:\hwpro-2016\20160627_L\iar\Debug\List\iic.lst          #
#    Object file  =  E:\hwpro-2016\20160627_L\iar\Debug\Obj\iic.o             #
#                                                                             #
#                                                                             #
###############################################################################

E:\hwpro-2016\20160627_L\drivers\iic.c
      1          #include "stm8l15x.h"
      2          #include "basictype.h"

  typedef unsigned char 	  uint8_t;
                        	  ^
"E:\hwpro-2016\20160627_L\user\inc\basictype.h",8  Warning[Pe301]: typedef
          name has already been declared (with same type)

  typedef unsigned short	  uint16_t;
                        	  ^
"E:\hwpro-2016\20160627_L\user\inc\basictype.h",10  Warning[Pe301]: typedef
          name has already been declared (with same type)

  typedef unsigned char     u8;
                            ^
"E:\hwpro-2016\20160627_L\user\inc\basictype.h",16  Warning[Pe301]: typedef
          name has already been declared (with same type)

  typedef unsigned short    u16;
                            ^
"E:\hwpro-2016\20160627_L\user\inc\basictype.h",17  Warning[Pe301]: typedef
          name has already been declared (with same type)
      3          #include "sysprintf.h"
      4          #include "stm8l15x_it.h"
      5          #include "boardiodef.h"
      6          
      7          

   \                                 In section .far_func.text, align 1
      8          static void delay_xus(U16 us_time)
      9          {
     10          	U16 i;
     11          	for(i = 0; i < us_time; i++)
   \                     delay_xus:
   \   000000 905F         CLRW      Y
   \   000002 20 08        JRA       L:??delay_xus_0
     12          	{
     13          		//    delay_1us();
     14          		asm("NOP");
   \                     ??delay_xus_1:
   \   000004 9D           NOP
     15          		asm("NOP");
   \   000005 9D           NOP
     16          		asm("NOP");
   \   000006 9D           NOP
     17          		asm("NOP");
   \   000007 9D           NOP
     18          		asm("NOP");
   \   000008 9D           NOP
     19          		asm("NOP");
   \   000009 9D           NOP
     20          	}
   \   00000A 905C         INCW      Y
   \                     ??delay_xus_0:
   \   00000C BF ..        LDW       S:?w0, X
   \   00000E 90B3 ..      CPW       Y, S:?w0
   \   000011 25 F1        JRC       L:??delay_xus_1
     21          }
   \   000013 87           RETF
     22          

   \                                 In section .far_func.text, align 1
     23          static void delay_1ms(u16 time)
     24          {
   \                     delay_1ms:
   \   000000 BF ..        LDW       S:?w0, X
     25          	unsigned int i,k;
     26          	for(k = 0; k< time; k++)
   \   000002 905F         CLRW      Y
   \   000004 20 08        JRA       L:??delay_1ms_0
     27          	{
     28          		for(i = 0; i<3190; i++)
   \                     ??delay_1ms_1:
   \   000006 5C           INCW      X
   \                     ??delay_1ms_2:
   \   000007 A3 0C76      CPW       X, #0xc76
   \   00000A 25 FA        JRC       L:??delay_1ms_1
   \   00000C 905C         INCW      Y
   \                     ??delay_1ms_0:
   \   00000E 90B3 ..      CPW       Y, S:?w0
   \   000011 24 03        JRNC      L:??delay_1ms_3
   \   000013 5F           CLRW      X
   \   000014 20 F1        JRA       L:??delay_1ms_2
     29          		{
     30          		}
     31          	}		
     32          }
   \                     ??delay_1ms_3:
   \   000016 87           RETF
     33          
     34          

   \                                 In section .far_func.text, align 1
     35          void iicPinInit(void)
     36          {
     37          	//  GPIO_DeInit(GPIOB);
     38          	/*
     39          	GPIO_Init(GPIOB, GPIO_Pin_0, GPIO_Mode_In_PU_IT);
     40          	GPIO_Init(GPIOB, GPIO_Pin_1, GPIO_Mode_Out_PP_High_Fast);
     41          	GPIO_Init(GPIOB, GPIO_Pin_2, GPIO_Mode_Out_PP_High_Fast);
     42          	GPIOB->CR2 &= (uint8_t)(~(GPIO_Pin_1));
     43          	GPIOB->CR2 &= (uint8_t)(~(GPIO_Pin_2));
     44          	/*/
                 	^
Warning[Pe009]: nested comment is not allowed
     45          	GPIO_Init(IIC_NSDN_PORT, IIC_NSDN_PIN, GPIO_Mode_In_PU_IT);
   \                     iicPinInit:
   \   000000 35 60 ....   MOV       S:?b0, #0x60
   \   000004 A6 01        LD        A, #0x1
   \   000006 AE 5005      LDW       X, #0x5005
   \   000009 8D ......    CALLF     GPIO_Init
     46          	GPIO_Init(IIC_SDA_PORT, IIC_SDA_PIN, GPIO_Mode_Out_PP_High_Fast);
   \   00000D 35 F0 ....   MOV       S:?b0, #0xf0
   \   000011 A6 02        LD        A, #0x2
   \   000013 AE 5005      LDW       X, #0x5005
   \   000016 8D ......    CALLF     GPIO_Init
     47          	GPIO_Init(IIC_SCL_PORT, IIC_SCL_PIN, GPIO_Mode_Out_PP_High_Fast);
   \   00001A 35 F0 ....   MOV       S:?b0, #0xf0
   \   00001E A6 04        LD        A, #0x4
   \   000020 AE 5005      LDW       X, #0x5005
   \   000023 8D ......    CALLF     GPIO_Init
     48          	GPIOB->CR2 &= (uint8_t)(~(IIC_SDA_PIN));
   \   000027 7213 5009    BRES      L:0x5009, #0x1
     49          	GPIOB->CR2 &= (uint8_t)(~(IIC_SCL_PIN));	
   \   00002B 7215 5009    BRES      L:0x5009, #0x2
     50          	EXTI_SetPinSensitivity(EXTI_Pin_0, EXTI_Trigger_Falling);
   \   00002F 35 02 ....   MOV       S:?b0, #0x2
   \   000033 4F           CLR       A
   \   000034 AC ......    JPF       EXTI_SetPinSensitivity
     51          }
     52          
     53          
     54          //***************************************************************************  

   \                                 In section .far_func.text, align 1
     55          void iicBusInit(void)//总线初始化 将总线都拉高一释放总线  发送启动信号前，要先初始化总线。即总有检测到总线空闲才开始发送启动信号  
     56          {  
     57              SCL_OUT();     //SDA、SCL初始化设置为输出
   \                     iicBusInit:
   \   000000 7214 5007    BSET      L:0x5007, #0x2
     58              SDA_OUT();
   \   000004 7212 5007    BSET      L:0x5007, #0x1
     59              nSDN_IN();
   \   000008 7211 5007    BRES      L:0x5007, #0x0
     60              SDA_HIGH(); 
   \   00000C 7212 5005    BSET      L:0x5005, #0x1
     61          	SDA_HIGH(); 
   \   000010 7212 5005    BSET      L:0x5005, #0x1
     62              //DELAY_X_US(5);  
     63              SCL_HIGH();
   \   000014 7214 5005    BSET      L:0x5005, #0x2
     64          	SCL_HIGH();
   \   000018 7214 5005    BSET      L:0x5005, #0x2
     65              //DELAY_X_US(5);  
     66          }
   \   00001C 87           RETF
     67          
     68          //***************************************************************************  

   \                                 In section .far_func.text, align 1
     69          U8 iicBusStart(void)  //开始信号 SCL在高电平期间，SDA一个下降沿则表示启动信号  
     70          {     
     71              unsigned long time_cnt = SCL_WAIT_TIME;
   \                     iicBusStart:
   \   000000 AE 1A80      LDW       X, #0x1a80
   \   000003 BF ..        LDW       S:?w1, X
   \   000005 AE 0006      LDW       X, #0x6
   \   000008 BF ..        LDW       S:?w0, X
     72          	while(!(SDA_OUT_READ() && SCL_OUT_READ()))             
   \                     ??iicBusStart_0:
   \   00000A 7203 5005 05 BTJF      L:0x5005, #0x1, L:??iicBusStart_1
   \   00000F 7204 5005 14 BTJT      L:0x5005, #0x2, L:??iicBusStart_2
     73          	{
     74          		if(!(--time_cnt))
   \                     ??iicBusStart_1:
   \   000014 8D ......    CALLF     L:?dec32_l0_l0
   \   000018 BE ..        LDW       X, S:?w0
   \   00001A A3 0000      CPW       X, #0x0
   \   00001D 26 05        JRNE      L:??iicBusStart_3
   \   00001F BE ..        LDW       X, S:?w1
   \   000021 A3 0000      CPW       X, #0x0
   \                     ??iicBusStart_3:
   \   000024 26 E4        JRNE      L:??iicBusStart_0
     75          		{
     76          			return ERROR;
   \   000026 4F           CLR       A
   \   000027 87           RETF
     77          		}
     78          	}
     79              SDA_LOW();  
   \                     ??iicBusStart_2:
   \   000028 7213 5005    BRES      L:0x5005, #0x1
     80          	SDA_LOW();
   \   00002C 7213 5005    BRES      L:0x5005, #0x1
     81              //DELAY_X_US(5);
     82              return SUCCESS;
   \   000030 A6 01        LD        A, #0x1
   \   000032 87           RETF
     83          } 
     84          
     85          
     86          //***************************************************************************  

   \                                 In section .far_func.text, align 1
     87          void iicBusStop(void)   //停止 SCL在高电平期间，SDA一个上升沿则表示停止信号  
     88          {  
     89          	SDA_LOW();  
   \                     iicBusStop:
   \   000000 7213 5005    BRES      L:0x5005, #0x1
     90          	SDA_LOW();
   \   000004 7213 5005    BRES      L:0x5005, #0x1
     91          	//DELAY_X_US(5);  
     92          	SCL_HIGH();
   \   000008 7214 5005    BSET      L:0x5005, #0x2
     93          	SCL_HIGH();
   \   00000C 7214 5005    BSET      L:0x5005, #0x2
     94          	//DELAY_X_US(5);
     95          	SDA_HIGH(); 
   \   000010 7212 5005    BSET      L:0x5005, #0x1
     96          }
   \   000014 87           RETF
     97          
     98          
     99          //***************************************************************************  

   \                                 In section .far_func.text, align 1
    100          U8 iicWaitACK(void)  //应答 SCL在高电平期间，SDA被从设备拉为低电平表示应答  
    101          {  
   \                     iicWaitACK:
   \   000000 3B ....      PUSH      S:?b8
    102          	U8 i=0;  
   \   000003 3F ..        CLR       S:?b8
    103          	SDA_HIGH();
   \   000005 7212 5005    BSET      L:0x5005, #0x1
    104          	//至多等待250个CPU时钟周期
    105          	SDA_IN();
   \   000009 7213 5007    BRES      L:0x5007, #0x1
    106          	SCL_HIGH(); 
   \   00000D 7214 5005    BSET      L:0x5005, #0x2
    107          	delay_xus(SCL_HALF_PERIOD/2);
   \   000011 AE 0019      LDW       X, #0x19
   \   000014 8D ......    CALLF     delay_xus
    108          	while(SDA_IN_READ())
   \                     ??iicWaitACK_0:
   \   000018 7203 5006 18 BTJF      L:0x5006, #0x1, L:??iicWaitACK_1
    109          	{
    110          		i++;
   \   00001D B6 ..        LD        A, S:?b8
   \   00001F AB 01        ADD       A, #0x1
   \   000021 B7 ..        LD        S:?b8, A
    111          		if(i>250)
   \   000023 B6 ..        LD        A, S:?b8
   \   000025 A1 FB        CP        A, #0xfb
   \   000027 25 EF        JRC       L:??iicWaitACK_0
    112          		{
    113          			SDA_OUT();
   \   000029 7212 5007    BSET      L:0x5007, #0x1
    114          			iicBusStop();
   \   00002D 8D ......    CALLF     iicBusStop
    115          			return 1;	   //没收到应答信号
   \   000031 A6 01        LD        A, #0x1
   \   000033 20 14        JRA       L:??iicWaitACK_2
    116          		}
    117          	}
    118          	delay_xus(SCL_HALF_PERIOD/2);
   \                     ??iicWaitACK_1:
   \   000035 AE 0019      LDW       X, #0x19
   \   000038 8D ......    CALLF     delay_xus
    119          	SCL_LOW();
   \   00003C 7215 5005    BRES      L:0x5005, #0x2
    120          	SDA_OUT();
   \   000040 7212 5007    BSET      L:0x5007, #0x1
    121          	//    SDA_LOW;
    122          	SDA_HIGH();
   \   000044 7212 5005    BSET      L:0x5005, #0x1
    123          	return 0;  		  //收到应答信号
   \   000048 4F           CLR       A
   \                     ??iicWaitACK_2:
   \   000049 32 ....      POP       S:?b8
   \   00004C 87           RETF
    124          } 
    125          
    126          
    127          //***************************************************************************

   \                                 In section .far_func.text, align 1
    128          void iicAck(void)  		 //应答信号
    129          {
    130          	SCL_LOW();
   \                     iicAck:
   \   000000 7215 5005    BRES      L:0x5005, #0x2
    131          	SDA_OUT();
   \   000004 7212 5007    BSET      L:0x5007, #0x1
    132          	SDA_HIGH();
   \   000008 7212 5005    BSET      L:0x5005, #0x1
    133          	delay_xus(SCL_HALF_PERIOD);
   \   00000C AE 0032      LDW       X, #0x32
   \   00000F 8D ......    CALLF     delay_xus
    134          	SDA_LOW();
   \   000013 7213 5005    BRES      L:0x5005, #0x1
    135          	SCL_HIGH();
   \   000017 7214 5005    BSET      L:0x5005, #0x2
    136          	delay_xus(SCL_HALF_PERIOD);
   \   00001B AE 0032      LDW       X, #0x32
   \   00001E 8D ......    CALLF     delay_xus
    137          	SCL_LOW();
   \   000022 7215 5005    BRES      L:0x5005, #0x2
    138          	SDA_HIGH();
   \   000026 7212 5005    BSET      L:0x5005, #0x1
    139           /*
    140          	SCL_LOW;
    141          	SDA_OUT;
    142          	SDA_LOW;
    143          	DELAY_X_US(SCL_HALF_PERIOD);
    144          	SCL_HIGH;
    145          	DELAY_X_US(SCL_HALF_PERIOD);
    146          	SCL_LOW;
    147          	SDA_HIGH;
    148          	DELAY_X_US(4);
    149            */
    150          }
   \   00002A 87           RETF
    151          
    152          
    153          //***************************************************************************

   \                                 In section .far_func.text, align 1
    154          void iicNoAck(void)		 //非应答信号
    155          {
    156          	SCL_LOW();
   \                     iicNoAck:
   \   000000 7215 5005    BRES      L:0x5005, #0x2
    157          	SDA_HIGH();
   \   000004 7212 5005    BSET      L:0x5005, #0x1
    158          	delay_xus(5);
   \   000008 AE 0005      LDW       X, #0x5
   \   00000B 8D ......    CALLF     delay_xus
    159          	SCL_HIGH();
   \   00000F 7214 5005    BSET      L:0x5005, #0x2
    160          	delay_xus(5);
   \   000013 AE 0005      LDW       X, #0x5
   \   000016 8D ......    CALLF     delay_xus
    161          	SCL_LOW();
   \   00001A 7215 5005    BRES      L:0x5005, #0x2
    162          }
   \   00001E 87           RETF
    163          
    164          //***************************************************************************  

   \                                 In section .far_func.text, align 1
    165          void iicWriteByte(U8 data) //写一个字节  
    166          {  
   \                     iicWriteByte:
   \   000000 8D ......    CALLF     L:?push_w4
    167          	U8 i=0,temp=0;  
   \   000004 3F ..        CLR       S:?b9
   \   000006 3F ..        CLR       S:?b8
    168          	temp=data;  
   \   000008 B7 ..        LD        S:?b8, A
    169          	for(i=0;i<8;i++)  
   \   00000A 4F           CLR       A
   \   00000B B7 ..        LD        S:?b9, A
   \   00000D 20 21        JRA       L:??iicWriteByte_0
    170          	{    
    171          		SCL_LOW();//拉低SCL，因为只有在时钟信号为低电平期间按数据线上的高低电平状态才允许变化；并在此时和上一个循环的scl=1一起形成一个上升沿  
    172          		if(temp&0x80)
    173          		{
    174          		    SDA_HIGH();
    175          		}
    176          		else
    177          		{
    178          		    SDA_LOW();
   \                     ??iicWriteByte_1:
   \   00000F 7213 5005    BRES      L:0x5005, #0x1
    179          		}  
    180          		delay_xus(SCL_HALF_PERIOD);  
   \                     ??iicWriteByte_2:
   \   000013 AE 0032      LDW       X, #0x32
   \   000016 8D ......    CALLF     delay_xus
    181          		SCL_HIGH();//拉高SCL，此时SDA上的数据稳定
   \   00001A 7214 5005    BSET      L:0x5005, #0x2
    182          		temp=temp<<1;
   \   00001E B6 ..        LD        A, S:?b8
   \   000020 48           SLL       A
   \   000021 B7 ..        LD        S:?b8, A
    183          		delay_xus(SCL_HALF_PERIOD);
   \   000023 AE 0032      LDW       X, #0x32
   \   000026 8D ......    CALLF     delay_xus
   \   00002A B6 ..        LD        A, S:?b9
   \   00002C AB 01        ADD       A, #0x1
   \   00002E B7 ..        LD        S:?b9, A
   \                     ??iicWriteByte_0:
   \   000030 B6 ..        LD        A, S:?b9
   \   000032 A1 08        CP        A, #0x8
   \   000034 24 12        JRNC      L:??iicWriteByte_3
   \   000036 7215 5005    BRES      L:0x5005, #0x2
   \   00003A B6 ..        LD        A, S:?b8
   \   00003C A4 80        AND       A, #0x80
   \   00003E A1 00        CP        A, #0x0
   \   000040 27 CD        JREQ      L:??iicWriteByte_1
   \   000042 7212 5005    BSET      L:0x5005, #0x1
   \   000046 20 CB        JRA       L:??iicWriteByte_2
    184          	}  
    185          	//    DELAY_X_US(SCL_HALF_PERIOD);
    186          	SCL_LOW();//拉低SCL，为下次数据传输做好准备  
   \                     ??iicWriteByte_3:
   \   000048 7215 5005    BRES      L:0x5005, #0x2
    187          	SDA_HIGH();//释放SDA总线，接下来由从设备控制，比如从设备接收完数据后，在SCL为高时，拉低SDA作为应答信号
   \   00004C 7212 5005    BSET      L:0x5005, #0x1
    188          	delay_xus(SCL_HALF_PERIOD);  
   \   000050 AE 0032      LDW       X, #0x32
   \   000053 8D ......    CALLF     delay_xus
    189          } 
   \   000057 AC ......    JPF       L:?epilogue_w4
    190          
    191          
    192          //***************************************************************************  

   \                                 In section .far_func.text, align 1
    193          U8 iicReadByte(void)//读一个字节  
    194          {  
   \                     iicReadByte:
   \   000000 8D ......    CALLF     L:?push_l2
   \   000004 8D ......    CALLF     L:?push_w6
    195          	U8 i=0,temp=0;  
   \   000008 3F ..        CLR       S:?b12
   \   00000A 3F ..        CLR       S:?b13
    196          	unsigned long time_cnt = SCL_WAIT_TIME;
   \   00000C AE 1A80      LDW       X, #0x1a80
   \   00000F BF ..        LDW       S:?w5, X
   \   000011 AE 0006      LDW       X, #0x6
   \   000014 BF ..        LDW       S:?w4, X
    197          	//    SCL_LOW;
    198          	//    delay_us(100);
    199          	//    SDA_HIGH;  
    200          	//    delay();
    201          
    202          	for(i=0;i<8;i++)  
   \   000016 4F           CLR       A
   \   000017 B7 ..        LD        S:?b12, A
   \   000019 20 62        JRA       L:??iicReadByte_0
    203          	{  
    204          		delay_xus(SCL_HALF_PERIOD/2);
   \                     ??iicReadByte_1:
   \   00001B AE 0019      LDW       X, #0x19
   \   00001E 8D ......    CALLF     delay_xus
    205          		SDA_IN();
   \   000022 7213 5007    BRES      L:0x5007, #0x1
    206          		delay_xus(SCL_HALF_PERIOD/2);
   \   000026 AE 0019      LDW       X, #0x19
   \   000029 8D ......    CALLF     delay_xus
    207          		SCL_HIGH();
   \   00002D 7214 5005    BSET      L:0x5005, #0x2
    208          		SCL_IN();
   \   000031 7215 5007    BRES      L:0x5007, #0x2
    209          		while((--time_cnt))
   \                     ??iicReadByte_2:
   \   000035 8D ......    CALLF     L:?dec32_l2_l2
   \   000039 BE ..        LDW       X, S:?w4
   \   00003B A3 0000      CPW       X, #0x0
   \   00003E 26 05        JRNE      L:??iicReadByte_3
   \   000040 BE ..        LDW       X, S:?w5
   \   000042 A3 0000      CPW       X, #0x0
   \                     ??iicReadByte_3:
   \   000045 27 05        JREQ      L:??iicReadByte_4
    210          		{
    211          			if( SCL_IN_READ() )
   \   000047 7205 5006 E9 BTJF      L:0x5006, #0x2, L:??iicReadByte_2
    212          			break;
    213          		}
    214          		if( SCL_IN_READ() )
   \                     ??iicReadByte_4:
   \   00004C 7205 5006 26 BTJF      L:0x5006, #0x2, L:??iicReadByte_5
    215          		{
    216          			delay_xus(SCL_HALF_PERIOD/2);
   \   000051 AE 0019      LDW       X, #0x19
   \   000054 8D ......    CALLF     delay_xus
    217          			temp<<=1; 
   \   000058 B6 ..        LD        A, S:?b13
   \   00005A 48           SLL       A
   \   00005B B7 ..        LD        S:?b13, A
    218          			if(SDA_IN_READ())
   \   00005D 7203 5006 06 BTJF      L:0x5006, #0x1, L:??iicReadByte_6
    219          			{
    220          				temp|=0x01;
   \   000062 B6 ..        LD        A, S:?b13
   \   000064 AA 01        OR        A, #0x1
   \   000066 B7 ..        LD        S:?b13, A
    221          			}
    222          			delay_xus(SCL_HALF_PERIOD/2);
   \                     ??iicReadByte_6:
   \   000068 AE 0019      LDW       X, #0x19
   \   00006B 8D ......    CALLF     delay_xus
    223          			SCL_OUT();
   \   00006F 7214 5007    BSET      L:0x5007, #0x2
    224          			SCL_LOW();
   \   000073 7215 5005    BRES      L:0x5005, #0x2
    225          		}
    226          	} 
   \                     ??iicReadByte_5:
   \   000077 B6 ..        LD        A, S:?b12
   \   000079 AB 01        ADD       A, #0x1
   \   00007B B7 ..        LD        S:?b12, A
   \                     ??iicReadByte_0:
   \   00007D B6 ..        LD        A, S:?b12
   \   00007F A1 08        CP        A, #0x8
   \   000081 25 98        JRC       L:??iicReadByte_1
    227          	return temp;  
   \   000083 B6 ..        LD        A, S:?b13
   \   000085 AC ......    JPF       L:?epilogue_l2_w6
    228          } 
    229          
    230          //***************************************************************************  

   \                                 In section .far_func.text, align 1
    231          U8 Data_Protocol(U8 *in_buff, U8 *data_buff)
    232          {
   \                     Data_Protocol:
   \   000000 8D ......    CALLF     L:?push_l2
   \   000004 8D ......    CALLF     L:?push_l3
   \   000008 9089         PUSHW     Y
   \   00000A BF ..        LDW       S:?w6, X
    233          	U8 state = ERROR;
   \   00000C 3F ..        CLR       S:?b15
    234          	unsigned long time_cnt = SCL_WAIT_TIME;
                 	              ^
Warning[Pe177]: variable "time_cnt" was declared but never referenced
   \   00000E AE 1A80      LDW       X, #0x1a80
   \   000011 BF ..        LDW       S:?w5, X
   \   000013 AE 0006      LDW       X, #0x6
   \   000016 BF ..        LDW       S:?w4, X
    235          	U8 i=0;
   \   000018 3F ..        CLR       S:?b14
    236          	static U8 ACK_Flag=0;
    237          
    238          	delay_1ms(10);
   \   00001A AE 000A      LDW       X, #0xa
   \   00001D 8D ......    CALLF     delay_1ms
    239          	if(ERROR == iicBusStart())            //开始信号
   \   000021 8D ......    CALLF     iicBusStart
   \   000025 A1 00        CP        A, #0x0
   \   000027 26 04        JRNE      L:??Data_Protocol_0
    240          	{
    241          		return state;
   \   000029 B6 ..        LD        A, S:?b15
   \   00002B 20 6A        JRA       L:??Data_Protocol_1
    242          	}
    243          	delay_xus(5);
   \                     ??Data_Protocol_0:
   \   00002D AE 0005      LDW       X, #0x5
   \   000030 8D ......    CALLF     delay_xus
    244          	for(i=0;i<4;i++)		  //发送4个CMD
   \   000034 3F ..        CLR       S:?b14
   \   000036 20 06        JRA       L:??Data_Protocol_2
   \                     ??Data_Protocol_3:
   \   000038 B6 ..        LD        A, S:?b14
   \   00003A AB 01        ADD       A, #0x1
   \   00003C B7 ..        LD        S:?b14, A
   \                     ??Data_Protocol_2:
   \   00003E B6 ..        LD        A, S:?b14
   \   000040 A1 04        CP        A, #0x4
   \   000042 24 20        JRNC      L:??Data_Protocol_4
    245          	{
    246          		iicWriteByte(in_buff[i]);
   \   000044 5F           CLRW      X
   \   000045 41           EXG       A, XL
   \   000046 B6 ..        LD        A, S:?b14
   \   000048 41           EXG       A, XL
   \   000049 72BB ....    ADDW      X, S:?w6
   \   00004D F6           LD        A, (X)
   \   00004E 8D ......    CALLF     iicWriteByte
    247          		ACK_Flag = iicWaitACK();
   \   000052 8D ......    CALLF     iicWaitACK
   \   000056 C7 ....      LD        L:??ACK_Flag, A
    248          		if(ACK_Flag)		  //有应答，则继续；无应答，则退出子函数
   \   000059 C6 ....      LD        A, L:??ACK_Flag
   \   00005C A1 00        CP        A, #0x0
   \   00005E 27 D8        JREQ      L:??Data_Protocol_3
    249          		{
    250          			return state;
   \   000060 B6 ..        LD        A, S:?b15
   \   000062 20 33        JRA       L:??Data_Protocol_1
    251          		}
    252          	}
    253          	SCL_OUT();
   \                     ??Data_Protocol_4:
   \   000064 7214 5007    BSET      L:0x5007, #0x2
    254          	for(i=0;i<4;i++)		  //从从机读取4个字节的数据，存入data_buff中
   \   000068 3F ..        CLR       S:?b14
   \   00006A 20 1B        JRA       L:??Data_Protocol_5
    255          	{
    256          		data_buff[i]=iicReadByte();
   \                     ??Data_Protocol_6:
   \   00006C 5F           CLRW      X
   \   00006D 41           EXG       A, XL
   \   00006E B6 ..        LD        A, S:?b14
   \   000070 41           EXG       A, XL
   \   000071 72FB 01      ADDW      X, (0x1,SP)
   \   000074 BF ..        LDW       S:?w4, X
   \   000076 8D ......    CALLF     iicReadByte
   \   00007A 92C7 ..      LD        [S:?w4.w], A
    257          		iicAck();				  //应答信号 
   \   00007D 8D ......    CALLF     iicAck
    258          	}
   \   000081 B6 ..        LD        A, S:?b14
   \   000083 AB 01        ADD       A, #0x1
   \   000085 B7 ..        LD        S:?b14, A
   \                     ??Data_Protocol_5:
   \   000087 B6 ..        LD        A, S:?b14
   \   000089 A1 04        CP        A, #0x4
   \   00008B 25 DF        JRC       L:??Data_Protocol_6
    259          	iicBusStop( );					  //结束信号
   \   00008D 8D ......    CALLF     iicBusStop
    260          	state = SUCCESS;
   \   000091 35 01 ....   MOV       S:?b15, #0x1
    261          	return state;
   \   000095 B6 ..        LD        A, S:?b15
   \                     ??Data_Protocol_1:
   \   000097 5B 02        ADD       SP, #0x2
   \   000099 AC ......    JPF       L:?epilogue_l2_l3
    262          }

   \                                 In section .near.bss, align 1
   \                     ??ACK_Flag:
   \   000000              DS8 1
    263          
    264          
    265          
    266          /**
    267            * @brief External IT PIN0 Interrupt routine.
    268            * @param  None
    269            * @retval None
    270            */

   \                                 In section .far_func.text, align 1
    271          INTERRUPT_HANDLER(EXTI0_IRQHandler, 8)
    272          {
   \                     EXTI0_IRQHandler:
   \                     _interrupt_10:
   \   000000 8A           PUSH      CC
   \   000001 84           POP       A
   \   000002 A4 BF        AND       A, #0xbf
   \   000004 88           PUSH      A
   \   000005 86           POP       CC
   \   000006 8D ......    CALLF     L:?push_l0
   \   00000A 8D ......    CALLF     L:?push_l1
    273          	/* In order to detect unexpected events during development,
    274          	it is recommended to set a breakpoint on the following instruction.
    275          	*/
    276          	EXTI_ClearITPendingBit(EXTI_IT_Pin0);
   \   00000E 5F           CLRW      X
   \   00000F 5C           INCW      X
   \   000010 8D ......    CALLF     EXTI_ClearITPendingBit
    277          	//Set_Int_Event(I2C_INT);
    278          }
   \   000014 8D ......    CALLF     L:?pop_l1
   \   000018 8D ......    CALLF     L:?pop_l0
   \   00001C 80           IRET
    279          
    280          
    281          

   Section sizes:

   Bytes  Function/Label
   -----  --------------
       1  ACK_Flag
     157  Data_Protocol
      29  EXTI0_IRQHandler
      23  delay_1ms
      20  delay_xus
      43  iicAck
      29  iicBusInit
      51  iicBusStart
      21  iicBusStop
      31  iicNoAck
      56  iicPinInit
     137  iicReadByte
      77  iicWaitACK
      91  iicWriteByte

 
 765 bytes in section .far_func.text
   1 byte  in section .near.bss
 
 765 bytes of CODE memory
   1 byte  of DATA memory

Errors: none
Warnings: 6
